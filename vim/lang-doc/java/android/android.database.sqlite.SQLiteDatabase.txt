*android.database.sqlite.SQLiteDatabase* *SQLiteDatabase* Exposes methods to man

public final class SQLiteDatabase
  extends    |android.database.sqlite.SQLiteClosable|

|android.database.sqlite.SQLiteDatabase_Description|
|android.database.sqlite.SQLiteDatabase_Fields|
|android.database.sqlite.SQLiteDatabase_Constructors|
|android.database.sqlite.SQLiteDatabase_Methods|

================================================================================

*android.database.sqlite.SQLiteDatabase_Fields*
|int_android.database.sqlite.SQLiteDatabase.CONFLICT_ABORT|
|int_android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL|
|int_android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE|
|int_android.database.sqlite.SQLiteDatabase.CONFLICT_NONE|
|int_android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE|
|int_android.database.sqlite.SQLiteDatabase.CONFLICT_ROLLBACK|
|int_android.database.sqlite.SQLiteDatabase.CREATE_IF_NECESSARY|
|int_android.database.sqlite.SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING|
|int_android.database.sqlite.SQLiteDatabase.MAX_SQL_CACHE_SIZE|
|int_android.database.sqlite.SQLiteDatabase.NO_LOCALIZED_COLLATORS|
|int_android.database.sqlite.SQLiteDatabase.OPEN_READONLY|
|int_android.database.sqlite.SQLiteDatabase.OPEN_READWRITE|
|int_android.database.sqlite.SQLiteDatabase.SQLITE_MAX_LIKE_PATTERN_LENGTH|

*android.database.sqlite.SQLiteDatabase_Methods*
|android.database.sqlite.SQLiteDatabase.addCustomFunction(String,int,SQLiteDatabase.CustomFunction)|
|android.database.sqlite.SQLiteDatabase.beginTransaction()|Begins a transaction
|android.database.sqlite.SQLiteDatabase.beginTransactionNonExclusive()|Begins a
|android.database.sqlite.SQLiteDatabase.beginTransactionWithListener(SQLiteTransactionListener)|
|android.database.sqlite.SQLiteDatabase.beginTransactionWithListenerNonExclusive(SQLiteTransactionListener)|
|android.database.sqlite.SQLiteDatabase.compileStatement(String)|Compiles an SQ
|android.database.sqlite.SQLiteDatabase.create(SQLiteDatabase.CursorFactory)|Cr
|android.database.sqlite.SQLiteDatabase.delete(String,String,String[])|Convenie
|android.database.sqlite.SQLiteDatabase.deleteDatabase(File)|Deletes a database
|android.database.sqlite.SQLiteDatabase.disableWriteAheadLogging()|This method 
|android.database.sqlite.SQLiteDatabase.enableWriteAheadLogging()|This method e
|android.database.sqlite.SQLiteDatabase.endTransaction()|End a transaction.
|android.database.sqlite.SQLiteDatabase.execSQL(String)|Execute a single SQL st
|android.database.sqlite.SQLiteDatabase.execSQL(String,Object[])|Execute a sing
|android.database.sqlite.SQLiteDatabase.finalize()|
|android.database.sqlite.SQLiteDatabase.findEditTable(String)|Finds the name of
|android.database.sqlite.SQLiteDatabase.getAttachedDbs()|Returns list of full p
|android.database.sqlite.SQLiteDatabase.getMaximumSize()|Returns the maximum si
|android.database.sqlite.SQLiteDatabase.getPageSize()|Returns the current datab
|android.database.sqlite.SQLiteDatabase.getPath()|Gets the path to the database
|android.database.sqlite.SQLiteDatabase.getSyncedTables()|Deprecated.
|android.database.sqlite.SQLiteDatabase.getVersion()|Gets the database version.
|android.database.sqlite.SQLiteDatabase.insert(String,String,ContentValues)|Con
|android.database.sqlite.SQLiteDatabase.insertOrThrow(String,String,ContentValues)|
|android.database.sqlite.SQLiteDatabase.insertWithOnConflict(String,String,ContentValues,int)|
|android.database.sqlite.SQLiteDatabase.inTransaction()|Returns true if the cur
|android.database.sqlite.SQLiteDatabase.isDatabaseIntegrityOk()|Runs 'pragma in
|android.database.sqlite.SQLiteDatabase.isDbLockedByCurrentThread()|Returns tru
|android.database.sqlite.SQLiteDatabase.isDbLockedByOtherThreads()|Always retur
|android.database.sqlite.SQLiteDatabase.isInMemoryDatabase()|Returns true if th
|android.database.sqlite.SQLiteDatabase.isOpen()|Returns true if the database i
|android.database.sqlite.SQLiteDatabase.isReadOnly()|Returns true if the databa
|android.database.sqlite.SQLiteDatabase.isWriteAheadLoggingEnabled()|Returns tr
|android.database.sqlite.SQLiteDatabase.markTableSyncable(String,String)|Mark t
|android.database.sqlite.SQLiteDatabase.markTableSyncable(String,String,String)|
|android.database.sqlite.SQLiteDatabase.needUpgrade(int)|Returns true if the ne
|android.database.sqlite.SQLiteDatabase.onAllReferencesReleased()|
|android.database.sqlite.SQLiteDatabase.openDatabase(String,SQLiteDatabase.CursorFactory,int)|
|android.database.sqlite.SQLiteDatabase.openDatabase(String,SQLiteDatabase.CursorFactory,int,DatabaseErrorHandler)|
|android.database.sqlite.SQLiteDatabase.openOrCreateDatabase(File,SQLiteDatabase.CursorFactory)|
|android.database.sqlite.SQLiteDatabase.openOrCreateDatabase(String,SQLiteDatabase.CursorFactory)|
|android.database.sqlite.SQLiteDatabase.openOrCreateDatabase(String,SQLiteDatabase.CursorFactory,DatabaseErrorHandler)|
|android.database.sqlite.SQLiteDatabase.query(boolean,String,String[],String,String[],String,String,String,String)|
|android.database.sqlite.SQLiteDatabase.query(boolean,String,String[],String,String[],String,String,String,String,CancellationSignal)|
|android.database.sqlite.SQLiteDatabase.query(String,String[],String,String[],String,String,String)|
|android.database.sqlite.SQLiteDatabase.query(String,String[],String,String[],String,String,String,String)|
|android.database.sqlite.SQLiteDatabase.queryWithFactory(SQLiteDatabase.CursorFactory,boolean,String,String[],String,String[],String,String,String,String)|
|android.database.sqlite.SQLiteDatabase.queryWithFactory(SQLiteDatabase.CursorFactory,boolean,String,String[],String,String[],String,String,String,String,CancellationSignal)|
|android.database.sqlite.SQLiteDatabase.rawQuery(String,String[])|Runs the prov
|android.database.sqlite.SQLiteDatabase.rawQuery(String,String[],CancellationSignal)|
|android.database.sqlite.SQLiteDatabase.rawQueryWithFactory(SQLiteDatabase.CursorFactory,String,String[],String)|
|android.database.sqlite.SQLiteDatabase.rawQueryWithFactory(SQLiteDatabase.CursorFactory,String,String[],String,CancellationSignal)|
|android.database.sqlite.SQLiteDatabase.releaseMemory()|Attempts to release mem
|android.database.sqlite.SQLiteDatabase.reopenReadWrite()|Reopens the database 
|android.database.sqlite.SQLiteDatabase.replace(String,String,ContentValues)|Co
|android.database.sqlite.SQLiteDatabase.replaceOrThrow(String,String,ContentValues)|
|android.database.sqlite.SQLiteDatabase.setForeignKeyConstraintsEnabled(boolean)|
|android.database.sqlite.SQLiteDatabase.setLocale(Locale)|Sets the locale for t
|android.database.sqlite.SQLiteDatabase.setLockingEnabled(boolean)|Control whet
|android.database.sqlite.SQLiteDatabase.setMaximumSize(long)|Sets the maximum s
|android.database.sqlite.SQLiteDatabase.setMaxSqlCacheSize(int)|Sets the maximu
|android.database.sqlite.SQLiteDatabase.setPageSize(long)|Sets the database pag
|android.database.sqlite.SQLiteDatabase.setTransactionSuccessful()|Marks the cu
|android.database.sqlite.SQLiteDatabase.setVersion(int)|Sets the database versi
|android.database.sqlite.SQLiteDatabase.toString()|
|android.database.sqlite.SQLiteDatabase.update(String,ContentValues,String,String[])|
|android.database.sqlite.SQLiteDatabase.updateWithOnConflict(String,ContentValues,String,String[],int)|
|android.database.sqlite.SQLiteDatabase.yieldIfContended()|Temporarily end the 
|android.database.sqlite.SQLiteDatabase.yieldIfContendedSafely()|Temporarily en
|android.database.sqlite.SQLiteDatabase.yieldIfContendedSafely(long)|Temporaril

*android.database.sqlite.SQLiteDatabase_Description*

Exposes methods to manage a SQLite database. 

SQLiteDatabase has methods to create, delete, execute SQL commands, and perform 
other common database management tasks. 

See the Notepad sample application in the SDK for an example of creating and 
managing a database. 

Database names must be unique within an application, not across all 
applications. 

Localized Collation - ORDER BY 

In addition to SQLite's default BINARY collator, Android supplies two more, 
LOCALIZED, which changes with the system's current locale, and UNICODE, which 
is the Unicode Collation Algorithm and not tailored to the current locale. 



*int_android.database.sqlite.SQLiteDatabase.CONFLICT_ABORT*

When a constraint violation occurs,no ROLLBACK is executed so changes from 
prior commands within the same transaction are preserved. This is the default 
behavior. 


*int_android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL*

When a constraint violation occurs, the command aborts with a return code 
SQLITE_CONSTRAINT. But any changes to the database that the command made prior 
to encountering the constraint violation are preserved and are not backed out. 


*int_android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE*

When a constraint violation occurs, the one row that contains the constraint 
violation is not inserted or changed. But the command continues executing 
normally. Other rows before and after the row that contained the constraint 
violation continue to be inserted or updated normally. No error is returned. 


*int_android.database.sqlite.SQLiteDatabase.CONFLICT_NONE*

Use the following when no conflict action is specified. 


*int_android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE*

When a UNIQUE constraint violation occurs, the pre-existing rows that are 
causing the constraint violation are removed prior to inserting or updating the 
current row. Thus the insert or update always occurs. The command continues 
executing normally. No error is returned. If a NOT NULL constraint violation 
occurs, the NULL value is replaced by the default value for that column. If the 
column has no default value, then the ABORT algorithm is used. If a CHECK 
constraint violation occurs then the IGNORE algorithm is used. When this 
conflict resolution strategy deletes rows in order to satisfy a constraint, it 
does not invoke delete triggers on those rows. This behavior might change in a 
future release. 


*int_android.database.sqlite.SQLiteDatabase.CONFLICT_ROLLBACK*

When a constraint violation occurs, an immediate ROLLBACK occurs, thus ending 
the current transaction, and the command aborts with a return code of 
SQLITE_CONSTRAINT. If no transaction is active (other than the implied 
transaction that is created on every command) then this algorithm works the 
same as ABORT. 


*int_android.database.sqlite.SQLiteDatabase.CREATE_IF_NECESSARY*

Open flag: Flag for (|android.database.sqlite.SQLiteDatabase|) to create the 
database file if it does not already exist. 


*int_android.database.sqlite.SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING*

Open flag: Flag for (|android.database.sqlite.SQLiteDatabase|) to open the 
database file with write-ahead logging enabled by default. Using this flag is 
more efficient than calling (|android.database.sqlite.SQLiteDatabase|) . 

Write-ahead logging cannot be used with read-only databases so the value of 
this flag is ignored if the database is opened read-only. 


*int_android.database.sqlite.SQLiteDatabase.MAX_SQL_CACHE_SIZE*

Absolute max value that can be set by 
(|android.database.sqlite.SQLiteDatabase|) . 

Each prepared-statement is between 1K - 6K, depending on the complexity of the 
SQL statement & schema. A large SQL cache may use a significant amount of 
memory. 


*int_android.database.sqlite.SQLiteDatabase.NO_LOCALIZED_COLLATORS*

Open flag: Flag for (|android.database.sqlite.SQLiteDatabase|) to open the 
database without support for localized collators.This causes the collator 
LOCALIZED not to be created. You must be consistent when using this flag to use 
the setting the database was created with. If this is set, 
(|android.database.sqlite.SQLiteDatabase|) will do nothing. 


*int_android.database.sqlite.SQLiteDatabase.OPEN_READONLY*

Open flag: Flag for (|android.database.sqlite.SQLiteDatabase|) to open the 
database for reading only. This is the only reliable way to open a database if 
the disk may be full. 


*int_android.database.sqlite.SQLiteDatabase.OPEN_READWRITE*

Open flag: Flag for (|android.database.sqlite.SQLiteDatabase|) to open the 
database for reading and writing. If the disk is full, this may fail even 
before you actually write anything.Note that the value of this flag is 0, so it 
is the default. 


*int_android.database.sqlite.SQLiteDatabase.SQLITE_MAX_LIKE_PATTERN_LENGTH*

Maximum Length Of A LIKE Or GLOB Pattern The pattern matching algorithm used in 
the default LIKE and GLOB implementation of SQLite can exhibit O(N^2) 
performance (where N is the number of characters in the pattern) for certain 
pathological cases. To avoid denial-of-service attacks the length of the LIKE 
or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default 
value of this limit is 50000. A modern workstation can evaluate even a 
pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial 
of service problem only comes into play when the pattern length gets into 
millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at 
most a few dozen bytes in length, paranoid application developers may want to 
reduce this parameter to something in the range of a few hundred if they know 
that external users are able to generate arbitrary patterns. 



*android.database.sqlite.SQLiteDatabase.addCustomFunction(String,int,SQLiteDatabase.CustomFunction)*

public void addCustomFunction(
  java.lang.String name,
  int numArgs,
  android.database.sqlite.SQLiteDatabase.CustomFunction function)

Registers a CustomFunction callback as a function that can be called from 
SQLite database triggers. 


    name - the name of the sqlite3 function 
    numArgs - the number of arguments for the function 
    function - callback to call when the function is executed 

*android.database.sqlite.SQLiteDatabase.beginTransaction()*

public void beginTransaction()

Begins a transaction in EXCLUSIVE mode. 

Transactions can be nested. When the outer transaction is ended all of the work 
done in that transaction and all of the nested transactions will be committed 
or rolled back. The changes will be rolled back if any transaction is ended 
without being marked as clean (by calling setTransactionSuccessful). Otherwise 
they will be committed. 

Here is the standard idiom for transactions: 



db.beginTransaction(); try { ... db.setTransactionSuccessful(); } finally { 
db.endTransaction(); } 



*android.database.sqlite.SQLiteDatabase.beginTransactionNonExclusive()*

public void beginTransactionNonExclusive()

Begins a transaction in IMMEDIATE mode. Transactions can be nested. When the 
outer transaction is ended all of the work done in that transaction and all of 
the nested transactions will be committed or rolled back. The changes will be 
rolled back if any transaction is ended without being marked as clean (by 
calling setTransactionSuccessful). Otherwise they will be committed. 

Here is the standard idiom for transactions: 



db.beginTransactionNonExclusive(); try { ... db.setTransactionSuccessful(); } 
finally { db.endTransaction(); } 



*android.database.sqlite.SQLiteDatabase.beginTransactionWithListener(SQLiteTransactionListener)*

public void beginTransactionWithListener(android.database.sqlite.SQLiteTransactionListener transactionListener)

Begins a transaction in EXCLUSIVE mode. 

Transactions can be nested. When the outer transaction is ended all of the work 
done in that transaction and all of the nested transactions will be committed 
or rolled back. The changes will be rolled back if any transaction is ended 
without being marked as clean (by calling setTransactionSuccessful). Otherwise 
they will be committed. 

Here is the standard idiom for transactions: 



db.beginTransactionWithListener(listener); try { ... 
db.setTransactionSuccessful(); } finally { db.endTransaction(); } 


    transactionListener - listener that should be notified when the transaction begins, commits, or is 
       rolled back, either explicitly or by a call to {@link 
       #yieldIfContendedSafely}. 

*android.database.sqlite.SQLiteDatabase.beginTransactionWithListenerNonExclusive(SQLiteTransactionListener)*

public void beginTransactionWithListenerNonExclusive(android.database.sqlite.SQLiteTransactionListener transactionListener)

Begins a transaction in IMMEDIATE mode. Transactions can be nested. When the 
outer transaction is ended all of the work done in that transaction and all of 
the nested transactions will be committed or rolled back. The changes will be 
rolled back if any transaction is ended without being marked as clean (by 
calling setTransactionSuccessful). Otherwise they will be committed. 

Here is the standard idiom for transactions: 



db.beginTransactionWithListenerNonExclusive(listener); try { ... 
db.setTransactionSuccessful(); } finally { db.endTransaction(); } 


    transactionListener - listener that should be notified when the transaction begins, commits, or is 
       rolled back, either explicitly or by a call to {@link 
       #yieldIfContendedSafely}. 

*android.database.sqlite.SQLiteDatabase.compileStatement(String)*

public |android.database.sqlite.SQLiteStatement| compileStatement(java.lang.String sql)
  throws |android.database.SQLException|
         
Compiles an SQL statement into a reusable pre-compiled statement object. The 
parameters are identical to (|android.database.sqlite.SQLiteDatabase|) . You 
may put ?s in the statement and fill in those values with 
(|android.database.sqlite.SQLiteProgram|) and 
(|android.database.sqlite.SQLiteProgram|) each time you want to run the 
statement. Statements may not return result sets larger than 1x1. 

No two threads should be using the same 
(|android.database.sqlite.SQLiteStatement|) at the same time. 


    sql - The raw SQL statement, may contain ? for unknown values to be bound later. 

    Returns: A pre-compiled {@link SQLiteStatement} object. Note that {@link 
             SQLiteStatement}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.create(SQLiteDatabase.CursorFactory)*

public static |android.database.sqlite.SQLiteDatabase| create(android.database.sqlite.SQLiteDatabase.CursorFactory factory)

Create a memory backed SQLite database. Its contents will be destroyed when the 
database is closed. 

Sets the locale of the database to the the system's current locale. Call 
(|android.database.sqlite.SQLiteDatabase|) if you would like something else. 


    factory - an optional factory class that is called to instantiate a cursor when query is 
       called 

    Returns: a SQLiteDatabase object, or null if the database can't be created 

*android.database.sqlite.SQLiteDatabase.delete(String,String,String[])*

public int delete(
  java.lang.String table,
  java.lang.String whereClause,
  java.lang.String[] whereArgs)

Convenience method for deleting rows in the database. 


    table - the table to delete from 
    whereClause - the optional WHERE clause to apply when deleting. Passing null will delete all 
       rows. 
    whereArgs - You may include ?s in the where clause, which will be replaced by the values 
       from whereArgs. The values will be bound as Strings. 

    Returns: the number of rows affected if a whereClause is passed in, 0 otherwise. To 
             remove all rows and get a count pass "1" as the whereClause. 

*android.database.sqlite.SQLiteDatabase.deleteDatabase(File)*

public static boolean deleteDatabase(java.io.File file)

Deletes a database including its journal file and other auxiliary files that 
may have been created by the database engine. 


    file - The database file path. 

    Returns: True if the database was successfully deleted. 

*android.database.sqlite.SQLiteDatabase.disableWriteAheadLogging()*

public void disableWriteAheadLogging()

This method disables the features enabled by 
(|android.database.sqlite.SQLiteDatabase|) . 



*android.database.sqlite.SQLiteDatabase.enableWriteAheadLogging()*

public boolean enableWriteAheadLogging()

This method enables parallel execution of queries from multiple threads on the 
same database. It does this by opening multiple connections to the database and 
using a different database connection for each query. The database journal mode 
is also changed to enable writes to proceed concurrently with reads. 

When write-ahead logging is not enabled (the default), it is not possible for 
reads and writes to occur on the database at the same time. Before modifying 
the database, the writer implicitly acquires an exclusive lock on the database 
which prevents readers from accessing the database until the write is 
completed. 

In contrast, when write-ahead logging is enabled (by calling this method), 
write operations occur in a separate log file which allows reads to proceed 
concurrently. While a write is in progress, readers on other threads will 
perceive the state of the database as it was before the write began. When the 
write completes, readers on other threads will then perceive the new state of 
the database. 

It is a good idea to enable write-ahead logging whenever a database will be 
concurrently accessed and modified by multiple threads at the same time. 
However, write-ahead logging uses significantly more memory than ordinary 
journaling because there are multiple connections to the same database. So if a 
database will only be used by a single thread, or if optimizing concurrency is 
not very important, then write-ahead logging should be disabled. 

After calling this method, execution of queries in parallel is enabled as long 
as the database remains open. To disable execution of queries in parallel, 
either call (|android.database.sqlite.SQLiteDatabase|) or close the database 
and reopen it. 

The maximum number of connections used to execute queries in parallel is 
dependent upon the device memory and possibly other properties. 

If a query is part of a transaction, then it is executed on the same database 
handle the transaction was begun. 

Writers should use (|android.database.sqlite.SQLiteDatabase|) or 
(|android.database.sqlite.SQLiteDatabase|) to start a transaction. 
Non-exclusive mode allows database file to be in readable by other threads 
executing queries. 

If the database has any attached databases, then execution of queries in 
parallel is NOT possible. Likewise, write-ahead logging is not supported for 
read-only databases or memory databases. In such cases, 
(|android.database.sqlite.SQLiteDatabase|) returns false. 

The best way to enable write-ahead logging is to pass the 
(|android.database.sqlite.SQLiteDatabase|) flag to 
(|android.database.sqlite.SQLiteDatabase|) . This is more efficient than 
calling (|android.database.sqlite.SQLiteDatabase|) . 

SQLiteDatabase db = SQLiteDatabase.openDatabase("db_filename", cursorFactory, 
SQLiteDatabase.CREATE_IF_NECESSARY | SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING, 
myDatabaseErrorHandler); db.enableWriteAheadLogging(); 

Another way to enable write-ahead logging is to call 
(|android.database.sqlite.SQLiteDatabase|) after opening the database. 

SQLiteDatabase db = SQLiteDatabase.openDatabase("db_filename", cursorFactory, 
SQLiteDatabase.CREATE_IF_NECESSARY, myDatabaseErrorHandler); 
db.enableWriteAheadLogging(); 

See also SQLite Write-Ahead Logging for more details about how write-ahead 
logging works. 



    Returns: True if write-ahead logging is enabled. 

*android.database.sqlite.SQLiteDatabase.endTransaction()*

public void endTransaction()

End a transaction. See beginTransaction for notes about how to use this and 
when transactions are committed and rolled back. 



*android.database.sqlite.SQLiteDatabase.execSQL(String)*

public void execSQL(java.lang.String sql)
  throws |android.database.SQLException|
         
Execute a single SQL statement that is NOT a SELECT or any other SQL statement 
that returns data. 

It has no means to return any data (such as the number of affected rows). 
Instead, you're encouraged to use (|android.database.sqlite.SQLiteDatabase|) , 
(|android.database.sqlite.SQLiteDatabase|) , et al, when possible. 

When using (|android.database.sqlite.SQLiteDatabase|) , journal_mode is 
automatically managed by this class. So, do not set journal_mode using "PRAGMA 
journal_mode'" statement if your app is using 
(|android.database.sqlite.SQLiteDatabase|) 


    sql - the SQL statement to be executed. Multiple statements separated by semicolons 
       are not supported. 

*android.database.sqlite.SQLiteDatabase.execSQL(String,Object[])*

public void execSQL(
  java.lang.String sql,
  java.lang.Object[] bindArgs)
  throws |android.database.SQLException|
         
Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE. 

For INSERT statements, use any of the following instead. 

(|android.database.sqlite.SQLiteDatabase|) 
(|android.database.sqlite.SQLiteDatabase|) 
(|android.database.sqlite.SQLiteDatabase|) 

For UPDATE statements, use any of the following instead. 

(|android.database.sqlite.SQLiteDatabase|) 
(|android.database.sqlite.SQLiteDatabase|) 

For DELETE statements, use any of the following instead. 

(|android.database.sqlite.SQLiteDatabase|) 

For example, the following are good candidates for using this method: 

ALTER TABLE CREATE or DROP table / trigger / view / index / virtual table 
REINDEX RELEASE SAVEPOINT PRAGMA that returns no data 



When using (|android.database.sqlite.SQLiteDatabase|) , journal_mode is 
automatically managed by this class. So, do not set journal_mode using "PRAGMA 
journal_mode'" statement if your app is using 
(|android.database.sqlite.SQLiteDatabase|) 


    sql - the SQL statement to be executed. Multiple statements separated by semicolons 
       are not supported. 
    bindArgs - only byte[], String, Long and Double are supported in bindArgs. 

*android.database.sqlite.SQLiteDatabase.finalize()*

protected void finalize()
  throws |java.lang.Throwable|
         




*android.database.sqlite.SQLiteDatabase.findEditTable(String)*

public static |java.lang.String| findEditTable(java.lang.String tables)

Finds the name of the first table, which is editable. 


    tables - a list of tables 

    Returns: the first table listed 

*android.database.sqlite.SQLiteDatabase.getAttachedDbs()*

public |java.util.List|<Pair<String,String>> getAttachedDbs()

Returns list of full pathnames of all attached databases including the main 
database by executing 'pragma database_list' on the database. 



    Returns: ArrayList of pairs of (database name, database file path) or null if the 
             database is not open. 

*android.database.sqlite.SQLiteDatabase.getMaximumSize()*

public long getMaximumSize()

Returns the maximum size the database may grow to. 



    Returns: the new maximum database size 

*android.database.sqlite.SQLiteDatabase.getPageSize()*

public long getPageSize()

Returns the current database page size, in bytes. 



    Returns: the database page size, in bytes 

*android.database.sqlite.SQLiteDatabase.getPath()*

public final |java.lang.String| getPath()

Gets the path to the database file. 



    Returns: The path to the database file. 

*android.database.sqlite.SQLiteDatabase.getSyncedTables()*

public |java.util.Map|<String,String> getSyncedTables()

Deprecated. 

    Deprecated: This method no longer serves any useful purpose and has been deprecated.


*android.database.sqlite.SQLiteDatabase.getVersion()*

public int getVersion()

Gets the database version. 



    Returns: the database version 

*android.database.sqlite.SQLiteDatabase.insert(String,String,ContentValues)*

public long insert(
  java.lang.String table,
  java.lang.String nullColumnHack,
  android.content.ContentValues values)

Convenience method for inserting a row into the database. 


    table - the table to insert the row into 
    nullColumnHack - optional; may be null. SQL doesn't allow inserting a completely empty row 
       without naming at least one column name. If your provided values is 
       empty, no column names are known and an empty row can't be inserted. If 
       not set to null, the nullColumnHack parameter provides the name of 
       nullable column name to explicitly insert a NULL into in the case where 
       your values is empty. 
    values - this map contains the initial column values for the row. The keys should be the 
       column names and the values the column values 

    Returns: the row ID of the newly inserted row, or -1 if an error occurred 

*android.database.sqlite.SQLiteDatabase.insertOrThrow(String,String,ContentValues)*

public long insertOrThrow(
  java.lang.String table,
  java.lang.String nullColumnHack,
  android.content.ContentValues values)
  throws |android.database.SQLException|
         
Convenience method for inserting a row into the database. 


    table - the table to insert the row into 
    nullColumnHack - optional; may be null. SQL doesn't allow inserting a completely empty row 
       without naming at least one column name. If your provided values is 
       empty, no column names are known and an empty row can't be inserted. If 
       not set to null, the nullColumnHack parameter provides the name of 
       nullable column name to explicitly insert a NULL into in the case where 
       your values is empty. 
    values - this map contains the initial column values for the row. The keys should be the 
       column names and the values the column values 

    Returns: the row ID of the newly inserted row, or -1 if an error occurred 

*android.database.sqlite.SQLiteDatabase.insertWithOnConflict(String,String,ContentValues,int)*

public long insertWithOnConflict(
  java.lang.String table,
  java.lang.String nullColumnHack,
  android.content.ContentValues initialValues,
  int conflictAlgorithm)

General method for inserting a row into the database. 


    table - the table to insert the row into 
    nullColumnHack - optional; may be null. SQL doesn't allow inserting a completely empty row 
       without naming at least one column name. If your provided initialValues 
       is empty, no column names are known and an empty row can't be inserted. 
       If not set to null, the nullColumnHack parameter provides the name of 
       nullable column name to explicitly insert a NULL into in the case where 
       your initialValues is empty. 
    initialValues - this map contains the initial column values for the row. The keys should be the 
       column names and the values the column values 
    conflictAlgorithm - for insert conflict resolver 

    Returns: the row ID of the newly inserted row OR the primary key of the existing row if 
             the input param 'conflictAlgorithm' = {@link #CONFLICT_IGNORE} OR 
             -1 if any error 

*android.database.sqlite.SQLiteDatabase.inTransaction()*

public boolean inTransaction()

Returns true if the current thread has a transaction pending. 



    Returns: True if the current thread is in a transaction. 

*android.database.sqlite.SQLiteDatabase.isDatabaseIntegrityOk()*

public boolean isDatabaseIntegrityOk()

Runs 'pragma integrity_check' on the given database (and all the attached 
databases) and returns true if the given database (and all its attached 
databases) pass integrity_check, false otherwise. 

If the result is false, then this method logs the errors reported by the 
integrity_check command execution. 

Note that 'pragma integrity_check' on a database can take a long time. 



    Returns: true if the given database (and all its attached databases) pass 
             integrity_check, false otherwise. 

*android.database.sqlite.SQLiteDatabase.isDbLockedByCurrentThread()*

public boolean isDbLockedByCurrentThread()

Returns true if the current thread is holding an active connection to the 
database. 

The name of this method comes from a time when having an active connection to 
the database meant that the thread was holding an actual lock on the database. 
Nowadays, there is no longer a true "database lock" although threads may block 
if they cannot acquire a database connection to perform a particular operation. 



    Returns: True if the current thread is holding an active connection to the database. 

*android.database.sqlite.SQLiteDatabase.isDbLockedByOtherThreads()*

public boolean isDbLockedByOtherThreads()

Always returns false. 

There is no longer the concept of a database lock, so this method always 
returns false. 

    Deprecated: Always returns false.  Do not use this method.


    Returns: 

*android.database.sqlite.SQLiteDatabase.isInMemoryDatabase()*

public boolean isInMemoryDatabase()

Returns true if the database is in-memory db. 



    Returns: True if the database is in-memory. 

*android.database.sqlite.SQLiteDatabase.isOpen()*

public boolean isOpen()

Returns true if the database is currently open. 



    Returns: True if the database is currently open (has not been closed). 

*android.database.sqlite.SQLiteDatabase.isReadOnly()*

public boolean isReadOnly()

Returns true if the database is opened as read only. 



    Returns: True if database is opened as read only. 

*android.database.sqlite.SQLiteDatabase.isWriteAheadLoggingEnabled()*

public boolean isWriteAheadLoggingEnabled()

Returns true if write-ahead logging has been enabled for this database. 



    Returns: True if write-ahead logging has been enabled for this database. 

*android.database.sqlite.SQLiteDatabase.markTableSyncable(String,String)*

public void markTableSyncable(
  java.lang.String table,
  java.lang.String deletedTable)

Mark this table as syncable. When an update occurs in this table the 
_sync_dirty field will be set to ensure proper syncing operation. 

    Deprecated: This method no longer serves any useful purpose and has been deprecated.

    table - the table to mark as syncable 
    deletedTable - The deleted table that corresponds to the syncable table 

*android.database.sqlite.SQLiteDatabase.markTableSyncable(String,String,String)*

public void markTableSyncable(
  java.lang.String table,
  java.lang.String foreignKey,
  java.lang.String updateTable)

Mark this table as syncable, with the _sync_dirty residing in another table. 
When an update occurs in this table the _sync_dirty field of the row in 
updateTable with the _id in foreignKey will be set to ensure proper syncing 
operation. 

    Deprecated: This method no longer serves any useful purpose and has been deprecated.

    table - an update on this table will trigger a sync time removal 
    foreignKey - this is the column in table whose value is an _id in updateTable 
    updateTable - this is the table that will have its _sync_dirty 

*android.database.sqlite.SQLiteDatabase.needUpgrade(int)*

public boolean needUpgrade(int newVersion)

Returns true if the new version code is greater than the current database 
version. 


    newVersion - The new version code. 

    Returns: True if the new version code is greater than the current database version. 

*android.database.sqlite.SQLiteDatabase.onAllReferencesReleased()*

protected void onAllReferencesReleased()





*android.database.sqlite.SQLiteDatabase.openDatabase(String,SQLiteDatabase.CursorFactory,int)*

public static |android.database.sqlite.SQLiteDatabase| openDatabase(
  java.lang.String path,
  android.database.sqlite.SQLiteDatabase.CursorFactory factory,
  int flags)

Open the database according to the flags 
(|android.database.sqlite.SQLiteDatabase|) 
(|android.database.sqlite.SQLiteDatabase|) 
(|android.database.sqlite.SQLiteDatabase|) and/or 
(|android.database.sqlite.SQLiteDatabase|) . 

Sets the locale of the database to the the system's current locale. Call 
(|android.database.sqlite.SQLiteDatabase|) if you would like something else. 


    path - to database file to open and/or create 
    factory - an optional factory class that is called to instantiate a cursor when query is 
       called, or null for default 
    flags - to control database access mode 

    Returns: the newly opened database 

*android.database.sqlite.SQLiteDatabase.openDatabase(String,SQLiteDatabase.CursorFactory,int,DatabaseErrorHandler)*

public static |android.database.sqlite.SQLiteDatabase| openDatabase(
  java.lang.String path,
  android.database.sqlite.SQLiteDatabase.CursorFactory factory,
  int flags,
  android.database.DatabaseErrorHandler errorHandler)

Open the database according to the flags 
(|android.database.sqlite.SQLiteDatabase|) 
(|android.database.sqlite.SQLiteDatabase|) 
(|android.database.sqlite.SQLiteDatabase|) and/or 
(|android.database.sqlite.SQLiteDatabase|) . 

Sets the locale of the database to the the system's current locale. Call 
(|android.database.sqlite.SQLiteDatabase|) if you would like something else. 

Accepts input param: a concrete instance of 
(|android.database.DatabaseErrorHandler|) to be used to handle corruption when 
sqlite reports database corruption. 


    path - to database file to open and/or create 
    factory - an optional factory class that is called to instantiate a cursor when query is 
       called, or null for default 
    flags - to control database access mode 
    errorHandler - the {@link DatabaseErrorHandler} obj to be used to handle corruption when 
       sqlite reports database corruption 

    Returns: the newly opened database 

*android.database.sqlite.SQLiteDatabase.openOrCreateDatabase(File,SQLiteDatabase.CursorFactory)*

public static |android.database.sqlite.SQLiteDatabase| openOrCreateDatabase(
  java.io.File file,
  android.database.sqlite.SQLiteDatabase.CursorFactory factory)

Equivalent to openDatabase(file.getPath(), factory, CREATE_IF_NECESSARY). 



*android.database.sqlite.SQLiteDatabase.openOrCreateDatabase(String,SQLiteDatabase.CursorFactory)*

public static |android.database.sqlite.SQLiteDatabase| openOrCreateDatabase(
  java.lang.String path,
  android.database.sqlite.SQLiteDatabase.CursorFactory factory)

Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY). 



*android.database.sqlite.SQLiteDatabase.openOrCreateDatabase(String,SQLiteDatabase.CursorFactory,DatabaseErrorHandler)*

public static |android.database.sqlite.SQLiteDatabase| openOrCreateDatabase(
  java.lang.String path,
  android.database.sqlite.SQLiteDatabase.CursorFactory factory,
  android.database.DatabaseErrorHandler errorHandler)

Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY, errorHandler). 



*android.database.sqlite.SQLiteDatabase.query(boolean,String,String[],String,String[],String,String,String,String)*

public |android.database.Cursor| query(
  boolean distinct,
  java.lang.String table,
  java.lang.String[] columns,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String groupBy,
  java.lang.String having,
  java.lang.String orderBy,
  java.lang.String limit)

Query the given URL, returning a (|android.database.Cursor|) over the result 
set. 


    distinct - true if you want each row to be unique, false otherwise. 
    table - The table name to compile the query against. 
    columns - A list of which columns to return. Passing null will return all columns, which 
       is discouraged to prevent reading data from storage that isn't going to 
       be used. 
    selection - A filter declaring which rows to return, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). Passing null will return all rows for the 
       given table. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in order that they appear in the selection. The values 
       will be bound as Strings. 
    groupBy - A filter declaring how to group rows, formatted as an SQL GROUP BY clause 
       (excluding the GROUP BY itself). Passing null will cause the rows to not 
       be grouped. 
    having - A filter declare which row groups to include in the cursor, if row grouping is 
       being used, formatted as an SQL HAVING clause (excluding the HAVING 
       itself). Passing null will cause all row groups to be included, and is 
       required when row grouping is not being used. 
    orderBy - How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER 
       BY itself). Passing null will use the default sort order, which may be 
       unordered. 
    limit - Limits the number of rows returned by the query, formatted as LIMIT clause. 
       Passing null denotes no LIMIT clause. 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.query(boolean,String,String[],String,String[],String,String,String,String,CancellationSignal)*

public |android.database.Cursor| query(
  boolean distinct,
  java.lang.String table,
  java.lang.String[] columns,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String groupBy,
  java.lang.String having,
  java.lang.String orderBy,
  java.lang.String limit,
  android.os.CancellationSignal cancellationSignal)

Query the given URL, returning a (|android.database.Cursor|) over the result 
set. 


    distinct - true if you want each row to be unique, false otherwise. 
    table - The table name to compile the query against. 
    columns - A list of which columns to return. Passing null will return all columns, which 
       is discouraged to prevent reading data from storage that isn't going to 
       be used. 
    selection - A filter declaring which rows to return, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). Passing null will return all rows for the 
       given table. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in order that they appear in the selection. The values 
       will be bound as Strings. 
    groupBy - A filter declaring how to group rows, formatted as an SQL GROUP BY clause 
       (excluding the GROUP BY itself). Passing null will cause the rows to not 
       be grouped. 
    having - A filter declare which row groups to include in the cursor, if row grouping is 
       being used, formatted as an SQL HAVING clause (excluding the HAVING 
       itself). Passing null will cause all row groups to be included, and is 
       required when row grouping is not being used. 
    orderBy - How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER 
       BY itself). Passing null will use the default sort order, which may be 
       unordered. 
    limit - Limits the number of rows returned by the query, formatted as LIMIT clause. 
       Passing null denotes no LIMIT clause. 
    cancellationSignal - A signal to cancel the operation in progress, or null if none. If the operation 
       is canceled, then {@link OperationCanceledException} will be thrown when 
       the query is executed. 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.query(String,String[],String,String[],String,String,String)*

public |android.database.Cursor| query(
  java.lang.String table,
  java.lang.String[] columns,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String groupBy,
  java.lang.String having,
  java.lang.String orderBy)

Query the given table, returning a (|android.database.Cursor|) over the result 
set. 


    table - The table name to compile the query against. 
    columns - A list of which columns to return. Passing null will return all columns, which 
       is discouraged to prevent reading data from storage that isn't going to 
       be used. 
    selection - A filter declaring which rows to return, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). Passing null will return all rows for the 
       given table. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in order that they appear in the selection. The values 
       will be bound as Strings. 
    groupBy - A filter declaring how to group rows, formatted as an SQL GROUP BY clause 
       (excluding the GROUP BY itself). Passing null will cause the rows to not 
       be grouped. 
    having - A filter declare which row groups to include in the cursor, if row grouping is 
       being used, formatted as an SQL HAVING clause (excluding the HAVING 
       itself). Passing null will cause all row groups to be included, and is 
       required when row grouping is not being used. 
    orderBy - How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER 
       BY itself). Passing null will use the default sort order, which may be 
       unordered. 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.query(String,String[],String,String[],String,String,String,String)*

public |android.database.Cursor| query(
  java.lang.String table,
  java.lang.String[] columns,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String groupBy,
  java.lang.String having,
  java.lang.String orderBy,
  java.lang.String limit)

Query the given table, returning a (|android.database.Cursor|) over the result 
set. 


    table - The table name to compile the query against. 
    columns - A list of which columns to return. Passing null will return all columns, which 
       is discouraged to prevent reading data from storage that isn't going to 
       be used. 
    selection - A filter declaring which rows to return, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). Passing null will return all rows for the 
       given table. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in order that they appear in the selection. The values 
       will be bound as Strings. 
    groupBy - A filter declaring how to group rows, formatted as an SQL GROUP BY clause 
       (excluding the GROUP BY itself). Passing null will cause the rows to not 
       be grouped. 
    having - A filter declare which row groups to include in the cursor, if row grouping is 
       being used, formatted as an SQL HAVING clause (excluding the HAVING 
       itself). Passing null will cause all row groups to be included, and is 
       required when row grouping is not being used. 
    orderBy - How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER 
       BY itself). Passing null will use the default sort order, which may be 
       unordered. 
    limit - Limits the number of rows returned by the query, formatted as LIMIT clause. 
       Passing null denotes no LIMIT clause. 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.queryWithFactory(SQLiteDatabase.CursorFactory,boolean,String,String[],String,String[],String,String,String,String)*

public |android.database.Cursor| queryWithFactory(
  android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory,
  boolean distinct,
  java.lang.String table,
  java.lang.String[] columns,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String groupBy,
  java.lang.String having,
  java.lang.String orderBy,
  java.lang.String limit)

Query the given URL, returning a (|android.database.Cursor|) over the result 
set. 


    cursorFactory - the cursor factory to use, or null for the default factory 
    distinct - true if you want each row to be unique, false otherwise. 
    table - The table name to compile the query against. 
    columns - A list of which columns to return. Passing null will return all columns, which 
       is discouraged to prevent reading data from storage that isn't going to 
       be used. 
    selection - A filter declaring which rows to return, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). Passing null will return all rows for the 
       given table. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in order that they appear in the selection. The values 
       will be bound as Strings. 
    groupBy - A filter declaring how to group rows, formatted as an SQL GROUP BY clause 
       (excluding the GROUP BY itself). Passing null will cause the rows to not 
       be grouped. 
    having - A filter declare which row groups to include in the cursor, if row grouping is 
       being used, formatted as an SQL HAVING clause (excluding the HAVING 
       itself). Passing null will cause all row groups to be included, and is 
       required when row grouping is not being used. 
    orderBy - How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER 
       BY itself). Passing null will use the default sort order, which may be 
       unordered. 
    limit - Limits the number of rows returned by the query, formatted as LIMIT clause. 
       Passing null denotes no LIMIT clause. 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.queryWithFactory(SQLiteDatabase.CursorFactory,boolean,String,String[],String,String[],String,String,String,String,CancellationSignal)*

public |android.database.Cursor| queryWithFactory(
  android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory,
  boolean distinct,
  java.lang.String table,
  java.lang.String[] columns,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String groupBy,
  java.lang.String having,
  java.lang.String orderBy,
  java.lang.String limit,
  android.os.CancellationSignal cancellationSignal)

Query the given URL, returning a (|android.database.Cursor|) over the result 
set. 


    cursorFactory - the cursor factory to use, or null for the default factory 
    distinct - true if you want each row to be unique, false otherwise. 
    table - The table name to compile the query against. 
    columns - A list of which columns to return. Passing null will return all columns, which 
       is discouraged to prevent reading data from storage that isn't going to 
       be used. 
    selection - A filter declaring which rows to return, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). Passing null will return all rows for the 
       given table. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in order that they appear in the selection. The values 
       will be bound as Strings. 
    groupBy - A filter declaring how to group rows, formatted as an SQL GROUP BY clause 
       (excluding the GROUP BY itself). Passing null will cause the rows to not 
       be grouped. 
    having - A filter declare which row groups to include in the cursor, if row grouping is 
       being used, formatted as an SQL HAVING clause (excluding the HAVING 
       itself). Passing null will cause all row groups to be included, and is 
       required when row grouping is not being used. 
    orderBy - How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER 
       BY itself). Passing null will use the default sort order, which may be 
       unordered. 
    limit - Limits the number of rows returned by the query, formatted as LIMIT clause. 
       Passing null denotes no LIMIT clause. 
    cancellationSignal - A signal to cancel the operation in progress, or null if none. If the operation 
       is canceled, then {@link OperationCanceledException} will be thrown when 
       the query is executed. 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.rawQuery(String,String[])*

public |android.database.Cursor| rawQuery(
  java.lang.String sql,
  java.lang.String[] selectionArgs)

Runs the provided SQL and returns a (|android.database.Cursor|) over the result 
set. 


    sql - the SQL query. The SQL string must not be ; terminated 
    selectionArgs - You may include ?s in where clause in the query, which will be replaced by the 
       values from selectionArgs. The values will be bound as Strings. 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.rawQuery(String,String[],CancellationSignal)*

public |android.database.Cursor| rawQuery(
  java.lang.String sql,
  java.lang.String[] selectionArgs,
  android.os.CancellationSignal cancellationSignal)

Runs the provided SQL and returns a (|android.database.Cursor|) over the result 
set. 


    sql - the SQL query. The SQL string must not be ; terminated 
    selectionArgs - You may include ?s in where clause in the query, which will be replaced by the 
       values from selectionArgs. The values will be bound as Strings. 
    cancellationSignal - A signal to cancel the operation in progress, or null if none. If the operation 
       is canceled, then {@link OperationCanceledException} will be thrown when 
       the query is executed. 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.rawQueryWithFactory(SQLiteDatabase.CursorFactory,String,String[],String)*

public |android.database.Cursor| rawQueryWithFactory(
  android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory,
  java.lang.String sql,
  java.lang.String[] selectionArgs,
  java.lang.String editTable)

Runs the provided SQL and returns a cursor over the result set. 


    cursorFactory - the cursor factory to use, or null for the default factory 
    sql - the SQL query. The SQL string must not be ; terminated 
    selectionArgs - You may include ?s in where clause in the query, which will be replaced by the 
       values from selectionArgs. The values will be bound as Strings. 
    editTable - the name of the first table, which is editable 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.rawQueryWithFactory(SQLiteDatabase.CursorFactory,String,String[],String,CancellationSignal)*

public |android.database.Cursor| rawQueryWithFactory(
  android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory,
  java.lang.String sql,
  java.lang.String[] selectionArgs,
  java.lang.String editTable,
  android.os.CancellationSignal cancellationSignal)

Runs the provided SQL and returns a cursor over the result set. 


    cursorFactory - the cursor factory to use, or null for the default factory 
    sql - the SQL query. The SQL string must not be ; terminated 
    selectionArgs - You may include ?s in where clause in the query, which will be replaced by the 
       values from selectionArgs. The values will be bound as Strings. 
    editTable - the name of the first table, which is editable 
    cancellationSignal - A signal to cancel the operation in progress, or null if none. If the operation 
       is canceled, then {@link OperationCanceledException} will be thrown when 
       the query is executed. 

    Returns: A {@link Cursor} object, which is positioned before the first entry. Note that 
             {@link Cursor}s are not synchronized, see the documentation for 
             more details. 

*android.database.sqlite.SQLiteDatabase.releaseMemory()*

public static int releaseMemory()

Attempts to release memory that SQLite holds but does not require to operate 
properly. Typically this memory will come from the page cache. 



    Returns: the number of bytes actually released 

*android.database.sqlite.SQLiteDatabase.reopenReadWrite()*

public void reopenReadWrite()

Reopens the database in read-write mode. If the database is already read-write, 
does nothing. 



*android.database.sqlite.SQLiteDatabase.replace(String,String,ContentValues)*

public long replace(
  java.lang.String table,
  java.lang.String nullColumnHack,
  android.content.ContentValues initialValues)

Convenience method for replacing a row in the database. 


    table - the table in which to replace the row 
    nullColumnHack - optional; may be null. SQL doesn't allow inserting a completely empty row 
       without naming at least one column name. If your provided initialValues 
       is empty, no column names are known and an empty row can't be inserted. 
       If not set to null, the nullColumnHack parameter provides the name of 
       nullable column name to explicitly insert a NULL into in the case where 
       your initialValues is empty. 
    initialValues - this map contains the initial column values for the row. 

    Returns: the row ID of the newly inserted row, or -1 if an error occurred 

*android.database.sqlite.SQLiteDatabase.replaceOrThrow(String,String,ContentValues)*

public long replaceOrThrow(
  java.lang.String table,
  java.lang.String nullColumnHack,
  android.content.ContentValues initialValues)
  throws |android.database.SQLException|
         
Convenience method for replacing a row in the database. 


    table - the table in which to replace the row 
    nullColumnHack - optional; may be null. SQL doesn't allow inserting a completely empty row 
       without naming at least one column name. If your provided initialValues 
       is empty, no column names are known and an empty row can't be inserted. 
       If not set to null, the nullColumnHack parameter provides the name of 
       nullable column name to explicitly insert a NULL into in the case where 
       your initialValues is empty. 
    initialValues - this map contains the initial column values for the row. The key 

    Returns: the row ID of the newly inserted row, or -1 if an error occurred 

*android.database.sqlite.SQLiteDatabase.setForeignKeyConstraintsEnabled(boolean)*

public void setForeignKeyConstraintsEnabled(boolean enable)

Sets whether foreign key constraints are enabled for the database. 

By default, foreign key constraints are not enforced by the database. This 
method allows an application to enable foreign key constraints. It must be 
called each time the database is opened to ensure that foreign key constraints 
are enabled for the session. 

A good time to call this method is right after calling 
(|android.database.sqlite.SQLiteDatabase|) or in the 
(|android.database.sqlite.SQLiteOpenHelper|) callback. 

When foreign key constraints are disabled, the database does not check whether 
changes to the database will violate foreign key constraints. Likewise, when 
foreign key constraints are disabled, the database will not execute cascade 
delete or update triggers. As a result, it is possible for the database state 
to become inconsistent. To perform a database integrity check, call 
(|android.database.sqlite.SQLiteDatabase|) . 

This method must not be called while a transaction is in progress. 

See also SQLite Foreign Key Constraints for more details about foreign key 
constraint support. 


    enable - True to enable foreign key constraints, false to disable them. 

*android.database.sqlite.SQLiteDatabase.setLocale(Locale)*

public void setLocale(java.util.Locale locale)

Sets the locale for this database. Does nothing if this database has the 
(|android.database.sqlite.SQLiteDatabase|) flag set or was opened read only. 


    locale - The new locale. 

*android.database.sqlite.SQLiteDatabase.setLockingEnabled(boolean)*

public void setLockingEnabled(boolean lockingEnabled)

Control whether or not the SQLiteDatabase is made thread-safe by using locks 
around critical sections. This is pretty expensive, so if you know that your DB 
will only be used by a single thread then you should set this to false. The 
default is true. 

    Deprecated: This method now does nothing.  Do not use.

    lockingEnabled - set to true to enable locks, false otherwise 

*android.database.sqlite.SQLiteDatabase.setMaximumSize(long)*

public long setMaximumSize(long numBytes)

Sets the maximum size the database will grow to. The maximum size cannot be set 
below the current size. 


    numBytes - the maximum database size, in bytes 

    Returns: the new maximum database size 

*android.database.sqlite.SQLiteDatabase.setMaxSqlCacheSize(int)*

public void setMaxSqlCacheSize(int cacheSize)

Sets the maximum size of the prepared-statement cache for this database. (size 
of the cache = number of compiled-sql-statements stored in the cache). 

Maximum cache size can ONLY be increased from its current size (default = 10). 
If this method is called with smaller size than the current maximum value, then 
IllegalStateException is thrown. 

This method is thread-safe. 


    cacheSize - the size of the cache. can be (0 to {@link #MAX_SQL_CACHE_SIZE}) 

*android.database.sqlite.SQLiteDatabase.setPageSize(long)*

public void setPageSize(long numBytes)

Sets the database page size. The page size must be a power of two. This method 
does not work if any data has been written to the database file, and must be 
called right after the database has been created. 


    numBytes - the database page size, in bytes 

*android.database.sqlite.SQLiteDatabase.setTransactionSuccessful()*

public void setTransactionSuccessful()

Marks the current transaction as successful. Do not do any more database work 
between calling this and calling endTransaction. Do as little non-database work 
as possible in that situation too. If any errors are encountered between this 
and endTransaction the transaction will still be committed. 



*android.database.sqlite.SQLiteDatabase.setVersion(int)*

public void setVersion(int version)

Sets the database version. 


    version - the new database version 

*android.database.sqlite.SQLiteDatabase.toString()*

public |java.lang.String| toString()





*android.database.sqlite.SQLiteDatabase.update(String,ContentValues,String,String[])*

public int update(
  java.lang.String table,
  android.content.ContentValues values,
  java.lang.String whereClause,
  java.lang.String[] whereArgs)

Convenience method for updating rows in the database. 


    table - the table to update in 
    values - a map from column names to new column values. null is a valid value that will 
       be translated to NULL. 
    whereClause - the optional WHERE clause to apply when updating. Passing null will update all 
       rows. 
    whereArgs - You may include ?s in the where clause, which will be replaced by the values 
       from whereArgs. The values will be bound as Strings. 

    Returns: the number of rows affected 

*android.database.sqlite.SQLiteDatabase.updateWithOnConflict(String,ContentValues,String,String[],int)*

public int updateWithOnConflict(
  java.lang.String table,
  android.content.ContentValues values,
  java.lang.String whereClause,
  java.lang.String[] whereArgs,
  int conflictAlgorithm)

Convenience method for updating rows in the database. 


    table - the table to update in 
    values - a map from column names to new column values. null is a valid value that will 
       be translated to NULL. 
    whereClause - the optional WHERE clause to apply when updating. Passing null will update all 
       rows. 
    whereArgs - You may include ?s in the where clause, which will be replaced by the values 
       from whereArgs. The values will be bound as Strings. 
    conflictAlgorithm - for update conflict resolver 

    Returns: the number of rows affected 

*android.database.sqlite.SQLiteDatabase.yieldIfContended()*

public boolean yieldIfContended()

Temporarily end the transaction to let other threads run. The transaction is 
assumed to be successful so far. Do not call setTransactionSuccessful before 
calling this. When this returns a new transaction will have been created but 
not marked as successful. 

    Deprecated: if the db is locked more than once (becuase of nested transactions) then the lock
   will not be yielded. Use yieldIfContendedSafely instead.


    Returns: true if the transaction was yielded 

*android.database.sqlite.SQLiteDatabase.yieldIfContendedSafely()*

public boolean yieldIfContendedSafely()

Temporarily end the transaction to let other threads run. The transaction is 
assumed to be successful so far. Do not call setTransactionSuccessful before 
calling this. When this returns a new transaction will have been created but 
not marked as successful. This assumes that there are no nested transactions 
(beginTransaction has only been called once) and will throw an exception if 
that is not the case. 



    Returns: true if the transaction was yielded 

*android.database.sqlite.SQLiteDatabase.yieldIfContendedSafely(long)*

public boolean yieldIfContendedSafely(long sleepAfterYieldDelay)

Temporarily end the transaction to let other threads run. The transaction is 
assumed to be successful so far. Do not call setTransactionSuccessful before 
calling this. When this returns a new transaction will have been created but 
not marked as successful. This assumes that there are no nested transactions 
(beginTransaction has only been called once) and will throw an exception if 
that is not the case. 


    sleepAfterYieldDelay - if > 0, sleep this long before starting a new transaction if the lock was 
       actually yielded. This will allow other background threads to make some 
       more progress than they would if we started the transaction immediately. 

    Returns: true if the transaction was yielded 


