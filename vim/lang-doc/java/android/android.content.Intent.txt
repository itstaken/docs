*android.content.Intent* *Intent* An intent is an abstract description of an ope

public class Intent
  extends    |java.lang.Object|
  implements |android.os.Parcelable|
             |java.lang.Cloneable|

|android.content.Intent_Description|
|android.content.Intent_Fields|
|android.content.Intent_Constructors|
|android.content.Intent_Methods|

================================================================================

*android.content.Intent_Fields*
|java.lang.String_android.content.Intent.ACTION_ADVANCED_SETTINGS_CHANGED|
|java.lang.String_android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED|
|java.lang.String_android.content.Intent.ACTION_ALARM_CHANGED|
|java.lang.String_android.content.Intent.ACTION_ALL_APPS|
|java.lang.String_android.content.Intent.ACTION_ANALOG_AUDIO_DOCK_PLUG|
|java.lang.String_android.content.Intent.ACTION_ANSWER|
|java.lang.String_android.content.Intent.ACTION_APP_ERROR|
|java.lang.String_android.content.Intent.ACTION_ASSIST|
|java.lang.String_android.content.Intent.ACTION_ATTACH_DATA|
|java.lang.String_android.content.Intent.ACTION_BATTERY_CHANGED|
|java.lang.String_android.content.Intent.ACTION_BATTERY_LOW|
|java.lang.String_android.content.Intent.ACTION_BATTERY_OKAY|
|java.lang.String_android.content.Intent.ACTION_BOOT_COMPLETED|
|java.lang.String_android.content.Intent.ACTION_BUG_REPORT|
|java.lang.String_android.content.Intent.ACTION_CALL|
|java.lang.String_android.content.Intent.ACTION_CALL_BUTTON|
|java.lang.String_android.content.Intent.ACTION_CALL_EMERGENCY|
|java.lang.String_android.content.Intent.ACTION_CALL_PRIVILEGED|
|java.lang.String_android.content.Intent.ACTION_CAMERA_BUTTON|
|java.lang.String_android.content.Intent.ACTION_CHOOSER|
|java.lang.String_android.content.Intent.ACTION_CLEAR_DNS_CACHE|
|java.lang.String_android.content.Intent.ACTION_CLOSE_SYSTEM_DIALOGS|
|java.lang.String_android.content.Intent.ACTION_CONFIGURATION_CHANGED|
|java.lang.String_android.content.Intent.ACTION_CREATE_DOCUMENT|
|java.lang.String_android.content.Intent.ACTION_CREATE_SHORTCUT|
|java.lang.String_android.content.Intent.ACTION_DATE_CHANGED|
|java.lang.String_android.content.Intent.ACTION_DEFAULT|
|java.lang.String_android.content.Intent.ACTION_DELETE|
|java.lang.String_android.content.Intent.ACTION_DEVICE_STORAGE_FULL|
|java.lang.String_android.content.Intent.ACTION_DEVICE_STORAGE_LOW|
|java.lang.String_android.content.Intent.ACTION_DEVICE_STORAGE_NOT_FULL|
|java.lang.String_android.content.Intent.ACTION_DEVICE_STORAGE_OK|
|java.lang.String_android.content.Intent.ACTION_DIAL|
|java.lang.String_android.content.Intent.ACTION_DIGITAL_AUDIO_DOCK_PLUG|
|java.lang.String_android.content.Intent.ACTION_DOCK_EVENT|
|java.lang.String_android.content.Intent.ACTION_DREAMING_STARTED|
|java.lang.String_android.content.Intent.ACTION_DREAMING_STOPPED|
|java.lang.String_android.content.Intent.ACTION_EDIT|
|java.lang.String_android.content.Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE|
|java.lang.String_android.content.Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE|
|java.lang.String_android.content.Intent.ACTION_FACTORY_TEST|
|java.lang.String_android.content.Intent.ACTION_GET_CONTENT|
|java.lang.String_android.content.Intent.ACTION_GET_RESTRICTION_ENTRIES|
|java.lang.String_android.content.Intent.ACTION_GLOBAL_BUTTON|
|java.lang.String_android.content.Intent.ACTION_GTALK_SERVICE_CONNECTED|
|java.lang.String_android.content.Intent.ACTION_GTALK_SERVICE_DISCONNECTED|
|java.lang.String_android.content.Intent.ACTION_HDMI_AUDIO_PLUG|
|java.lang.String_android.content.Intent.ACTION_HEADSET_PLUG|
|java.lang.String_android.content.Intent.ACTION_IDLE_MAINTENANCE_END|
|java.lang.String_android.content.Intent.ACTION_IDLE_MAINTENANCE_START|
|java.lang.String_android.content.Intent.ACTION_INPUT_METHOD_CHANGED|
|java.lang.String_android.content.Intent.ACTION_INSERT|
|java.lang.String_android.content.Intent.ACTION_INSERT_OR_EDIT|
|java.lang.String_android.content.Intent.ACTION_INSTALL_PACKAGE|
|java.lang.String_android.content.Intent.ACTION_LOCALE_CHANGED|
|java.lang.String_android.content.Intent.ACTION_MAIN|
|java.lang.String_android.content.Intent.ACTION_MANAGE_NETWORK_USAGE|
|java.lang.String_android.content.Intent.ACTION_MANAGE_PACKAGE_STORAGE|
|java.lang.String_android.content.Intent.ACTION_MEDIA_BAD_REMOVAL|
|java.lang.String_android.content.Intent.ACTION_MEDIA_BUTTON|
|java.lang.String_android.content.Intent.ACTION_MEDIA_CHECKING|
|java.lang.String_android.content.Intent.ACTION_MEDIA_EJECT|
|java.lang.String_android.content.Intent.ACTION_MEDIA_MOUNTED|
|java.lang.String_android.content.Intent.ACTION_MEDIA_NOFS|
|java.lang.String_android.content.Intent.ACTION_MEDIA_REMOVED|
|java.lang.String_android.content.Intent.ACTION_MEDIA_SCANNER_FINISHED|
|java.lang.String_android.content.Intent.ACTION_MEDIA_SCANNER_SCAN_FILE|
|java.lang.String_android.content.Intent.ACTION_MEDIA_SCANNER_STARTED|
|java.lang.String_android.content.Intent.ACTION_MEDIA_SHARED|
|java.lang.String_android.content.Intent.ACTION_MEDIA_UNMOUNTABLE|
|java.lang.String_android.content.Intent.ACTION_MEDIA_UNMOUNTED|
|java.lang.String_android.content.Intent.ACTION_MEDIA_UNSHARED|
|java.lang.String_android.content.Intent.ACTION_MY_PACKAGE_REPLACED|
|java.lang.String_android.content.Intent.ACTION_NEW_OUTGOING_CALL|
|java.lang.String_android.content.Intent.ACTION_OPEN_DOCUMENT|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_ADDED|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_CHANGED|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_DATA_CLEARED|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_FIRST_LAUNCH|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_FULLY_REMOVED|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_INSTALL|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_NEEDS_VERIFICATION|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_REMOVED|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_REPLACED|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_RESTARTED|
|java.lang.String_android.content.Intent.ACTION_PACKAGE_VERIFIED|
|java.lang.String_android.content.Intent.ACTION_PASTE|
|java.lang.String_android.content.Intent.ACTION_PICK|
|java.lang.String_android.content.Intent.ACTION_PICK_ACTIVITY|
|java.lang.String_android.content.Intent.ACTION_POWER_CONNECTED|
|java.lang.String_android.content.Intent.ACTION_POWER_DISCONNECTED|
|java.lang.String_android.content.Intent.ACTION_POWER_USAGE_SUMMARY|
|java.lang.String_android.content.Intent.ACTION_PRE_BOOT_COMPLETED|
|java.lang.String_android.content.Intent.ACTION_PROVIDER_CHANGED|
|java.lang.String_android.content.Intent.ACTION_QUERY_PACKAGE_RESTART|
|java.lang.String_android.content.Intent.ACTION_QUICK_CLOCK|
|java.lang.String_android.content.Intent.ACTION_REBOOT|
|java.lang.String_android.content.Intent.ACTION_REMOTE_INTENT|
|java.lang.String_android.content.Intent.ACTION_REQUEST_SHUTDOWN|
|java.lang.String_android.content.Intent.ACTION_RESTRICTIONS_CHALLENGE|
|java.lang.String_android.content.Intent.ACTION_RUN|
|java.lang.String_android.content.Intent.ACTION_SCREEN_OFF|
|java.lang.String_android.content.Intent.ACTION_SCREEN_ON|
|java.lang.String_android.content.Intent.ACTION_SEARCH|
|java.lang.String_android.content.Intent.ACTION_SEARCH_LONG_PRESS|
|java.lang.String_android.content.Intent.ACTION_SEND|
|java.lang.String_android.content.Intent.ACTION_SEND_MULTIPLE|
|java.lang.String_android.content.Intent.ACTION_SENDTO|
|java.lang.String_android.content.Intent.ACTION_SET_WALLPAPER|
|java.lang.String_android.content.Intent.ACTION_SHOW_BRIGHTNESS_DIALOG|
|java.lang.String_android.content.Intent.ACTION_SHUTDOWN|
|java.lang.String_android.content.Intent.ACTION_SYNC|
|java.lang.String_android.content.Intent.ACTION_SYNC_STATE_CHANGED|
|java.lang.String_android.content.Intent.ACTION_SYSTEM_TUTORIAL|
|java.lang.String_android.content.Intent.ACTION_TIME_CHANGED|
|java.lang.String_android.content.Intent.ACTION_TIME_TICK|
|java.lang.String_android.content.Intent.ACTION_TIMEZONE_CHANGED|
|java.lang.String_android.content.Intent.ACTION_UID_REMOVED|
|java.lang.String_android.content.Intent.ACTION_UMS_CONNECTED|
|java.lang.String_android.content.Intent.ACTION_UMS_DISCONNECTED|
|java.lang.String_android.content.Intent.ACTION_UNINSTALL_PACKAGE|
|java.lang.String_android.content.Intent.ACTION_UPGRADE_SETUP|
|java.lang.String_android.content.Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG|
|java.lang.String_android.content.Intent.ACTION_USB_AUDIO_DEVICE_PLUG|
|java.lang.String_android.content.Intent.ACTION_USER_ADDED|
|java.lang.String_android.content.Intent.ACTION_USER_BACKGROUND|
|java.lang.String_android.content.Intent.ACTION_USER_FOREGROUND|
|java.lang.String_android.content.Intent.ACTION_USER_INFO_CHANGED|
|java.lang.String_android.content.Intent.ACTION_USER_INITIALIZE|
|java.lang.String_android.content.Intent.ACTION_USER_PRESENT|
|java.lang.String_android.content.Intent.ACTION_USER_REMOVED|
|java.lang.String_android.content.Intent.ACTION_USER_STARTED|
|java.lang.String_android.content.Intent.ACTION_USER_STARTING|
|java.lang.String_android.content.Intent.ACTION_USER_STOPPED|
|java.lang.String_android.content.Intent.ACTION_USER_STOPPING|
|java.lang.String_android.content.Intent.ACTION_USER_SWITCHED|
|java.lang.String_android.content.Intent.ACTION_VIEW|
|java.lang.String_android.content.Intent.ACTION_VOICE_ASSIST|
|java.lang.String_android.content.Intent.ACTION_VOICE_COMMAND|
|java.lang.String_android.content.Intent.ACTION_WALLPAPER_CHANGED|
|java.lang.String_android.content.Intent.ACTION_WEB_SEARCH|
|java.lang.String_android.content.Intent.CATEGORY_ALTERNATIVE|
|java.lang.String_android.content.Intent.CATEGORY_APP_BROWSER|
|java.lang.String_android.content.Intent.CATEGORY_APP_CALCULATOR|
|java.lang.String_android.content.Intent.CATEGORY_APP_CALENDAR|
|java.lang.String_android.content.Intent.CATEGORY_APP_CONTACTS|
|java.lang.String_android.content.Intent.CATEGORY_APP_EMAIL|
|java.lang.String_android.content.Intent.CATEGORY_APP_GALLERY|
|java.lang.String_android.content.Intent.CATEGORY_APP_MAPS|
|java.lang.String_android.content.Intent.CATEGORY_APP_MARKET|
|java.lang.String_android.content.Intent.CATEGORY_APP_MESSAGING|
|java.lang.String_android.content.Intent.CATEGORY_APP_MUSIC|
|java.lang.String_android.content.Intent.CATEGORY_BROWSABLE|
|java.lang.String_android.content.Intent.CATEGORY_CAR_DOCK|
|java.lang.String_android.content.Intent.CATEGORY_CAR_MODE|
|java.lang.String_android.content.Intent.CATEGORY_DEFAULT|
|java.lang.String_android.content.Intent.CATEGORY_DESK_DOCK|
|java.lang.String_android.content.Intent.CATEGORY_DEVELOPMENT_PREFERENCE|
|java.lang.String_android.content.Intent.CATEGORY_EMBED|
|java.lang.String_android.content.Intent.CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST|
|java.lang.String_android.content.Intent.CATEGORY_HE_DESK_DOCK|
|java.lang.String_android.content.Intent.CATEGORY_HOME|
|java.lang.String_android.content.Intent.CATEGORY_INFO|
|java.lang.String_android.content.Intent.CATEGORY_LAUNCHER|
|java.lang.String_android.content.Intent.CATEGORY_LE_DESK_DOCK|
|java.lang.String_android.content.Intent.CATEGORY_MONKEY|
|java.lang.String_android.content.Intent.CATEGORY_OPENABLE|
|java.lang.String_android.content.Intent.CATEGORY_PREFERENCE|
|java.lang.String_android.content.Intent.CATEGORY_SAMPLE_CODE|
|java.lang.String_android.content.Intent.CATEGORY_SELECTED_ALTERNATIVE|
|java.lang.String_android.content.Intent.CATEGORY_TAB|
|java.lang.String_android.content.Intent.CATEGORY_TEST|
|java.lang.String_android.content.Intent.CATEGORY_UNIT_TEST|
|android.os.Parcelable.Creator<android.content.Intent>_android.content.Intent.CREATOR|
|java.lang.String_android.content.Intent.EXTRA_ALARM_COUNT|
|java.lang.String_android.content.Intent.EXTRA_ALLOW_MULTIPLE|
|java.lang.String_android.content.Intent.EXTRA_ALLOW_REPLACE|
|java.lang.String_android.content.Intent.EXTRA_ASSIST_CONTEXT|
|java.lang.String_android.content.Intent.EXTRA_ASSIST_PACKAGE|
|java.lang.String_android.content.Intent.EXTRA_BCC|
|java.lang.String_android.content.Intent.EXTRA_BUG_REPORT|
|java.lang.String_android.content.Intent.EXTRA_CC|
|java.lang.String_android.content.Intent.EXTRA_CHANGED_COMPONENT_NAME|
|java.lang.String_android.content.Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST|
|java.lang.String_android.content.Intent.EXTRA_CHANGED_PACKAGE_LIST|
|java.lang.String_android.content.Intent.EXTRA_CHANGED_UID_LIST|
|java.lang.String_android.content.Intent.EXTRA_CLIENT_INTENT|
|java.lang.String_android.content.Intent.EXTRA_CLIENT_LABEL|
|java.lang.String_android.content.Intent.EXTRA_DATA_REMOVED|
|java.lang.String_android.content.Intent.EXTRA_DOCK_STATE|
|int_android.content.Intent.EXTRA_DOCK_STATE_CAR|
|int_android.content.Intent.EXTRA_DOCK_STATE_DESK|
|int_android.content.Intent.EXTRA_DOCK_STATE_HE_DESK|
|int_android.content.Intent.EXTRA_DOCK_STATE_LE_DESK|
|int_android.content.Intent.EXTRA_DOCK_STATE_UNDOCKED|
|java.lang.String_android.content.Intent.EXTRA_DONT_KILL_APP|
|java.lang.String_android.content.Intent.EXTRA_EMAIL|
|java.lang.String_android.content.Intent.EXTRA_HTML_TEXT|
|java.lang.String_android.content.Intent.EXTRA_INITIAL_INTENTS|
|java.lang.String_android.content.Intent.EXTRA_INSTALL_RESULT|
|java.lang.String_android.content.Intent.EXTRA_INSTALLER_PACKAGE_NAME|
|java.lang.String_android.content.Intent.EXTRA_INTENT|
|java.lang.String_android.content.Intent.EXTRA_KEY_CONFIRM|
|java.lang.String_android.content.Intent.EXTRA_KEY_EVENT|
|java.lang.String_android.content.Intent.EXTRA_LOCAL_ONLY|
|java.lang.String_android.content.Intent.EXTRA_MIME_TYPES|
|java.lang.String_android.content.Intent.EXTRA_NOT_UNKNOWN_SOURCE|
|java.lang.String_android.content.Intent.EXTRA_ORIGINATING_UID|
|java.lang.String_android.content.Intent.EXTRA_ORIGINATING_URI|
|java.lang.String_android.content.Intent.EXTRA_PACKAGES|
|java.lang.String_android.content.Intent.EXTRA_PHONE_NUMBER|
|java.lang.String_android.content.Intent.EXTRA_REFERRER|
|java.lang.String_android.content.Intent.EXTRA_REMOTE_INTENT_TOKEN|
|java.lang.String_android.content.Intent.EXTRA_REMOVED_FOR_ALL_USERS|
|java.lang.String_android.content.Intent.EXTRA_REPLACING|
|java.lang.String_android.content.Intent.EXTRA_RESTRICTIONS_BUNDLE|
|java.lang.String_android.content.Intent.EXTRA_RESTRICTIONS_INTENT|
|java.lang.String_android.content.Intent.EXTRA_RESTRICTIONS_LIST|
|java.lang.String_android.content.Intent.EXTRA_RETURN_RESULT|
|java.lang.String_android.content.Intent.EXTRA_SHORTCUT_ICON|
|java.lang.String_android.content.Intent.EXTRA_SHORTCUT_ICON_RESOURCE|
|java.lang.String_android.content.Intent.EXTRA_SHORTCUT_INTENT|
|java.lang.String_android.content.Intent.EXTRA_SHORTCUT_NAME|
|java.lang.String_android.content.Intent.EXTRA_SHUTDOWN_USERSPACE_ONLY|
|java.lang.String_android.content.Intent.EXTRA_STREAM|
|java.lang.String_android.content.Intent.EXTRA_SUBJECT|
|java.lang.String_android.content.Intent.EXTRA_TEMPLATE|
|java.lang.String_android.content.Intent.EXTRA_TEXT|
|java.lang.String_android.content.Intent.EXTRA_TITLE|
|java.lang.String_android.content.Intent.EXTRA_UID|
|java.lang.String_android.content.Intent.EXTRA_UNINSTALL_ALL_USERS|
|java.lang.String_android.content.Intent.EXTRA_USER_HANDLE|
|int_android.content.Intent.FILL_IN_ACTION|
|int_android.content.Intent.FILL_IN_CATEGORIES|
|int_android.content.Intent.FILL_IN_CLIP_DATA|
|int_android.content.Intent.FILL_IN_COMPONENT|
|int_android.content.Intent.FILL_IN_DATA|
|int_android.content.Intent.FILL_IN_PACKAGE|
|int_android.content.Intent.FILL_IN_SELECTOR|
|int_android.content.Intent.FILL_IN_SOURCE_BOUNDS|
|int_android.content.Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT|
|int_android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK|
|int_android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP|
|int_android.content.Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET|
|int_android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS|
|int_android.content.Intent.FLAG_ACTIVITY_FORWARD_RESULT|
|int_android.content.Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY|
|int_android.content.Intent.FLAG_ACTIVITY_MULTIPLE_TASK|
|int_android.content.Intent.FLAG_ACTIVITY_NEW_TASK|
|int_android.content.Intent.FLAG_ACTIVITY_NO_ANIMATION|
|int_android.content.Intent.FLAG_ACTIVITY_NO_HISTORY|
|int_android.content.Intent.FLAG_ACTIVITY_NO_USER_ACTION|
|int_android.content.Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP|
|int_android.content.Intent.FLAG_ACTIVITY_REORDER_TO_FRONT|
|int_android.content.Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED|
|int_android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP|
|int_android.content.Intent.FLAG_ACTIVITY_TASK_ON_HOME|
|int_android.content.Intent.FLAG_DEBUG_LOG_RESOLUTION|
|int_android.content.Intent.FLAG_EXCLUDE_STOPPED_PACKAGES|
|int_android.content.Intent.FLAG_FROM_BACKGROUND|
|int_android.content.Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION|
|int_android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION|
|int_android.content.Intent.FLAG_GRANT_WRITE_URI_PERMISSION|
|int_android.content.Intent.FLAG_INCLUDE_STOPPED_PACKAGES|
|int_android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE|
|int_android.content.Intent.FLAG_RECEIVER_FOREGROUND|
|int_android.content.Intent.FLAG_RECEIVER_NO_ABORT|
|int_android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY|
|int_android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT|
|int_android.content.Intent.FLAG_RECEIVER_REPLACE_PENDING|
|int_android.content.Intent.IMMUTABLE_FLAGS|
|java.lang.String_android.content.Intent.METADATA_DOCK_HOME|
|java.lang.String_android.content.Intent.METADATA_SETUP_VERSION|
|int_android.content.Intent.URI_INTENT_SCHEME|

*android.content.Intent_Constructors*
|android.content.Intent()|Create an empty intent.
|android.content.Intent(Context,Class<?>)|Create an intent for a specific compo
|android.content.Intent(Intent)|Copy constructor.
|android.content.Intent(Parcel)|
|android.content.Intent(String)|Create an intent with a given action.
|android.content.Intent(String,Uri)|Create an intent with a given action and fo
|android.content.Intent(String,Uri,Context,Class<?>)|Create an intent for a spe

*android.content.Intent_Methods*
|android.content.Intent.addCategory(String)|Add a new category to the intent.
|android.content.Intent.addFlags(int)|Add additional flags to the intent (or wi
|android.content.Intent.clone()|
|android.content.Intent.cloneFilter()|Make a clone of only the parts of the Int
|android.content.Intent.createChooser(Intent,CharSequence)|Convenience function
|android.content.Intent.describeContents()|
|android.content.Intent.fillIn(Intent,int)|Copy the contents of other in to thi
|android.content.Intent.filterEquals(Intent)|Determine if two intents are the s
|android.content.Intent.filterHashCode()|Generate hash code that matches semant
|android.content.Intent.getAction()|Retrieve the general action to be performed
|android.content.Intent.getBooleanArrayExtra(String)|Retrieve extended data fro
|android.content.Intent.getBooleanExtra(String,boolean)|Retrieve extended data 
|android.content.Intent.getBundleExtra(String)|Retrieve extended data from the 
|android.content.Intent.getByteArrayExtra(String)|Retrieve extended data from t
|android.content.Intent.getByteExtra(String,byte)|Retrieve extended data from t
|android.content.Intent.getCategories()|Return the set of all categories in the
|android.content.Intent.getCharArrayExtra(String)|Retrieve extended data from t
|android.content.Intent.getCharExtra(String,char)|Retrieve extended data from t
|android.content.Intent.getCharSequenceArrayExtra(String)|Retrieve extended dat
|android.content.Intent.getCharSequenceArrayListExtra(String)|Retrieve extended
|android.content.Intent.getCharSequenceExtra(String)|Retrieve extended data fro
|android.content.Intent.getClipData()|Return theClipDataassociated with this In
|android.content.Intent.getComponent()|Retrieve the concrete component associat
|android.content.Intent.getData()|Retrieve data this intent is operating on.
|android.content.Intent.getDataString()|The same as#getData(), but returns the 
|android.content.Intent.getDoubleArrayExtra(String)|Retrieve extended data from
|android.content.Intent.getDoubleExtra(String,double)|Retrieve extended data fr
|android.content.Intent.getExtra(String)|Retrieve extended data from the intent
|android.content.Intent.getExtra(String,Object)|Retrieve extended data from the
|android.content.Intent.getExtras()|Retrieves a map of extended data from the i
|android.content.Intent.getFlags()|Retrieve any special flags associated with t
|android.content.Intent.getFloatArrayExtra(String)|Retrieve extended data from 
|android.content.Intent.getFloatExtra(String,float)|Retrieve extended data from
|android.content.Intent.getIBinderExtra(String)|Retrieve extended data from the
|android.content.Intent.getIntArrayExtra(String)|Retrieve extended data from th
|android.content.Intent.getIntegerArrayListExtra(String)|Retrieve extended data
|android.content.Intent.getIntent(String)|Call#parseUriwith 0 flags.
|android.content.Intent.getIntentOld(String)|
|android.content.Intent.getIntExtra(String,int)|Retrieve extended data from the
|android.content.Intent.getLongArrayExtra(String)|Retrieve extended data from t
|android.content.Intent.getLongExtra(String,long)|Retrieve extended data from t
|android.content.Intent.getPackage()|Retrieve the application package name this
|android.content.Intent.getParcelableArrayExtra(String)|Retrieve extended data 
|android.content.Intent.getParcelableArrayListExtra(String)|Retrieve extended d
|android.content.Intent.getParcelableExtra(String)|Retrieve extended data from 
|android.content.Intent.getScheme()|Return the scheme portion of the intent's d
|android.content.Intent.getSelector()|Return the specific selector associated w
|android.content.Intent.getSerializableExtra(String)|Retrieve extended data fro
|android.content.Intent.getShortArrayExtra(String)|Retrieve extended data from 
|android.content.Intent.getShortExtra(String,short)|Retrieve extended data from
|android.content.Intent.getSourceBounds()|Get the bounds of the sender of this 
|android.content.Intent.getStringArrayExtra(String)|Retrieve extended data from
|android.content.Intent.getStringArrayListExtra(String)|Retrieve extended data 
|android.content.Intent.getStringExtra(String)|Retrieve extended data from the 
|android.content.Intent.getType()|Retrieve any explicit MIME type included in t
|android.content.Intent.hasCategory(String)|Check if a category exists in the i
|android.content.Intent.hasExtra(String)|Returns true if an extra value is asso
|android.content.Intent.hasFileDescriptors()|Returns true if the Intent's extra
|android.content.Intent.isExcludingStopped()|
|android.content.Intent.makeMainActivity(ComponentName)|Create an intent to lau
|android.content.Intent.makeMainSelectorActivity(String,String)|Make an Intent 
|android.content.Intent.makeRestartActivityTask(ComponentName)|Make an Intent t
|android.content.Intent.migrateExtraStreamToClipData()|Migrate any#EXTRA_STREAM
|android.content.Intent.normalizeMimeType(String)|Normalize a MIME data type.
|android.content.Intent.parseIntent(Resources,XmlPullParser,AttributeSet)|Parse
|android.content.Intent.parseUri(String,int)|Create an intent from a URI.
|android.content.Intent.prepareToLeaveProcess()|Prepare thisIntentto leave an a
|android.content.Intent.putCharSequenceArrayListExtra(String,ArrayList<CharSequence>)|
|android.content.Intent.putExtra(String,boolean)|Add extended data to the inten
|android.content.Intent.putExtra(String,boolean[])|Add extended data to the int
|android.content.Intent.putExtra(String,Bundle)|Add extended data to the intent
|android.content.Intent.putExtra(String,byte)|Add extended data to the intent.
|android.content.Intent.putExtra(String,byte[])|Add extended data to the intent
|android.content.Intent.putExtra(String,char)|Add extended data to the intent.
|android.content.Intent.putExtra(String,char[])|Add extended data to the intent
|android.content.Intent.putExtra(String,CharSequence)|Add extended data to the 
|android.content.Intent.putExtra(String,CharSequence[])|Add extended data to th
|android.content.Intent.putExtra(String,double)|Add extended data to the intent
|android.content.Intent.putExtra(String,double[])|Add extended data to the inte
|android.content.Intent.putExtra(String,float)|Add extended data to the intent.
|android.content.Intent.putExtra(String,float[])|Add extended data to the inten
|android.content.Intent.putExtra(String,IBinder)|Add extended data to the inten
|android.content.Intent.putExtra(String,int)|Add extended data to the intent.
|android.content.Intent.putExtra(String,int[])|Add extended data to the intent.
|android.content.Intent.putExtra(String,long)|Add extended data to the intent.
|android.content.Intent.putExtra(String,long[])|Add extended data to the intent
|android.content.Intent.putExtra(String,Parcelable)|Add extended data to the in
|android.content.Intent.putExtra(String,Parcelable[])|Add extended data to the 
|android.content.Intent.putExtra(String,Serializable)|Add extended data to the 
|android.content.Intent.putExtra(String,short)|Add extended data to the intent.
|android.content.Intent.putExtra(String,short[])|Add extended data to the inten
|android.content.Intent.putExtra(String,String)|Add extended data to the intent
|android.content.Intent.putExtra(String,String[])|Add extended data to the inte
|android.content.Intent.putExtras(Bundle)|Add a set of extended data to the int
|android.content.Intent.putExtras(Intent)|Copy all extras in 'src' in to this i
|android.content.Intent.putIntegerArrayListExtra(String,ArrayList<Integer>)|Add
|android.content.Intent.putParcelableArrayListExtra(String,ArrayList<?extendsParcelable>)|
|android.content.Intent.putStringArrayListExtra(String,ArrayList<String>)|Add e
|android.content.Intent.readFromParcel(Parcel)|
|android.content.Intent.removeCategory(String)|Remove a category from an intent
|android.content.Intent.removeExtra(String)|Remove extended data from the inten
|android.content.Intent.replaceExtras(Bundle)|Completely replace the extras in 
|android.content.Intent.replaceExtras(Intent)|Completely replace the extras in 
|android.content.Intent.resolveActivity(PackageManager)|Return the Activity com
|android.content.Intent.resolveActivityInfo(PackageManager,int)|Resolve the Int
|android.content.Intent.resolveSystemService(PackageManager,int)|Special functi
|android.content.Intent.resolveType(ContentResolver)|Return the MIME data type 
|android.content.Intent.resolveType(Context)|Return the MIME data type of this 
|android.content.Intent.resolveTypeIfNeeded(ContentResolver)|Return the MIME da
|android.content.Intent.setAction(String)|Set the general action to be performe
|android.content.Intent.setAllowFds(boolean)|
|android.content.Intent.setClass(Context,Class<?>)|Convenience for calling#setC
|android.content.Intent.setClassName(Context,String)|Convenience for calling#se
|android.content.Intent.setClassName(String,String)|Convenience for calling#set
|android.content.Intent.setClipData(ClipData)|Set aClipDataassociated with this
|android.content.Intent.setComponent(ComponentName)|(Usually optional) Explicit
|android.content.Intent.setData(Uri)|Set the data this intent is operating on.
|android.content.Intent.setDataAndNormalize(Uri)|Normalize and set the data thi
|android.content.Intent.setDataAndType(Uri,String)|(Usually optional) Set the d
|android.content.Intent.setDataAndTypeAndNormalize(Uri,String)|(Usually optiona
|android.content.Intent.setExtrasClassLoader(ClassLoader)|Sets the ClassLoader 
|android.content.Intent.setFlags(int)|Set special flags controlling how this in
|android.content.Intent.setPackage(String)|(Usually optional) Set an explicit a
|android.content.Intent.setSelector(Intent)|Set a selector for this Intent.
|android.content.Intent.setSourceBounds(Rect)|Set the bounds of the sender of t
|android.content.Intent.setType(String)|Set an explicit MIME data type.
|android.content.Intent.setTypeAndNormalize(String)|Normalize and set an explic
|android.content.Intent.toInsecureString()|
|android.content.Intent.toInsecureStringWithClip()|
|android.content.Intent.toShortString(boolean,boolean,boolean,boolean)|
|android.content.Intent.toShortString(StringBuilder,boolean,boolean,boolean,boolean)|
|android.content.Intent.toString()|
|android.content.Intent.toURI()|Call#toUriwith 0 flags.
|android.content.Intent.toUri(int)|Convert this Intent into a String holding a 
|android.content.Intent.writeToParcel(Parcel,int)|

*android.content.Intent_Description*

An intent is an abstract description of an operation to be performed. It can be 
used with startActivity(|android.content.Context|) to launch an 
(|android.app.Activity|) , broadcastIntent(|android.content.Context|) to send 
it to any interested BroadcastReceiver(|android.content.BroadcastReceiver|) 
components, and (|android.content.Context|) or (|android.content.Context|) to 
communicate with a background (|android.app.Service|) . 

An Intent provides a facility for performing late runtime binding between the 
code in different applications. Its most significant use is in the launching of 
activities, where it can be thought of as the glue between activities. It is 
basically a passive data structure holding an abstract description of an action 
to be performed. 

Developer Guides For information about how to create and resolve intents, read 
the <a href="guide/topics/intents/intents-filters.html">Intents and Intent 
Filters developer guide. 

Intent Structure The primary pieces of information in an intent are: 

action -- The general action to be performed, such as 
(|android.content.Intent|) , (|android.content.Intent|) , 
(|android.content.Intent|) , etc. 

data -- The data to operate on, such as a person record in the contacts 
database, expressed as a (|android.net.Uri|) . 



Some examples of action/data pairs are: 

(|android.content.Intent|) content://contacts/people/1 -- Display information 
about the person whose identifier is "1". 

(|android.content.Intent|) content://contacts/people/1 -- Display the phone 
dialer with the person filled in. 

(|android.content.Intent|) tel:123 -- Display the phone dialer with the given 
number filled in. Note how the VIEW action does what what is considered the 
most reasonable thing for a particular URI. 

(|android.content.Intent|) tel:123 -- Display the phone dialer with the given 
number filled in. 

(|android.content.Intent|) content://contacts/people/1 -- Edit information 
about the person whose identifier is "1". 

(|android.content.Intent|) content://contacts/people/ -- Display a list of 
people, which the user can browse through. This example is a typical top-level 
entry into the Contacts application, showing you the list of people. Selecting 
a particular person to view would result in a new intent { 
(|android.content.Intent|) content://contacts/N } being used to start an 
activity to display that person. 



In addition to these primary attributes, there are a number of secondary 
attributes that you can also include with an intent: 

category -- Gives additional information about the action to execute. For 
example, (|android.content.Intent|) means it should appear in the Launcher as a 
top-level application, while (|android.content.Intent|) means it should be 
included in a list of alternative actions the user can perform on a piece of 
data. type -- Specifies an explicit type (a MIME type) of the intent data. 
Normally the type is inferred from the data itself. By setting this attribute, 
you disable that evaluation and force an explicit type. component -- Specifies 
an explicit name of a component class to use for the intent. Normally this is 
determined by looking at the other information in the intent (the action, 
data/type, and categories) and matching that with a component that can handle 
it. If this attribute is set then none of the evaluation is performed, and this 
component is used exactly as is. By specifying this attribute, all of the other 
Intent attributes become optional. extras -- This is a (|android.os.Bundle|) of 
any additional information. This can be used to provide extended information to 
the component. For example, if we have a action to send an e-mail message, we 
could also include extra pieces of data here to supply a subject, body, etc. 

Here are some examples of other operations you can specify as intents using 
these additional parameters: 

(|android.content.Intent|) with category (|android.content.Intent|) -- Launch 
the home screen. 

(|android.content.Intent|) with MIME type 
vnd.android.cursor.item/phone(|android.provider.Contacts.Phones|) -- Display 
the list of people's phone numbers, allowing the user to browse through them 
and pick one and return it to the parent activity. 

(|android.content.Intent|) with MIME type */* and category 
(|android.content.Intent|) -- Display all pickers for data that can be opened 
with ContentResolver.openInputStream()(|android.content.ContentResolver|) , 
allowing the user to pick one of them and then some data inside of it and 
returning the resulting URI to the caller. This can be used, for example, in an 
e-mail application to allow the user to pick some data to include as an 
attachment. 



There are a variety of standard Intent action and category constants defined in 
the Intent class, but applications can also define their own. These strings use 
java style scoping, to ensure they are unique -- for example, the standard 
(|android.content.Intent|) is called "android.intent.action.VIEW". 

Put together, the set of actions, data types, categories, and extra data 
defines a language for the system allowing for the expression of phrases such 
as "call john smith's cell". As applications are added to the system, they can 
extend this language by adding new actions, types, and categories, or they can 
modify the behavior of existing phrases by supplying their own activities that 
handle them. 

Intent Resolution 

There are two primary forms of intents you will use. 

Explicit Intents have specified a component (via (|android.content.Intent|) or 
(|android.content.Intent|) ), which provides the exact class to be run. Often 
these will not include any other information, simply being a way for an 
application to launch various internal activities it has as the user interacts 
with the application. 

Implicit Intents have not specified a component; instead, they must include 
enough information for the system to determine which of the available 
components is best to run for that intent. 

When using implicit intents, given such an arbitrary intent we need to know 
what to do with it. This is handled by the process of Intent resolution, which 
maps an Intent to an (|android.app.Activity|) , 
(|android.content.BroadcastReceiver|) , or (|android.app.Service|) (or 
sometimes two or more activities/receivers) that can handle it. 

The intent resolution mechanism basically revolves around matching an Intent 
against all of the <intent-filter> descriptions in the installed application 
packages. (Plus, in the case of broadcasts, any 
(|android.content.BroadcastReceiver|) objects explicitly registered with 
(|android.content.Context|) .) More details on this can be found in the 
documentation on the (|android.content.IntentFilter|) class. 

There are three pieces of information in the Intent that are used for 
resolution: the action, type, and category. Using this information, a query is 
done on the (|android.content.pm.PackageManager|) for a component that can 
handle the intent. The appropriate component is determined based on the intent 
information supplied in the AndroidManifest.xml file as follows: 

The action, if given, must be listed by the component as one it handles. The 
type is retrieved from the Intent's data, if not already supplied in the 
Intent. Like the action, if a type is included in the intent (either explicitly 
or implicitly in its data), then this must be listed by the component as one it 
handles. For data that is not a content: URI and where no explicit type is 
included in the Intent, instead the scheme of the intent data (such as http: or 
mailto:) is considered. Again like the action, if we are matching a scheme it 
must be listed by the component as one it can handle. The categories, if 
supplied, must all be listed by the activity as categories it handles. That is, 
if you include the categories (|android.content.Intent|) and 
(|android.content.Intent|) , then you will only resolve to components with an 
intent that lists both of those categories. Activities will very often need to 
support the (|android.content.Intent|) so that they can be found by 
Context.startActivity()(|android.content.Context|) . 

For example, consider the Note Pad sample application that allows user to 
browse through a list of notes data and view details about individual items. 
Text in italics indicate places were you would replace a name with one specific 
to your own package. 

<manifest xmlns:android="http://schemas.android.com/apk/res/android" 
package="com.android.notepad"> <application android:icon="@drawable/app_notes" 
android:label="@string/app_name"> 

<provider class=".NotePadProvider" 
android:authorities="com.google.provider.NotePad" /> 

<activity class=".NotesList" android:label="@string/title_notes_list"> 
<intent-filter> <action android:name="android.intent.action.MAIN" /> <category 
android:name="android.intent.category.LAUNCHER" /> </intent-filter> 
<intent-filter> <action android:name="android.intent.action.VIEW" /> <action 
android:name="android.intent.action.EDIT" /> <action 
android:name="android.intent.action.PICK" /> <category 
android:name="android.intent.category.DEFAULT" /> <data 
android:mimeType="vnd.android.cursor.dir/vnd.google.note" /> </intent-filter> 
<intent-filter> <action android:name="android.intent.action.GET_CONTENT" /> 
<category android:name="android.intent.category.DEFAULT" /> <data 
android:mimeType="vnd.android.cursor.item/vnd.google.note" /> </intent-filter> 
</activity> 

<activity class=".NoteEditor" android:label="@string/title_note"> 
<intent-filter android:label="@string/resolve_edit"> <action 
android:name="android.intent.action.VIEW" /> <action 
android:name="android.intent.action.EDIT" /> <category 
android:name="android.intent.category.DEFAULT" /> <data 
android:mimeType="vnd.android.cursor.item/vnd.google.note" /> </intent-filter> 

<intent-filter> <action android:name="android.intent.action.INSERT" /> 
<category android:name="android.intent.category.DEFAULT" /> <data 
android:mimeType="vnd.android.cursor.dir/vnd.google.note" /> </intent-filter> 

</activity> 

<activity class=".TitleEditor" android:label="@string/title_edit_title" 
android:theme="@android:style/Theme.Dialog"> <intent-filter 
android:label="@string/resolve_title"> <action 
android:name="com.android.notepad.action.EDIT_TITLE" /> <category 
android:name="android.intent.category.DEFAULT" /> <category 
android:name="android.intent.category.ALTERNATIVE" /> <category 
android:name="android.intent.category.SELECTED_ALTERNATIVE" /> <data 
android:mimeType="vnd.android.cursor.item/vnd.google.note" /> </intent-filter> 
</activity> 

</application> </manifest> 

The first activity, com.android.notepad.NotesList, serves as our main entry 
into the app. It can do three things as described by its three intent 
templates: 



<intent-filter> <action android:name=" 
android.intent.action.MAIN(|android.content.Intent|) " /> <category 
android:name=" android.intent.category.LAUNCHER(|android.content.Intent|) " /> 
</intent-filter> 

This provides a top-level entry into the NotePad application: the standard MAIN 
action is a main entry point (not requiring any other information in the 
Intent), and the LAUNCHER category says that this entry point should be listed 
in the application launcher. 

<intent-filter> <action android:name=" 
android.intent.action.VIEW(|android.content.Intent|) " /> <action 
android:name=" android.intent.action.EDIT(|android.content.Intent|) " /> 
<action android:name=" android.intent.action.PICK(|android.content.Intent|) " 
/> <category android:name=" 
android.intent.category.DEFAULT(|android.content.Intent|) " /> <data 
mimeType:name="vnd.android.cursor.dir/vnd.google.note" /> </intent-filter> 

This declares the things that the activity can do on a directory of notes. The 
type being supported is given with the <type> tag, where 
vnd.android.cursor.dir/vnd.google.note is a URI from which a Cursor of zero or 
more items (vnd.android.cursor.dir) can be retrieved which holds our note pad 
data (vnd.google.note). The activity allows the user to view or edit the 
directory of data (via the VIEW and EDIT actions), or to pick a particular note 
and return it to the caller (via the PICK action). Note also the DEFAULT 
category supplied here: this is required for the 
Context.startActivity(|android.content.Context|) method to resolve your 
activity when its component name is not explicitly specified. 

<intent-filter> <action android:name=" 
android.intent.action.GET_CONTENT(|android.content.Intent|) " /> <category 
android:name=" android.intent.category.DEFAULT(|android.content.Intent|) " /> 
<data android:mimeType="vnd.android.cursor.item/vnd.google.note" /> 
</intent-filter> 

This filter describes the ability return to the caller a note selected by the 
user without needing to know where it came from. The data type 
vnd.android.cursor.item/vnd.google.note is a URI from which a Cursor of exactly 
one (vnd.android.cursor.item) item can be retrieved which contains our note pad 
data (vnd.google.note). The GET_CONTENT action is similar to the PICK action, 
where the activity will return to its caller a piece of data selected by the 
user. Here, however, the caller specifies the type of data they desire instead 
of the type of data the user will be picking from. 

Given these capabilities, the following intents will resolve to the NotesList 
activity: 

{ action=android.app.action.MAIN } matches all of the activities that can be 
used as top-level entry points into an application. { 
action=android.app.action.MAIN, category=android.app.category.LAUNCHER } is the 
actual intent used by the Launcher to populate its top-level list. { 
action=android.intent.action.VIEW 
data=content://com.google.provider.NotePad/notes } displays a list of all the 
notes under "content://com.google.provider.NotePad/notes", which the user can 
browse through and see the details on. { action=android.app.action.PICK 
data=content://com.google.provider.NotePad/notes } provides a list of the notes 
under "content://com.google.provider.NotePad/notes", from which the user can 
pick a note whose data URL is returned back to the caller. { 
action=android.app.action.GET_CONTENT 
type=vnd.android.cursor.item/vnd.google.note } is similar to the pick action, 
but allows the caller to specify the kind of data they want back so that the 
system can find the appropriate activity to pick something of that data type. 

The second activity, com.android.notepad.NoteEditor, shows the user a single 
note entry and allows them to edit it. It can do two things as described by its 
two intent templates: 



<intent-filter android:label="@string/resolve_edit"> <action android:name=" 
android.intent.action.VIEW(|android.content.Intent|) " /> <action 
android:name=" android.intent.action.EDIT(|android.content.Intent|) " /> 
<category android:name=" 
android.intent.category.DEFAULT(|android.content.Intent|) " /> <data 
android:mimeType="vnd.android.cursor.item/vnd.google.note" /> </intent-filter> 

The first, primary, purpose of this activity is to let the user interact with a 
single note, as decribed by the MIME type 
vnd.android.cursor.item/vnd.google.note. The activity can either VIEW a note or 
allow the user to EDIT it. Again we support the DEFAULT category to allow the 
activity to be launched without explicitly specifying its component. 

<intent-filter> <action android:name=" 
android.intent.action.INSERT(|android.content.Intent|) " /> <category 
android:name=" android.intent.category.DEFAULT(|android.content.Intent|) " /> 
<data android:mimeType="vnd.android.cursor.dir/vnd.google.note" /> 
</intent-filter> 

The secondary use of this activity is to insert a new note entry into an 
existing directory of notes. This is used when the user creates a new note: the 
INSERT action is executed on the directory of notes, causing this activity to 
run and have the user create the new note data which it then adds to the 
content provider. 

Given these capabilities, the following intents will resolve to the NoteEditor 
activity: 

{ action=android.intent.action.VIEW 
data=content://com.google.provider.NotePad/notes/{ID} } shows the user the 
content of note {ID}. { action=android.app.action.EDIT 
data=content://com.google.provider.NotePad/notes/{ID} } allows the user to edit 
the content of note {ID}. { action=android.app.action.INSERT 
data=content://com.google.provider.NotePad/notes } creates a new, empty note in 
the notes list at "content://com.google.provider.NotePad/notes" and allows the 
user to edit it. If they keep their changes, the URI of the newly created note 
is returned to the caller. 

The last activity, com.android.notepad.TitleEditor, allows the user to edit the 
title of a note. This could be implemented as a class that the application 
directly invokes (by explicitly setting its component in the Intent), but here 
we show a way you can publish alternative operations on existing data: 



<intent-filter android:label="@string/resolve_title"> <action 
android:name="com.android.notepad.action.EDIT_TITLE" /> <category 
android:name=" android.intent.category.DEFAULT(|android.content.Intent|) " /> 
<category android:name=" 
android.intent.category.ALTERNATIVE(|android.content.Intent|) " /> <category 
android:name=" 
android.intent.category.SELECTED_ALTERNATIVE(|android.content.Intent|) " /> 
<data android:mimeType="vnd.android.cursor.item/vnd.google.note" /> 
</intent-filter> 

In the single intent template here, we have created our own private action 
called com.android.notepad.action.EDIT_TITLE which means to edit the title of a 
note. It must be invoked on a specific note (data type 
vnd.android.cursor.item/vnd.google.note) like the previous view and edit 
actions, but here displays and edits the title contained in the note data. 

In addition to supporting the default category as usual, our title editor also 
supports two other standard categories: ALTERNATIVE and SELECTED_ALTERNATIVE. 
Implementing these categories allows others to find the special action it 
provides without directly knowing about it, through the 
(|android.content.pm.PackageManager|) method, or more often to build dynamic 
menu items with (|android.view.Menu|) . Note that in the intent template here 
was also supply an explicit name for the template (via 
android:label="@string/resolve_title") to better control what the user sees 
when presented with this activity as an alternative action to the data they are 
viewing. 

Given these capabilities, the following intent will resolve to the TitleEditor 
activity: 

{ action=com.android.notepad.action.EDIT_TITLE 
data=content://com.google.provider.NotePad/notes/{ID} } displays and allows the 
user to edit the title associated with note {ID}. 

Standard Activity Actions 

These are the current standard actions that Intent defines for launching 
activities (usually through (|android.content.Context|) . The most important, 
and by far most frequently used, are (|android.content.Intent|) and 
(|android.content.Intent|) . 

(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 

Standard Broadcast Actions 

These are the current standard actions that Intent defines for receiving 
broadcasts (usually through (|android.content.Context|) or a <receiver> tag in 
a manifest). 

(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 

Standard Categories 

These are the current standard categories that can be used to further clarify 
an Intent via (|android.content.Intent|) . 

(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 

Standard Extra Data 

These are the current standard fields that can be used as extra data via 
(|android.content.Intent|) . 

(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) (|android.content.Intent|) 
(|android.content.Intent|) 

Flags 

These are the possible flags that can be used in the Intent via 
(|android.content.Intent|) and (|android.content.Intent|) . See 
(|android.content.Intent|) for a list of all possible flags. 



*java.lang.String_android.content.Intent.ACTION_ADVANCED_SETTINGS_CHANGED*

Broadcast Action: The user has switched on advanced settings in the settings 
app: 

state - A boolean value indicating whether the settings is on or off. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED*

Broadcast Action: The user has switched the phone into or out of Airplane Mode. 
One or more radios have been turned off or on. The intent will have the 
following extra value: 

state - A boolean value indicating whether Airplane Mode is on. If true, then 
cell radio and possibly other radios such as bluetooth or WiFi may have also 
been turned off 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_ALARM_CHANGED*

Alarm Changed Action: This is broadcast when the AlarmClock application's alarm 
is set or unset. It is used by the AlarmClock application and the StatusBar 
service. 


*java.lang.String_android.content.Intent.ACTION_ALL_APPS*

Activity Action: List all available applications Input: Nothing. Output: 
nothing. 


*java.lang.String_android.content.Intent.ACTION_ANALOG_AUDIO_DOCK_PLUG*

Broadcast Action: An analog audio speaker/headset plugged in or unplugged. 

The intent will have the following extra values: 

state - 0 for unplugged, 1 for plugged. name - Headset type, human readable 
string 




*java.lang.String_android.content.Intent.ACTION_ANSWER*

Activity Action: Handle an incoming phone call. Input: nothing. Output: 
nothing. 


*java.lang.String_android.content.Intent.ACTION_APP_ERROR*

Activity Action: The user pressed the "Report" button in the crash/ANR dialog. 
This intent is delivered to the package which installed the application, 
usually Google Play. Input: No data is specified. The bug report is passed in 
using an (|android.content.Intent|) field. Output: Nothing. 


*java.lang.String_android.content.Intent.ACTION_ASSIST*

Activity Action: Perform assist action. 

Input: (|android.content.Intent|) , (|android.content.Intent|) , can provide 
additional optional contextual information about where the user was when they 
requested the assist. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_ATTACH_DATA*

Used to indicate that some piece of data should be attached to some other 
place. For example, image data could be attached to a contact. It is up to the 
recipient to decide where the data should be attached; the intent does not 
specify the ultimate destination. Input: (|android.content.Intent|) is URI of 
data to be attached. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_BATTERY_CHANGED*

Broadcast Action: This is a sticky broadcast containing the charging state, 
level, and other information about the battery. See 
(|android.os.BatteryManager|) for documentation on the contents of the Intent. 

You can not receive this through components declared in manifests, only by 
explicitly registering for it with 
Context.registerReceiver()(|android.content.Context|) . See 
(|android.content.Intent|) , (|android.content.Intent|) , 
(|android.content.Intent|) , and (|android.content.Intent|) for distinct 
battery-related broadcasts that are sent and can be received through manifest 
receivers. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_BATTERY_LOW*

Broadcast Action: Indicates low battery condition on the device. This broadcast 
corresponds to the "Low battery warning" system dialog. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_BATTERY_OKAY*

Broadcast Action: Indicates the battery is now okay after being low. This will 
be sent after (|android.content.Intent|) once the battery has gone back up to 
an okay state. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_BOOT_COMPLETED*

Broadcast Action: This is broadcast once, after the system has finished 
booting. It can be used to perform application-specific initialization, such as 
installing alarms. You must hold the (|android.Manifest.permission|) permission 
in order to receive this broadcast. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_BUG_REPORT*

Activity Action: Show activity for reporting a bug. Input: Nothing. Output: 
Nothing. 


*java.lang.String_android.content.Intent.ACTION_CALL*

Activity Action: Perform a call to someone specified by the data. Input: If 
nothing, an empty dialer is started; else (|android.content.Intent|) is URI of 
a phone number to be dialed or a tel: URI of an explicit phone number. Output: 
nothing. 

Note: there will be restrictions on which applications can initiate a call; 
most applications should use the (|android.content.Intent|) . Note: this Intent 
cannot be used to call emergency numbers. Applications can dial emergency 
numbers using (|android.content.Intent|) , however. 


*java.lang.String_android.content.Intent.ACTION_CALL_BUTTON*

Activity Action: The user pressed the "call" button to go to the dialer or 
other appropriate UI for placing a call. Input: Nothing. Output: Nothing. 


*java.lang.String_android.content.Intent.ACTION_CALL_EMERGENCY*

Activity Action: Perform a call to an emergency number specified by the data. 
Input: (|android.content.Intent|) is URI of a phone number to be dialed or a 
tel: URI of an explicit phone number. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_CALL_PRIVILEGED*

Activity action: Perform a call to any number (emergency or not) specified by 
the data. Input: (|android.content.Intent|) is URI of a phone number to be 
dialed or a tel: URI of an explicit phone number. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_CAMERA_BUTTON*

Broadcast Action: The "Camera Button" was pressed. Includes a single extra 
field, (|android.content.Intent|) , containing the key event that caused the 
broadcast. 


*java.lang.String_android.content.Intent.ACTION_CHOOSER*

Activity Action: Display an activity chooser, allowing the user to pick what 
they want to before proceeding. This can be used as an alternative to the 
standard activity picker that is displayed by the system when you try to start 
an activity with multiple possible matches, with these differences in behavior: 

You can specify the title that will appear in the activity chooser. The user 
does not have the option to make one of the matching activities a preferred 
activity, and all possible activities will always be shown even if one of them 
is currently marked as the preferred activity. 

This action should be used when the user will naturally expect to select an 
activity in order to proceed. An example if when not to use it is when the user 
clicks on a "mailto:" link. They would naturally expect to go directly to their 
mail app, so startActivity() should be called directly: it will either launch 
the current preferred app, or put up a dialog allowing the user to pick an app 
to use and optionally marking that as preferred. 

In contrast, if the user is selecting a menu item to send a picture they are 
viewing to someone else, there are many different things they may want to do at 
this point: send it through e-mail, upload it to a web service, etc. In this 
case the CHOOSER action should be used, to always present to the user a list of 
the things they can do, with a nice title given by the caller such as "Send 
this photo with:". 

If you need to grant URI permissions through a chooser, you must specify the 
permissions to be granted on the ACTION_CHOOSER Intent in addition to the 
EXTRA_INTENT inside. This means using (|android.content.Intent|) to specify the 
URIs to be granted as well as (|android.content.Intent|) and/or 
(|android.content.Intent|) as appropriate. 

As a convenience, an Intent of this form can be created with the 
(|android.content.Intent|) function. 

Input: No data should be specified. get*Extra must have a 
(|android.content.Intent|) field containing the Intent being executed, and can 
optionally have a (|android.content.Intent|) field containing the title text to 
display in the chooser. 

Output: Depends on the protocol of (|android.content.Intent|) . 


*java.lang.String_android.content.Intent.ACTION_CLEAR_DNS_CACHE*

Clear DNS Cache Action: This is broadcast when networks have changed and old 
DNS entries should be tossed. 


*java.lang.String_android.content.Intent.ACTION_CLOSE_SYSTEM_DIALOGS*

Broadcast Action: This is broadcast when a user action should request a 
temporary system dialog to dismiss. Some examples of temporary system dialogs 
are the notification window-shade and the recent tasks dialog. 


*java.lang.String_android.content.Intent.ACTION_CONFIGURATION_CHANGED*

Broadcast Action: The current device (|android.content.res.Configuration|) 
(orientation, locale, etc) has changed. When such a change happens, the UIs 
(view hierarchy) will need to be rebuilt based on this new information; for the 
most part, applications don't need to worry about this, because the system will 
take care of stopping and restarting the application to make sure it sees the 
new changes. Some system code that can not be restarted will need to watch for 
this action and handle it appropriately. 

You can not receive this through components declared in manifests, only by 
explicitly registering for it with 
Context.registerReceiver()(|android.content.Context|) . 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_CREATE_DOCUMENT*

Activity Action: Allow the user to create a new document. When invoked, the 
system will display the various (|android.provider.DocumentsProvider|) 
instances installed on the device, letting the user navigate through them. The 
returned document may be a newly created document with no content, or it may be 
an existing document with the requested MIME type. 

Each document is represented as acontent://URI backed by a 
(|android.provider.DocumentsProvider|) , which can be opened as a stream with 
(|android.content.ContentResolver|) , or queried for 
(|android.provider.DocumentsContract.Document|) metadata. 

Callers must indicate the concrete MIME type of the document being created by 
setting (|android.content.Intent|) . This MIME type cannot be changed after the 
document is created. 

Callers can provide an initial display name through (|android.content.Intent|) 
, but the user may change this value before creating the file. 

Callers must include (|android.content.Intent|) in the Intent so that returned 
URIs can be opened with (|android.content.ContentResolver|) . 

Output: The URI of the item that was created. This must be acontent://URI so 
that any receiver can access it. 


*java.lang.String_android.content.Intent.ACTION_CREATE_SHORTCUT*

Activity Action: Creates a shortcut. Input: Nothing. Output: An Intent 
representing the shortcut. The intent must contain three extras: 
SHORTCUT_INTENT (value: Intent), SHORTCUT_NAME (value: String), and 
SHORTCUT_ICON (value: Bitmap) or SHORTCUT_ICON_RESOURCE (value: 
ShortcutIconResource). 


*java.lang.String_android.content.Intent.ACTION_DATE_CHANGED*

Broadcast Action: The date has changed. 


*java.lang.String_android.content.Intent.ACTION_DEFAULT*

A synonym for (|android.content.Intent|) , the "standard" action that is 
performed on a piece of data. 


*java.lang.String_android.content.Intent.ACTION_DELETE*

Activity Action: Delete the given data from its container. Input: 
(|android.content.Intent|) is URI of data to be deleted. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_DEVICE_STORAGE_FULL*

Broadcast Action: A sticky broadcast that indicates a memory full condition on 
the device. This is intended for activities that want to be able to fill the 
data partition completely, leaving only enough free space to prevent 
system-wide SQLite failures. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_DEVICE_STORAGE_LOW*

Broadcast Action: A sticky broadcast that indicates low memory condition on the 
device 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_DEVICE_STORAGE_NOT_FULL*

Broadcast Action: Indicates memory full condition on the device no longer 
exists. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_DEVICE_STORAGE_OK*

Broadcast Action: Indicates low memory condition on the device no longer exists 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_DIAL*

Activity Action: Dial a number as specified by the data. This shows a UI with 
the number being dialed, allowing the user to explicitly initiate the call. 
Input: If nothing, an empty dialer is started; else (|android.content.Intent|) 
is URI of a phone number to be dialed or a tel: URI of an explicit phone 
number. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_DIGITAL_AUDIO_DOCK_PLUG*

Broadcast Action: A digital audio speaker/headset plugged in or unplugged. 

The intent will have the following extra values: 

state - 0 for unplugged, 1 for plugged. name - Headset type, human readable 
string 




*java.lang.String_android.content.Intent.ACTION_DOCK_EVENT*

Broadcast Action: A sticky broadcast for changes in the physical docking state 
of the device. 

The intent will have the following extra values: 

(|android.content.Intent|) - the current dock state, indicating which dock the 
device is physically in. 

This is intended for monitoring the current physical dock state. See 
(|android.app.UiModeManager|) for the normal API dealing with dock mode 
changes. 


*java.lang.String_android.content.Intent.ACTION_DREAMING_STARTED*

Broadcast Action: Sent after the system starts dreaming. 

This is a protected intent that can only be sent by the system. It is only sent 
to registered receivers. 


*java.lang.String_android.content.Intent.ACTION_DREAMING_STOPPED*

Broadcast Action: Sent after the system stops dreaming. 

This is a protected intent that can only be sent by the system. It is only sent 
to registered receivers. 


*java.lang.String_android.content.Intent.ACTION_EDIT*

Activity Action: Provide explicit editable access to the given data. Input: 
(|android.content.Intent|) is URI of data to be edited. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE*

Broadcast Action: Resources for a set of packages (which were previously 
unavailable) are currently available since the media on which they exist is 
available. The extra data (|android.content.Intent|) contains a list of 
packages whose availability changed. The extra data (|android.content.Intent|) 
contains a list of uids of packages whose availability changed. Note that the 
packages in this list do not receive this broadcast. The specified set of 
packages are now available on the system. Includes the following extras: 

(|android.content.Intent|) is the set of packages whose resources(were 
previously unavailable) are currently available. (|android.content.Intent|) is 
the set of uids of the packages whose resources(were previously unavailable) 
are currently available. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE*

Broadcast Action: Resources for a set of packages are currently unavailable 
since the media on which they exist is unavailable. The extra data 
(|android.content.Intent|) contains a list of packages whose availability 
changed. The extra data (|android.content.Intent|) contains a list of uids of 
packages whose availability changed. The specified set of packages can no 
longer be launched and are practically unavailable on the system. Inclues the 
following extras: 

(|android.content.Intent|) is the set of packages whose resources are no longer 
available. (|android.content.Intent|) is the set of packages whose resources 
are no longer available. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_FACTORY_TEST*

Activity Action: Main entry point for factory tests. Only used when the device 
is booting in factory test node. The implementing package must be installed in 
the system image. Input: nothing Output: nothing 


*java.lang.String_android.content.Intent.ACTION_GET_CONTENT*

Activity Action: Allow the user to select a particular kind of data and return 
it. This is different than (|android.content.Intent|) in that here we just say 
what kind of data is desired, not a URI of existing data from which the user 
can pick. An ACTION_GET_CONTENT could allow the user to create the data as it 
runs (for example taking a picture or recording a sound), let them browse over 
the web and download the desired data, etc. 

There are two main ways to use this action: if you want a specific kind of 
data, such as a person contact, you set the MIME type to the kind of data you 
want and launch it with (|android.content.Context|) . The system will then 
launch the best application to select that kind of data for you. 

You may also be interested in any of a set of types of content the user can 
pick. For example, an e-mail application that wants to allow the user to add an 
attachment to an e-mail message can use this action to bring up a list of all 
of the types of content the user can attach. 

In this case, you should wrap the GET_CONTENT intent with a chooser (through 
(|android.content.Intent|) ), which will give the proper interface for the user 
to pick how to send your data and allow you to specify a prompt indicating what 
they are doing. You will usually specify a broad MIME type (such as image/* 
or*/*), resulting in a broad range of content types the user can select from. 

When using such a broad GET_CONTENT action, it is often desirable to only pick 
from data that can be represented as a stream. This is accomplished by 
requiring the (|android.content.Intent|) in the Intent. 

Callers can optionally specify (|android.content.Intent|) to request that the 
launched content chooser only returns results representing data that is locally 
available on the device. For example, if this extra is set to true then an 
image picker should not show any pictures that are available from a remote 
server but not already on the local device (thus requiring they be downloaded 
when opened). 

If the caller can handle multiple returned items (the user performing multiple 
selection), then it can specify (|android.content.Intent|) to indicate this. 

Input: (|android.content.Intent|) is the desired MIME type to retrieve. Note 
that no URI is supplied in the intent, as there are no constraints on where the 
returned data originally comes from. You may also include the 
(|android.content.Intent|) if you can only accept data that can be opened as a 
stream. You may use (|android.content.Intent|) to limit content selection to 
local data. You may use (|android.content.Intent|) to allow the user to select 
multiple items. 

Output: The URI of the item that was picked. This must be a content: URI so 
that any receiver can access it. 


*java.lang.String_android.content.Intent.ACTION_GET_RESTRICTION_ENTRIES*

Broadcast to a specific application to query any supported restrictions to 
impose on restricted users. The broadcast intent contains an extra 
(|android.content.Intent|) with the currently persisted restrictions as a 
Bundle of key/value pairs. The value types can be Boolean, String or String[] 
depending on the restriction type. The response should contain an extra 
(|android.content.Intent|) , which is of type ArrayList<RestrictionEntry>. It 
can also contain an extra (|android.content.Intent|) , which is of type Intent. 
The activity specified by that intent will be launched for a result which must 
contain one of the extras (|android.content.Intent|) or 
(|android.content.Intent|) . The keys and values of the returned restrictions 
will be persisted. 


*java.lang.String_android.content.Intent.ACTION_GLOBAL_BUTTON*

Broadcast Action: A global button was pressed. Includes a single extra field, 
(|android.content.Intent|) , containing the key event that caused the 
broadcast. 


*java.lang.String_android.content.Intent.ACTION_GTALK_SERVICE_CONNECTED*

Broadcast Action: A GTalk connection has been established. 


*java.lang.String_android.content.Intent.ACTION_GTALK_SERVICE_DISCONNECTED*

Broadcast Action: A GTalk connection has been disconnected. 


*java.lang.String_android.content.Intent.ACTION_HDMI_AUDIO_PLUG*

Broadcast Action: A HMDI cable was plugged or unplugged 

The intent will have the following extra values: 

state - 0 for unplugged, 1 for plugged. name - HDMI cable, human readable 
string 




*java.lang.String_android.content.Intent.ACTION_HEADSET_PLUG*

Broadcast Action: Wired Headset plugged in or unplugged. 

The intent will have the following extra values: 

state - 0 for unplugged, 1 for plugged. name - Headset type, human readable 
string microphone - 1 if headset has a microphone, 0 otherwise 




*java.lang.String_android.content.Intent.ACTION_IDLE_MAINTENANCE_END*

Broadcast Action: A broadcast when idle maintenance should be stopped. This 
means that the user was not interacting with the device as a result of which a 
broadcast with action (|android.content.Intent|) was sent and now the user 
started interacting with the device. Typical use of the idle maintenance is to 
perform somehow expensive tasks that can be postponed at a moment when they 
will not degrade user experience. 

In order to keep the device responsive in case of an unexpected user 
interaction, implementations of a maintenance task should be interruptible. 
Hence, on receiving a broadcast with this action, the maintenance task should 
be interrupted as soon as possible. In other words, you should not do the 
maintenance work in (|android.content.BroadcastReceiver|) , rather stop the 
maintenance service that was started on receiving of (|android.content.Intent|) 
.Also you should release the wake lock you acquired when your maintenance 
service started. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_IDLE_MAINTENANCE_START*

Broadcast Action: A broadcast when idle maintenance can be started. This means 
that the user is not interacting with the device and is not expected to do so 
soon. Typical use of the idle maintenance is to perform somehow expensive tasks 
that can be postponed at a moment when they will not degrade user experience. 

In order to keep the device responsive in case of an unexpected user 
interaction, implementations of a maintenance task should be interruptible. In 
such a scenario a broadcast with action (|android.content.Intent|) will be 
sent. In other words, you should not do the maintenance work in 
(|android.content.BroadcastReceiver|) , rather start a maintenance service by 
(|android.content.Context|) . Also you should hold a wake lock while your 
maintenance service is running to prevent the device going to sleep. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_INPUT_METHOD_CHANGED*

Broadcast Action: An input method has been changed. 


*java.lang.String_android.content.Intent.ACTION_INSERT*

Activity Action: Insert an empty item into the given container. Input: 
(|android.content.Intent|) is URI of the directory (vnd.android.cursor.dir/*) 
in which to place the data. Output: URI of the new data that was created. 


*java.lang.String_android.content.Intent.ACTION_INSERT_OR_EDIT*

Activity Action: Pick an existing item, or insert a new item, and then edit it. 
Input: (|android.content.Intent|) is the desired MIME type of the item to 
create or edit. The extras can contain type specific data to pass through to 
the editing/creating activity. Output: The URI of the item that was picked. 
This must be a content: URI so that any receiver can access it. 


*java.lang.String_android.content.Intent.ACTION_INSTALL_PACKAGE*

Activity Action: Launch application installer. 

Input: The data must be a content: or file: URI at which the application can be 
retrieved. As of (|android.os.Build.VERSION_CODES|) , you can also use 
"package:" to install an application for the current user that is already 
installed for another user. You can optionally supply 
(|android.content.Intent|) , (|android.content.Intent|) , 
(|android.content.Intent|) , and (|android.content.Intent|) . 

Output: If (|android.content.Intent|) , returns whether the install succeeded. 


*java.lang.String_android.content.Intent.ACTION_LOCALE_CHANGED*

Broadcast Action: The current device's locale has changed. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_MAIN*

Activity Action: Start as a main entry point, does not expect to receive data. 
Input: nothing Output: nothing 


*java.lang.String_android.content.Intent.ACTION_MANAGE_NETWORK_USAGE*

Activity Action: Show settings for managing network data usage of a specific 
application. Applications should define an activity that offers options to 
control data usage. 


*java.lang.String_android.content.Intent.ACTION_MANAGE_PACKAGE_STORAGE*

Broadcast Action: Indicates low memory condition notification acknowledged by 
user and package management should be started. This is triggered by the user 
from the ACTION_DEVICE_STORAGE_LOW notification. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_BAD_REMOVAL*

Broadcast Action: External media was removed from SD card slot, but mount point 
was not unmounted. The path to the mount point for the removed media is 
contained in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_BUTTON*

Broadcast Action: The "Media Button" was pressed. Includes a single extra 
field, (|android.content.Intent|) , containing the key event that caused the 
broadcast. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_CHECKING*

Broadcast Action: External media is present, and being disk-checked The path to 
the mount point for the checking media is contained in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_EJECT*

Broadcast Action: User has expressed the desire to remove the external storage 
media. Applications should close all files they have open within the mount 
point when they receive this intent. The path to the mount point for the media 
to be ejected is contained in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_MOUNTED*

Broadcast Action: External media is present and mounted at its mount point. The 
path to the mount point for the mounted media is contained in the Intent.mData 
field. The Intent contains an extra with name "read-only" and Boolean value to 
indicate if the media was mounted read only. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_NOFS*

Broadcast Action: External media is present, but is using an incompatible fs 
(or is blank) The path to the mount point for the checking media is contained 
in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_REMOVED*

Broadcast Action: External media has been removed. The path to the mount point 
for the removed media is contained in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_SCANNER_FINISHED*

Broadcast Action: The media scanner has finished scanning a directory. The path 
to the scanned directory is contained in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_SCANNER_SCAN_FILE*

Broadcast Action: Request the media scanner to scan a file and add it to the 
media database. The path to the file is contained in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_SCANNER_STARTED*

Broadcast Action: The media scanner has started scanning a directory. The path 
to the directory being scanned is contained in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_SHARED*

Broadcast Action: External media is unmounted because it is being shared via 
USB mass storage. The path to the mount point for the shared media is contained 
in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_UNMOUNTABLE*

Broadcast Action: External media is present but cannot be mounted. The path to 
the mount point for the unmountable media is contained in the Intent.mData 
field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_UNMOUNTED*

Broadcast Action: External media is present, but not mounted at its mount 
point. The path to the mount point for the unmounted media is contained in the 
Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MEDIA_UNSHARED*

Broadcast Action: External media is no longer being shared via USB mass 
storage. The path to the mount point for the previously shared media is 
contained in the Intent.mData field. 


*java.lang.String_android.content.Intent.ACTION_MY_PACKAGE_REPLACED*

Broadcast Action: A new version of your application has been installed over an 
existing one. This is only sent to the application that was replaced. It does 
not contain any additional data; to receive it, just use an intent filter for 
this action. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_NEW_OUTGOING_CALL*

Broadcast Action: An outgoing call is about to be placed. 

The Intent will have the following extra value: 

(|android.content.Intent|) - the phone number originally intended to be dialed. 

Once the broadcast is finished, the resultData is used as the actual number to 
call. If null, no call will be placed. It is perfectly acceptable for multiple 
receivers to process the outgoing call in turn: for example, a parental control 
application might verify that the user is authorized to place the call at that 
time, then a number-rewriting application might add an area code if one was not 
specified. For consistency, any receiver whose purpose is to prohibit phone 
calls should have a priority of 0, to ensure it will see the final phone number 
to be dialed. Any receiver whose purpose is to rewrite phone numbers to be 
called should have a positive priority. Negative priorities are reserved for 
the system for this broadcast; using them may cause problems. Any 
BroadcastReceiver receiving this Intent must not abort the broadcast. Emergency 
calls cannot be intercepted using this mechanism, and other calls cannot be 
modified to call emergency numbers using this mechanism. Some apps (such as 
VoIP apps) may want to redirect the outgoing call to use their own service 
instead. Those apps should first prevent the call from being placed by setting 
resultData to null and then start their own app to make the call. You must hold 
the (|android.Manifest.permission|) permission to receive this Intent. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_OPEN_DOCUMENT*

Activity Action: Allow the user to select and return one or more existing 
documents. When invoked, the system will display the various 
(|android.provider.DocumentsProvider|) instances installed on the device, 
letting the user interactively navigate through them. These documents include 
local media, such as photos and video, and documents provided by installed 
cloud storage providers. 

Each document is represented as acontent://URI backed by a 
(|android.provider.DocumentsProvider|) , which can be opened as a stream with 
(|android.content.ContentResolver|) , or queried for 
(|android.provider.DocumentsContract.Document|) metadata. 

All selected documents are returned to the calling application with persistable 
read and write permission grants. If you want to maintain access to the 
documents across device reboots, you need to explicitly take the persistable 
permissions using (|android.content.ContentResolver|) . 

Callers can restrict document selection to a specific kind of data, such as 
photos, by setting one or more MIME types in (|android.content.Intent|) . 

If the caller can handle multiple returned items (the user performing multiple 
selection), then you can specify (|android.content.Intent|) to indicate this. 

Callers must include (|android.content.Intent|) in the Intent so that returned 
URIs can be opened with (|android.content.ContentResolver|) . 

Output: The URI of the item that was picked. This must be acontent://URI so 
that any receiver can access it. If multiple documents were selected, they are 
returned in (|android.content.Intent|) . 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_ADDED*

Broadcast Action: A new application package has been installed on the device. 
The data contains the name of the package. Note that the newly installed 
package does not receive this broadcast. May include the following extras: 

(|android.content.Intent|) containing the integer uid assigned to the new 
package. (|android.content.Intent|) is set to true if this is following an 
(|android.content.Intent|) broadcast for the same package. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_CHANGED*

Broadcast Action: An existing application package has been changed (e.g. a 
component has been enabled or disabled). The data contains the name of the 
package. 

(|android.content.Intent|) containing the integer uid assigned to the package. 
(|android.content.Intent|) containing the class name of the changed components 
(or the package name itself). (|android.content.Intent|) containing boolean 
field to override the default action of restarting the application. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_DATA_CLEARED*

Broadcast Action: The user has cleared the data of a package. This should be 
preceded by (|android.content.Intent|) , after which all of its persistent data 
is erased and this broadcast sent. Note that the cleared package does not 
receive this broadcast. The data contains the name of the package. 

(|android.content.Intent|) containing the integer uid assigned to the package. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_FIRST_LAUNCH*

Broadcast Action: Sent to the installer package of an application when that 
application is first launched (that is the first time it is moved out of the 
stopped state). The data contains the name of the package. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_FULLY_REMOVED*

Broadcast Action: An existing application package has been completely removed 
from the device. The data contains the name of the package. This is like 
(|android.content.Intent|) , but only set when (|android.content.Intent|) is 
true and (|android.content.Intent|) is false of that broadcast. 

(|android.content.Intent|) containing the integer uid previously assigned to 
the package. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_INSTALL*

Broadcast Action: Trigger the download and eventual installation of a package. 
Input: (|android.content.Intent|) is the URI of the package file to download. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_NEEDS_VERIFICATION*

Broadcast Action: Sent to the system package verifier when a package needs to 
be verified. The data contains the package URI. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_REMOVED*

Broadcast Action: An existing application package has been removed from the 
device. The data contains the name of the package. The package that is being 
installed does not receive this Intent. 

(|android.content.Intent|) containing the integer uid previously assigned to 
the package. (|android.content.Intent|) is set to true if the entire 
application -- data and code -- is being removed. (|android.content.Intent|) is 
set to true if this will be followed by an (|android.content.Intent|) broadcast 
for the same package. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_REPLACED*

Broadcast Action: A new version of an application package has been installed, 
replacing an existing version that was previously installed. The data contains 
the name of the package. May include the following extras: 

(|android.content.Intent|) containing the integer uid assigned to the new 
package. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_RESTARTED*

Broadcast Action: The user has restarted a package, and all of its processes 
have been killed. All runtime state associated with it (processes, alarms, 
notifications, etc) should be removed. Note that the restarted package does not 
receive this broadcast. The data contains the name of the package. 

(|android.content.Intent|) containing the integer uid assigned to the package. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PACKAGE_VERIFIED*

Broadcast Action: Sent to the system package verifier when a package is 
verified. The data contains the package URI. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_PASTE*

Activity Action: Create a new item in the given container, initializing it from 
the current contents of the clipboard. Input: (|android.content.Intent|) is URI 
of the directory (vnd.android.cursor.dir/*) in which to place the data. Output: 
URI of the new data that was created. 


*java.lang.String_android.content.Intent.ACTION_PICK*

Activity Action: Pick an item from the data, returning what was selected. 
Input: (|android.content.Intent|) is URI containing a directory of data 
(vnd.android.cursor.dir/*) from which to pick an item. Output: The URI of the 
item that was picked. 


*java.lang.String_android.content.Intent.ACTION_PICK_ACTIVITY*

Activity Action: Pick an activity given an intent, returning the class 
selected. Input: get*Extra field (|android.content.Intent|) is an Intent used 
with (|android.content.pm.PackageManager|) to determine the set of activities 
from which to pick. Output: Class name of the activity that was selected. 


*java.lang.String_android.content.Intent.ACTION_POWER_CONNECTED*

Broadcast Action: External power has been connected to the device. This is 
intended for applications that wish to register specifically to this 
notification. Unlike ACTION_BATTERY_CHANGED, applications will be woken for 
this and so do not have to stay active to receive this notification. This 
action can be used to implement actions that wait until power is available to 
trigger. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_POWER_DISCONNECTED*

Broadcast Action: External power has been removed from the device. This is 
intended for applications that wish to register specifically to this 
notification. Unlike ACTION_BATTERY_CHANGED, applications will be woken for 
this and so do not have to stay active to receive this notification. This 
action can be used to implement actions that wait until power is available to 
trigger. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_POWER_USAGE_SUMMARY*

Activity Action: Show power usage information to the user. Input: Nothing. 
Output: Nothing. 


*java.lang.String_android.content.Intent.ACTION_PRE_BOOT_COMPLETED*

Broadcast Action: hook for permforming cleanup after a system update. 

The broadcast is sent when the system is booting, before the BOOT_COMPLETED 
broadcast. It is only sent to receivers in the system image. A receiver for 
this should do its work and then disable itself so that it does not get run 
again at the next boot. 


*java.lang.String_android.content.Intent.ACTION_PROVIDER_CHANGED*

Broadcast Action: Some content providers have parts of their namespace where 
they publish new events or items that the user may be especially interested in. 
For these things, they may broadcast this action when the set of interesting 
items change. 

For example, GmailProvider sends this notification when the set of unread mail 
in the inbox changes. 

The data of the intent identifies which part of which provider changed. When 
queried through the content resolver, the data URI will return the data set in 
question. 

The intent will have the following extra values: 

count - The number of items in the data set. This is the same as the number of 
items in the cursor returned by querying the data URI. 

This intent will be sent at boot (if the count is non-zero) and when the data 
set changes. It is possible for the data set to change without the count 
changing (for example, if a new unread message arrives in the same sync 
operation in which a message is archived). The phone should still 
ring/vibrate/etc as normal in this case. 


*java.lang.String_android.content.Intent.ACTION_QUERY_PACKAGE_RESTART*




*java.lang.String_android.content.Intent.ACTION_QUICK_CLOCK*

Sent when the user taps on the clock widget in the system's "quick settings" 
area. 


*java.lang.String_android.content.Intent.ACTION_REBOOT*

Broadcast Action: Have the device reboot. This is only for use by system code. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_REMOTE_INTENT*

Broadcast Action: a remote intent is to be broadcasted. 

A remote intent is used for remote RPC between devices. The remote intent is 
serialized and sent from one device to another device. The receiving device 
parses the remote intent and broadcasts it. Note that anyone can broadcast a 
remote intent. However, if the intent receiver of the remote intent does not 
trust intent broadcasts from arbitrary intent senders, it should require the 
sender to hold certain permissions so only trusted sender's broadcast will be 
let through. 


*java.lang.String_android.content.Intent.ACTION_REQUEST_SHUTDOWN*

Activity Action: Start this activity to request system shutdown. The optional 
boolean extra field (|android.content.Intent|) can be set to true to request 
confirmation from the user before shutting down. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_RESTRICTIONS_CHALLENGE*




*java.lang.String_android.content.Intent.ACTION_RUN*

Activity Action: Run the data, whatever that means. Input: ? (Note: this is 
currently specific to the test harness.) Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_SCREEN_OFF*

Broadcast Action: Sent after the screen turns off. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_SCREEN_ON*

Broadcast Action: Sent after the screen turns on. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_SEARCH*

Activity Action: Perform a search. Input: 
getStringExtra(SearchManager.QUERY)(|android.app.SearchManager|) is the text to 
search for. If empty, simply enter your search results Activity with the search 
UI activated. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_SEARCH_LONG_PRESS*

Activity Action: Start action associated with long pressing on the search key. 
Input: Nothing. Output: Nothing. 


*java.lang.String_android.content.Intent.ACTION_SEND*

Activity Action: Deliver some data to someone else. Who the data is being 
delivered to is not specified; it is up to the receiver of this action to ask 
the user where the data should be sent. 

When launching a SEND intent, you should usually wrap it in a chooser (through 
(|android.content.Intent|) ), which will give the proper interface for the user 
to pick how to send your data and allow you to specify a prompt indicating what 
they are doing. 

Input: (|android.content.Intent|) is the MIME type of the data being sent. 
get*Extra can have either a (|android.content.Intent|) or 
(|android.content.Intent|) field, containing the data to be sent. If using 
EXTRA_TEXT, the MIME type should be "text/plain"; otherwise it should be the 
MIME type of the data in EXTRA_STREAM. Use*/* if the MIME type is unknown (this 
will only allow senders that can handle generic data streams). If using 
(|android.content.Intent|) , you can also optionally supply 
(|android.content.Intent|) for clients to retrieve your text with HTML 
formatting. 

As of (|android.os.Build.VERSION_CODES|) , the data being sent can be supplied 
through (|android.content.Intent|) . This allows you to use 
(|android.content.Intent|) when sharing content: URIs and other advanced 
features of (|android.content.ClipData|) . If using this approach, you still 
must supply the same data through the (|android.content.Intent|) or 
(|android.content.Intent|) fields described below for compatibility with old 
applications. If you don't set a ClipData, it will be copied there for you when 
calling (|android.content.Context|) . 

Optional standard extras, which may be interpreted by some recipients as 
appropriate, are: (|android.content.Intent|) , (|android.content.Intent|) , 
(|android.content.Intent|) , (|android.content.Intent|) . 

Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_SEND_MULTIPLE*

Activity Action: Deliver multiple data to someone else. 

Like (|android.content.Intent|) , except the data is multiple. 

Input: (|android.content.Intent|) is the MIME type of the data being sent. 
get*ArrayListExtra can have either a (|android.content.Intent|) or 
(|android.content.Intent|) field, containing the data to be sent. If using 
(|android.content.Intent|) , you can also optionally supply 
(|android.content.Intent|) for clients to retrieve your text with HTML 
formatting. 

Multiple types are supported, and receivers should handle mixed types whenever 
possible. The right way for the receiver to check them is to use the content 
resolver on each URI. The intent sender should try to put the most concrete 
mime type in the intent type, but it can fall back to/*or*/* as needed. 

e.g. if you are sending image/jpg and image/jpg, the intent's type can be 
image/jpg, but if you are sending image/jpg and image/png, then the intent's 
type should be image/*. 

As of (|android.os.Build.VERSION_CODES|) , the data being sent can be supplied 
through (|android.content.Intent|) . This allows you to use 
(|android.content.Intent|) when sharing content: URIs and other advanced 
features of (|android.content.ClipData|) . If using this approach, you still 
must supply the same data through the (|android.content.Intent|) or 
(|android.content.Intent|) fields described below for compatibility with old 
applications. If you don't set a ClipData, it will be copied there for you when 
calling (|android.content.Context|) . 

Optional standard extras, which may be interpreted by some recipients as 
appropriate, are: (|android.content.Intent|) , (|android.content.Intent|) , 
(|android.content.Intent|) , (|android.content.Intent|) . 

Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_SENDTO*

Activity Action: Send a message to someone specified by the data. Input: 
(|android.content.Intent|) is URI describing the target. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_SET_WALLPAPER*

Activity Action: Show settings for choosing wallpaper Input: Nothing. Output: 
Nothing. 


*java.lang.String_android.content.Intent.ACTION_SHOW_BRIGHTNESS_DIALOG*

Broadcast Action: This is broadcast when a user action should request the 
brightness setting dialog. 


*java.lang.String_android.content.Intent.ACTION_SHUTDOWN*

Broadcast Action: Device is shutting down. This is broadcast when the device is 
being shut down (completely turned off, not sleeping). Once the broadcast is 
complete, the final shutdown will proceed and all unsaved data lost. Apps will 
not normally need to handle this, since the foreground activity will be paused 
as well. 

This is a protected intent that can only be sent by the system. May include the 
following extras: 

(|android.content.Intent|) a boolean that is set to true if this shutdown is 
only for userspace processes. If not set, assumed to be false. 


*java.lang.String_android.content.Intent.ACTION_SYNC*

Activity Action: Perform a data synchronization. Input: ? Output: ? 


*java.lang.String_android.content.Intent.ACTION_SYNC_STATE_CHANGED*

Sync State Changed Action: This is broadcast when the sync starts or stops or 
when one has been failing for a long time. It is used by the SyncManager and 
the StatusBar service. 


*java.lang.String_android.content.Intent.ACTION_SYSTEM_TUTORIAL*

Activity Action: Start the platform-defined tutorial Input: 
getStringExtra(SearchManager.QUERY)(|android.app.SearchManager|) is the text to 
search for. If empty, simply enter your search results Activity with the search 
UI activated. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_TIME_CHANGED*

Broadcast Action: The time was set. 


*java.lang.String_android.content.Intent.ACTION_TIME_TICK*

Broadcast Action: The current time has changed. Sent every minute. You can not 
receive this through components declared in manifests, only by explicitly 
registering for it with Context.registerReceiver()(|android.content.Context|) . 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_TIMEZONE_CHANGED*

Broadcast Action: The timezone has changed. The intent will have the following 
extra values: 

time-zone - The java.util.TimeZone.getID() value identifying the new time zone. 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_UID_REMOVED*

Broadcast Action: A user ID has been removed from the system. The user ID 
number is stored in the extra data under (|android.content.Intent|) . 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_UMS_CONNECTED*

Broadcast Action: The device has entered USB Mass Storage mode. This is used 
mainly for the USB Settings panel. Apps should listen for ACTION_MEDIA_MOUNTED 
and ACTION_MEDIA_UNMOUNTED broadcasts to be notified when the SD card file 
system is mounted or unmounted 


*java.lang.String_android.content.Intent.ACTION_UMS_DISCONNECTED*

Broadcast Action: The device has exited USB Mass Storage mode. This is used 
mainly for the USB Settings panel. Apps should listen for ACTION_MEDIA_MOUNTED 
and ACTION_MEDIA_UNMOUNTED broadcasts to be notified when the SD card file 
system is mounted or unmounted 


*java.lang.String_android.content.Intent.ACTION_UNINSTALL_PACKAGE*

Activity Action: Launch application uninstaller. 

Input: The data must be a package: URI whose scheme specific part is the 
package name of the current installed package to be uninstalled. You can 
optionally supply (|android.content.Intent|) . 

Output: If (|android.content.Intent|) , returns whether the install succeeded. 


*java.lang.String_android.content.Intent.ACTION_UPGRADE_SETUP*

Activity Action: Setup wizard to launch after a platform update. This activity 
should have a string meta-data field associated with it, 
(|android.content.Intent|) , which defines the current version of the platform 
for setup. The activity will be launched only if 
(|android.provider.Settings.Secure|) is not the same value. Input: Nothing. 
Output: Nothing. 


*java.lang.String_android.content.Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG*

Broadcast Action: A USB audio accessory was plugged in or unplugged. 

The intent will have the following extra values: 

state - 0 for unplugged, 1 for plugged. card - ALSA card number (integer) 
device - ALSA device number (integer) 




*java.lang.String_android.content.Intent.ACTION_USB_AUDIO_DEVICE_PLUG*

Broadcast Action: A USB audio device was plugged in or unplugged. 

The intent will have the following extra values: 

state - 0 for unplugged, 1 for plugged. card - ALSA card number (integer) 
device - ALSA device number (integer) 




*java.lang.String_android.content.Intent.ACTION_USER_ADDED*

Broadcast sent to the system when a user is added. Carries an extra 
EXTRA_USER_HANDLE that has the userHandle of the new user. It is sent to all 
running users. You must hold (|android.Manifest.permission|) to receive this 
broadcast. 


*java.lang.String_android.content.Intent.ACTION_USER_BACKGROUND*

Sent when a user switch is happening, causing the process's user to be sent to 
the background. This is only sent to receivers registered through 
Context.registerReceiver(|android.content.Context|) . It is sent to the user 
that is going to the background. This is sent as a foreground broadcast, since 
it is part of a visible user interaction; be as quick as possible when handling 
it. 


*java.lang.String_android.content.Intent.ACTION_USER_FOREGROUND*

Sent when a user switch is happening, causing the process's user to be brought 
to the foreground. This is only sent to receivers registered through 
Context.registerReceiver(|android.content.Context|) . It is sent to the user 
that is going to the foreground. This is sent as a foreground broadcast, since 
it is part of a visible user interaction; be as quick as possible when handling 
it. 


*java.lang.String_android.content.Intent.ACTION_USER_INFO_CHANGED*

Broadcast sent to the system when a user's information changes. Carries an 
extra (|android.content.Intent|) to indicate which user's information changed. 
This is only sent to registered receivers, not manifest receivers. It is sent 
to all users. 


*java.lang.String_android.content.Intent.ACTION_USER_INITIALIZE*

Sent the first time a user is starting, to allow system apps to perform one 
time initialization. (This will not be seen by third party applications because 
a newly initialized user does not have any third party applications installed 
for it.) This is sent early in starting the user, around the time the home app 
is started, before (|android.content.Intent|) is sent. This is sent as a 
foreground broadcast, since it is part of a visible user interaction; be as 
quick as possible when handling it. 


*java.lang.String_android.content.Intent.ACTION_USER_PRESENT*

Broadcast Action: Sent when the user is present after device wakes up (e.g when 
the keyguard is gone). 

This is a protected intent that can only be sent by the system. 


*java.lang.String_android.content.Intent.ACTION_USER_REMOVED*

Broadcast sent to the system when a user is removed. Carries an extra 
EXTRA_USER_HANDLE that has the userHandle of the user. It is sent to all 
running users except the one that has been removed. The user will not be 
completely removed until all receivers have handled the broadcast. You must 
hold (|android.Manifest.permission|) to receive this broadcast. 


*java.lang.String_android.content.Intent.ACTION_USER_STARTED*

Broadcast sent by the system when a user is started. Carries an extra 
EXTRA_USER_HANDLE that has the userHandle of the user. This is only sent to 
registered receivers, not manifest receivers. It is sent to the user that has 
been started. This is sent as a foreground broadcast, since it is part of a 
visible user interaction; be as quick as possible when handling it. 


*java.lang.String_android.content.Intent.ACTION_USER_STARTING*

Broadcast sent when a user is in the process of starting. Carries an extra 
EXTRA_USER_HANDLE that has the userHandle of the user. This is only sent to 
registered receivers, not manifest receivers. It is sent to all users 
(including the one that is being started). You must hold 
(|android.Manifest.permission|) to receive this broadcast. This is sent as a 
background broadcast, since its result is not part of the primary UX flow; to 
safely keep track of started/stopped state of a user you can use this in 
conjunction with (|android.content.Intent|) . It is not generally safe to use 
with other user state broadcasts since those are foreground broadcasts so can 
execute in a different order. 


*java.lang.String_android.content.Intent.ACTION_USER_STOPPED*

Broadcast sent to the system when a user is stopped. Carries an extra 
EXTRA_USER_HANDLE that has the userHandle of the user. This is similar to 
(|android.content.Intent|) , but for an entire user instead of a specific 
package. This is only sent to registered receivers, not manifest receivers. It 
is sent to all running users except the one that has just been stopped (which 
is no longer running). 


*java.lang.String_android.content.Intent.ACTION_USER_STOPPING*

Broadcast sent when a user is going to be stopped. Carries an extra 
EXTRA_USER_HANDLE that has the userHandle of the user. This is only sent to 
registered receivers, not manifest receivers. It is sent to all users 
(including the one that is being stopped). You must hold 
(|android.Manifest.permission|) to receive this broadcast. The user will not 
stop until all receivers have handled the broadcast. This is sent as a 
background broadcast, since its result is not part of the primary UX flow; to 
safely keep track of started/stopped state of a user you can use this in 
conjunction with (|android.content.Intent|) . It is not generally safe to use 
with other user state broadcasts since those are foreground broadcasts so can 
execute in a different order. 


*java.lang.String_android.content.Intent.ACTION_USER_SWITCHED*

Broadcast sent to the system when the user switches. Carries an extra 
EXTRA_USER_HANDLE that has the userHandle of the user to become the current 
one. This is only sent to registered receivers, not manifest receivers. It is 
sent to all running users. You must hold (|android.Manifest.permission|) to 
receive this broadcast. 


*java.lang.String_android.content.Intent.ACTION_VIEW*

Activity Action: Display the data to the user. This is the most common action 
performed on data -- it is the generic action you can use on a piece of data to 
get the most reasonable thing to occur. For example, when used on a contacts 
entry it will view the entry; when used on a mailto: URI it will bring up a 
compose window filled with the information supplied by the URI; when used with 
a tel: URI it will invoke the dialer. Input: (|android.content.Intent|) is URI 
from which to retrieve data. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_VOICE_ASSIST*

Activity Action: Perform voice assist action. 

Input: (|android.content.Intent|) , (|android.content.Intent|) , can provide 
additional optional contextual information about where the user was when they 
requested the voice assist. Output: nothing. 


*java.lang.String_android.content.Intent.ACTION_VOICE_COMMAND*

Activity Action: Start Voice Command. Input: Nothing. Output: Nothing. 


*java.lang.String_android.content.Intent.ACTION_WALLPAPER_CHANGED*

Broadcast Action: The current system wallpaper has changed. See 
(|android.app.WallpaperManager|) for retrieving the new wallpaper. This should 
only be used to determine when the wallpaper has changed to show the new 
wallpaper to the user. You should certainly never, in response to this, change 
the wallpaper or other attributes of it such as the suggested size. That would 
be crazy, right? You'd cause all kinds of loops, especially if other apps are 
doing similar things, right? Of course. So please don't do this. 


*java.lang.String_android.content.Intent.ACTION_WEB_SEARCH*

Activity Action: Perform a web search. 

Input: getStringExtra(SearchManager.QUERY)(|android.app.SearchManager|) is the 
text to search for. If it is a url starts with http or https, the site will be 
opened. If it is plain text, Google search will be applied. 

Output: nothing. 


*java.lang.String_android.content.Intent.CATEGORY_ALTERNATIVE*

Set if the activity should be considered as an alternative action to the data 
the user is currently viewing. See also (|android.content.Intent|) for an 
alternative action that applies to the selection in a list of items. 

Supporting this category means that you would like your activity to be 
displayed in the set of alternative things the user can do, usually as part of 
the current activity's options menu. You will usually want to include a 
specific label in the <intent-filter> of this action describing to the user 
what it does. 

The action of IntentFilter with this category is important in that it describes 
the specific action the target will perform. This generally should not be a 
generic action (such as (|android.content.Intent|) , but rather a specific name 
such as "com.android.camera.action.CROP. Only one alternative of any particular 
action will be shown to the user, so using a specific action like this makes 
sure that your alternative will be displayed while also allowing other 
applications to provide their own overrides of that particular action. 


*java.lang.String_android.content.Intent.CATEGORY_APP_BROWSER*

Used with (|android.content.Intent|) to launch the browser application. The 
activity should be able to browse the Internet. NOTE: This should not be used 
as the primary key of an Intent, since it will not result in the app launching 
with the correct action and category. Instead, use this with 
(|android.content.Intent|) to generate a main Intent with this category in the 
selector. 


*java.lang.String_android.content.Intent.CATEGORY_APP_CALCULATOR*

Used with (|android.content.Intent|) to launch the calculator application. The 
activity should be able to perform standard arithmetic operations. NOTE: This 
should not be used as the primary key of an Intent, since it will not result in 
the app launching with the correct action and category. Instead, use this with 
(|android.content.Intent|) to generate a main Intent with this category in the 
selector. 


*java.lang.String_android.content.Intent.CATEGORY_APP_CALENDAR*

Used with (|android.content.Intent|) to launch the calendar application. The 
activity should be able to view and manipulate calendar entries. NOTE: This 
should not be used as the primary key of an Intent, since it will not result in 
the app launching with the correct action and category. Instead, use this with 
(|android.content.Intent|) to generate a main Intent with this category in the 
selector. 


*java.lang.String_android.content.Intent.CATEGORY_APP_CONTACTS*

Used with (|android.content.Intent|) to launch the contacts application. The 
activity should be able to view and manipulate address book entries. NOTE: This 
should not be used as the primary key of an Intent, since it will not result in 
the app launching with the correct action and category. Instead, use this with 
(|android.content.Intent|) to generate a main Intent with this category in the 
selector. 


*java.lang.String_android.content.Intent.CATEGORY_APP_EMAIL*

Used with (|android.content.Intent|) to launch the email application. The 
activity should be able to send and receive email. NOTE: This should not be 
used as the primary key of an Intent, since it will not result in the app 
launching with the correct action and category. Instead, use this with 
(|android.content.Intent|) to generate a main Intent with this category in the 
selector. 


*java.lang.String_android.content.Intent.CATEGORY_APP_GALLERY*

Used with (|android.content.Intent|) to launch the gallery application. The 
activity should be able to view and manipulate image and video files stored on 
the device. NOTE: This should not be used as the primary key of an Intent, 
since it will not result in the app launching with the correct action and 
category. Instead, use this with (|android.content.Intent|) to generate a main 
Intent with this category in the selector. 


*java.lang.String_android.content.Intent.CATEGORY_APP_MAPS*

Used with (|android.content.Intent|) to launch the maps application. The 
activity should be able to show the user's current location and surroundings. 
NOTE: This should not be used as the primary key of an Intent, since it will 
not result in the app launching with the correct action and category. Instead, 
use this with (|android.content.Intent|) to generate a main Intent with this 
category in the selector. 


*java.lang.String_android.content.Intent.CATEGORY_APP_MARKET*

This activity allows the user to browse and download new applications. 


*java.lang.String_android.content.Intent.CATEGORY_APP_MESSAGING*

Used with (|android.content.Intent|) to launch the messaging application. The 
activity should be able to send and receive text messages. NOTE: This should 
not be used as the primary key of an Intent, since it will not result in the 
app launching with the correct action and category. Instead, use this with 
(|android.content.Intent|) to generate a main Intent with this category in the 
selector. 


*java.lang.String_android.content.Intent.CATEGORY_APP_MUSIC*

Used with (|android.content.Intent|) to launch the music application. The 
activity should be able to play, browse, or manipulate music files stored on 
the device. NOTE: This should not be used as the primary key of an Intent, 
since it will not result in the app launching with the correct action and 
category. Instead, use this with (|android.content.Intent|) to generate a main 
Intent with this category in the selector. 


*java.lang.String_android.content.Intent.CATEGORY_BROWSABLE*

Activities that can be safely invoked from a browser must support this 
category. For example, if the user is viewing a web page or an e-mail and 
clicks on a link in the text, the Intent generated execute that link will 
require the BROWSABLE category, so that only activities supporting this 
category will be considered as possible actions. By supporting this category, 
you are promising that there is nothing damaging (without user intervention) 
that can happen by invoking any matching Intent. 


*java.lang.String_android.content.Intent.CATEGORY_CAR_DOCK*

An activity to run when device is inserted into a car dock. Used with 
(|android.content.Intent|) to launch an activity. For more information, see 
(|android.app.UiModeManager|) . 


*java.lang.String_android.content.Intent.CATEGORY_CAR_MODE*

Used to indicate that the activity can be used in a car environment. 


*java.lang.String_android.content.Intent.CATEGORY_DEFAULT*

Set if the activity should be an option for the default action (center press) 
to perform on a piece of data. Setting this will hide from the user any 
activities without it set when performing an action on some data. Note that 
this is normally -not- set in the Intent when initiating an action -- it is for 
use in intent filters specified in packages. 


*java.lang.String_android.content.Intent.CATEGORY_DESK_DOCK*

An activity to run when device is inserted into a car dock. Used with 
(|android.content.Intent|) to launch an activity. For more information, see 
(|android.app.UiModeManager|) . 


*java.lang.String_android.content.Intent.CATEGORY_DEVELOPMENT_PREFERENCE*

This activity is a development preference panel. 


*java.lang.String_android.content.Intent.CATEGORY_EMBED*

Capable of running inside a parent activity container. 


*java.lang.String_android.content.Intent.CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST*

To be used as code under test for framework instrumentation tests. 


*java.lang.String_android.content.Intent.CATEGORY_HE_DESK_DOCK*

An activity to run when device is inserted into a digital (high end) dock. Used 
with (|android.content.Intent|) to launch an activity. For more information, 
see (|android.app.UiModeManager|) . 


*java.lang.String_android.content.Intent.CATEGORY_HOME*

This is the home activity, that is the first activity that is displayed when 
the device boots. 


*java.lang.String_android.content.Intent.CATEGORY_INFO*

Provides information about the package it is in; typically used if a package 
does not contain a (|android.content.Intent|) to provide a front-door to the 
user without having to be shown in the all apps list. 


*java.lang.String_android.content.Intent.CATEGORY_LAUNCHER*

Should be displayed in the top-level launcher. 


*java.lang.String_android.content.Intent.CATEGORY_LE_DESK_DOCK*

An activity to run when device is inserted into a analog (low end) dock. Used 
with (|android.content.Intent|) to launch an activity. For more information, 
see (|android.app.UiModeManager|) . 


*java.lang.String_android.content.Intent.CATEGORY_MONKEY*

This activity may be exercised by the monkey or other automated test tools. 


*java.lang.String_android.content.Intent.CATEGORY_OPENABLE*

Used to indicate that an intent only wants URIs that can be opened with 
(|android.content.ContentResolver|) . Openable URIs must support at least the 
columns defined in (|android.provider.OpenableColumns|) when queried. 


*java.lang.String_android.content.Intent.CATEGORY_PREFERENCE*

This activity is a preference panel. 


*java.lang.String_android.content.Intent.CATEGORY_SAMPLE_CODE*

To be used as a sample code example (not part of the normal user experience). 


*java.lang.String_android.content.Intent.CATEGORY_SELECTED_ALTERNATIVE*

Set if the activity should be considered as an alternative selection action to 
the data the user has currently selected. This is like 
(|android.content.Intent|) , but is used in activities showing a list of items 
from which the user can select, giving them alternatives to the default action 
that will be performed on it. 


*java.lang.String_android.content.Intent.CATEGORY_TAB*

Intended to be used as a tab inside of a containing TabActivity. 


*java.lang.String_android.content.Intent.CATEGORY_TEST*

To be used as a test (not part of the normal user experience). 


*java.lang.String_android.content.Intent.CATEGORY_UNIT_TEST*

To be used as a unit test (run through the Test Harness). 


*android.os.Parcelable.Creator<android.content.Intent>_android.content.Intent.CREATOR*




*java.lang.String_android.content.Intent.EXTRA_ALARM_COUNT*

Used as an int extra field in (|android.app.AlarmManager|) intents to tell the 
application being invoked how many pending alarms are being delievered with the 
intent. For one-shot alarms this will always be 1. For recurring alarms, this 
might be greater than 1 if the device was asleep or powered off at the time an 
earlier alarm would have been delivered. 


*java.lang.String_android.content.Intent.EXTRA_ALLOW_MULTIPLE*

Extra used to indicate that an intent can allow the user to select and return 
multiple items. This is a boolean extra; the default is false. If true, an 
implementation is allowed to present the user with a UI where they can pick 
multiple items that are all returned to the caller. When this happens, they 
should be returned as the (|android.content.Intent|) part of the result Intent. 


*java.lang.String_android.content.Intent.EXTRA_ALLOW_REPLACE*

Used as a boolean extra field with (|android.content.Intent|) to install a 
package. Tells the installer UI to skip the confirmation with the user if the 
.apk is replacing an existing one. 


*java.lang.String_android.content.Intent.EXTRA_ASSIST_CONTEXT*

An optional field on (|android.content.Intent|) and containing additional 
contextual information supplied by the current foreground app at the time of 
the assist request. This is a (|android.os.Bundle|) of additional data. 


*java.lang.String_android.content.Intent.EXTRA_ASSIST_PACKAGE*

An optional field on (|android.content.Intent|) containing the name of the 
current foreground application package at the time the assist was invoked. 


*java.lang.String_android.content.Intent.EXTRA_BCC*

A String[] holding e-mail addresses that should be blind carbon copied. 


*java.lang.String_android.content.Intent.EXTRA_BUG_REPORT*

Used as a parcelable extra field in (|android.content.Intent|) , containing the 
bug report. 


*java.lang.String_android.content.Intent.EXTRA_CC*

A String[] holding e-mail addresses that should be carbon copied. 


*java.lang.String_android.content.Intent.EXTRA_CHANGED_COMPONENT_NAME*




*java.lang.String_android.content.Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST*

This field is part of (|android.content.Intent|) , and contains a string array 
of all of the components that have changed. If the state of the overall package 
has changed, then it will contain an entry with the package name itself. 


*java.lang.String_android.content.Intent.EXTRA_CHANGED_PACKAGE_LIST*

This field is part of (|android.content.Intent|) , (|android.content.Intent|) 
and contains a string array of all of the components that have changed. 


*java.lang.String_android.content.Intent.EXTRA_CHANGED_UID_LIST*

This field is part of (|android.content.Intent|) , (|android.content.Intent|) 
and contains an integer array of uids of all of the components that have 
changed. 


*java.lang.String_android.content.Intent.EXTRA_CLIENT_INTENT*




*java.lang.String_android.content.Intent.EXTRA_CLIENT_LABEL*




*java.lang.String_android.content.Intent.EXTRA_DATA_REMOVED*

Used as a boolean extra field in (|android.content.Intent|) intents to indicate 
whether this represents a full uninstall (removing both the code and its data) 
or a partial uninstall (leaving its data, implying that this is an update). 


*java.lang.String_android.content.Intent.EXTRA_DOCK_STATE*

Used as an int extra field in (|android.content.Intent|) intents to request the 
dock state. Possible values are (|android.content.Intent|) , 
(|android.content.Intent|) , or (|android.content.Intent|) , or 
(|android.content.Intent|) , or (|android.content.Intent|) . 


*int_android.content.Intent.EXTRA_DOCK_STATE_CAR*

Used as an int value for (|android.content.Intent|) to represent that the phone 
is in a car dock. 


*int_android.content.Intent.EXTRA_DOCK_STATE_DESK*

Used as an int value for (|android.content.Intent|) to represent that the phone 
is in a desk dock. 


*int_android.content.Intent.EXTRA_DOCK_STATE_HE_DESK*

Used as an int value for (|android.content.Intent|) to represent that the phone 
is in a digital (high end) dock. 


*int_android.content.Intent.EXTRA_DOCK_STATE_LE_DESK*

Used as an int value for (|android.content.Intent|) to represent that the phone 
is in a analog (low end) dock. 


*int_android.content.Intent.EXTRA_DOCK_STATE_UNDOCKED*

Used as an int value for (|android.content.Intent|) to represent that the phone 
is not in any dock. 


*java.lang.String_android.content.Intent.EXTRA_DONT_KILL_APP*

Used as a boolean extra field in (|android.content.Intent|) or 
(|android.content.Intent|) intents to override the default action of restarting 
the application. 


*java.lang.String_android.content.Intent.EXTRA_EMAIL*

A String[] holding e-mail addresses that should be delivered to. 


*java.lang.String_android.content.Intent.EXTRA_HTML_TEXT*

A constant String that is associated with the Intent, used with 
(|android.content.Intent|) to supply an alternative to 
(|android.content.Intent|) as HTML formatted text. Note that you must also 
supply (|android.content.Intent|) . 


*java.lang.String_android.content.Intent.EXTRA_INITIAL_INTENTS*

A Parcelable[] of (|android.content.Intent|) or 
(|android.content.pm.LabeledIntent|) objects as set with 
(|android.content.Intent|) of additional activities to place a the front of the 
list of choices, when shown to the user with a (|android.content.Intent|) . 


*java.lang.String_android.content.Intent.EXTRA_INSTALL_RESULT*

Package manager install result code. @hide because result codes are not yet 
ready to be exposed. 


*java.lang.String_android.content.Intent.EXTRA_INSTALLER_PACKAGE_NAME*

Used as a string extra field with (|android.content.Intent|) to install a 
package. Specifies the installer package name; this package will receive the 
(|android.content.Intent|) intent. 


*java.lang.String_android.content.Intent.EXTRA_INTENT*

An Intent describing the choices you would like shown with 
(|android.content.Intent|) . 


*java.lang.String_android.content.Intent.EXTRA_KEY_CONFIRM*

Set to true in (|android.content.Intent|) to request confirmation from the user 
before shutting down. 


*java.lang.String_android.content.Intent.EXTRA_KEY_EVENT*

A (|android.view.KeyEvent|) object containing the event that triggered the 
creation of the Intent it is in. 


*java.lang.String_android.content.Intent.EXTRA_LOCAL_ONLY*

Extra used to indicate that an intent should only return data that is on the 
local device. This is a boolean extra; the default is false. If true, an 
implementation should only allow the user to select data that is already on the 
device, not requiring it be downloaded from a remote service when opened. 


*java.lang.String_android.content.Intent.EXTRA_MIME_TYPES*

Extra used to communicate a set of acceptable MIME types. The type of the extra 
isString[]. Values may be a combination of concrete MIME types (such as 
"image/png") and/or partial MIME types (such as "audio/*"). 


*java.lang.String_android.content.Intent.EXTRA_NOT_UNKNOWN_SOURCE*

Used as a boolean extra field with (|android.content.Intent|) to install a 
package. Specifies that the application being installed should not be treated 
as coming from an unknown source, but as coming from the app invoking the 
Intent. For this to work you must start the installer with 
startActivityForResult(). 


*java.lang.String_android.content.Intent.EXTRA_ORIGINATING_UID*

Used as an int extra field with (|android.content.Intent|) and (|null|) 
#ACTION_VIEW} to indicate the uid of the package that initiated the install 


*java.lang.String_android.content.Intent.EXTRA_ORIGINATING_URI*

Used as a URI extra field with (|android.content.Intent|) and 
(|android.content.Intent|) to indicate the URI from which the local APK in the 
Intent data field originated from. 


*java.lang.String_android.content.Intent.EXTRA_PACKAGES*




*java.lang.String_android.content.Intent.EXTRA_PHONE_NUMBER*

A String holding the phone number originally entered in 
(|android.content.Intent|) , or the actual number to call in a 
(|android.content.Intent|) . 


*java.lang.String_android.content.Intent.EXTRA_REFERRER*

Used as a URI extra field with (|android.content.Intent|) and 
(|android.content.Intent|) to indicate the HTTP referrer URI associated with 
the Intent data field or (|android.content.Intent|) . 


*java.lang.String_android.content.Intent.EXTRA_REMOTE_INTENT_TOKEN*

Used in the extra field in the remote intent. It's astring token passed with 
the remote intent. 


*java.lang.String_android.content.Intent.EXTRA_REMOVED_FOR_ALL_USERS*




*java.lang.String_android.content.Intent.EXTRA_REPLACING*

Used as a boolean extra field in (|android.content.Intent|) intents to indicate 
that this is a replacement of the package, so this broadcast will immediately 
be followed by an add broadcast for a different version of the same package. 


*java.lang.String_android.content.Intent.EXTRA_RESTRICTIONS_BUNDLE*

Extra sent in the intent to the BroadcastReceiver that handles 
(|android.content.Intent|) . The type of the extra is a Bundle containing the 
restrictions as key/value pairs. 


*java.lang.String_android.content.Intent.EXTRA_RESTRICTIONS_INTENT*

Extra used in the response from a BroadcastReceiver that handles 
(|android.content.Intent|) . 


*java.lang.String_android.content.Intent.EXTRA_RESTRICTIONS_LIST*

Extra used in the response from a BroadcastReceiver that handles 
(|android.content.Intent|) . The type of the extra is 
ArrayList<RestrictionEntry>. 


*java.lang.String_android.content.Intent.EXTRA_RETURN_RESULT*

Used as a boolean extra field with (|android.content.Intent|) or 
(|android.content.Intent|) . Specifies that the installer UI should return to 
the application the result code of the install/uninstall. The returned result 
code will be (|android.app.Activity|) on success or (|android.app.Activity|) on 
failure. 


*java.lang.String_android.content.Intent.EXTRA_SHORTCUT_ICON*

The name of the extra used to define the icon, as a Bitmap, of a shortcut. 


*java.lang.String_android.content.Intent.EXTRA_SHORTCUT_ICON_RESOURCE*

The name of the extra used to define the icon, as a ShortcutIconResource, of a 
shortcut. 


*java.lang.String_android.content.Intent.EXTRA_SHORTCUT_INTENT*

The name of the extra used to define the Intent of a shortcut. 


*java.lang.String_android.content.Intent.EXTRA_SHORTCUT_NAME*

The name of the extra used to define the name of a shortcut. 


*java.lang.String_android.content.Intent.EXTRA_SHUTDOWN_USERSPACE_ONLY*

Optional extra for (|android.content.Intent|) that allows the sender to qualify 
that this shutdown is only for the user space of the system, not a complete 
shutdown. When this is true, hardware devices can use this information to 
determine that they shouldn't do a complete shutdown of their device since this 
is not a complete shutdown down to the kernel, but only user space restarting. 
The default if not supplied is false. 


*java.lang.String_android.content.Intent.EXTRA_STREAM*

A content: URI holding a stream of data associated with the Intent, used with 
(|android.content.Intent|) to supply the data being sent. 


*java.lang.String_android.content.Intent.EXTRA_SUBJECT*

A constant string holding the desired subject line of a message. 


*java.lang.String_android.content.Intent.EXTRA_TEMPLATE*

The initial data to place in a newly created record. Use with 
(|android.content.Intent|) . The data here is a Map containing the same fields 
as would be given to the underlying ContentProvider.insert() call. 


*java.lang.String_android.content.Intent.EXTRA_TEXT*

A constant CharSequence that is associated with the Intent, used with 
(|android.content.Intent|) to supply the literal data to be sent. Note that 
this may be a styled CharSequence, so you must use 
Bundle.getCharSequence()(|android.os.Bundle|) to retrieve it. 


*java.lang.String_android.content.Intent.EXTRA_TITLE*

A CharSequence dialog title to provide to the user when used with a 
(|android.content.Intent|) . 


*java.lang.String_android.content.Intent.EXTRA_UID*

Used as an int extra field in (|android.content.Intent|) intents to supply the 
uid the package had been assigned. Also an optional extra in 
(|android.content.Intent|) or (|android.content.Intent|) for the same purpose. 


*java.lang.String_android.content.Intent.EXTRA_UNINSTALL_ALL_USERS*

Specify whether the package should be uninstalled for all users. 


*java.lang.String_android.content.Intent.EXTRA_USER_HANDLE*

The userHandle carried with broadcast intents related to addition, removal and 
switching of users - (|android.content.Intent|) , (|android.content.Intent|) 
and (|android.content.Intent|) . 


*int_android.content.Intent.FILL_IN_ACTION*

Use with (|android.content.Intent|) to allow the current action value to be 
overwritten, even if it is already set. 


*int_android.content.Intent.FILL_IN_CATEGORIES*

Use with (|android.content.Intent|) to allow the current categories to be 
overwritten, even if they are already set. 


*int_android.content.Intent.FILL_IN_CLIP_DATA*

Use with (|android.content.Intent|) to allow the current ClipData to be 
overwritten, even if it is already set. 


*int_android.content.Intent.FILL_IN_COMPONENT*

Use with (|android.content.Intent|) to allow the current component value to be 
overwritten, even if it is already set. 


*int_android.content.Intent.FILL_IN_DATA*

Use with (|android.content.Intent|) to allow the current data or type value 
overwritten, even if it is already set. 


*int_android.content.Intent.FILL_IN_PACKAGE*

Use with (|android.content.Intent|) to allow the current package value to be 
overwritten, even if it is already set. 


*int_android.content.Intent.FILL_IN_SELECTOR*

Use with (|android.content.Intent|) to allow the current selector to be 
overwritten, even if it is already set. 


*int_android.content.Intent.FILL_IN_SOURCE_BOUNDS*

Use with (|android.content.Intent|) to allow the current bounds rectangle to be 
overwritten, even if it is already set. 


*int_android.content.Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT*

This flag is not normally set by application code, but set for you by the 
system as described in the launchMode(|android.R.styleable|) documentation for 
the singleTask mode. 


*int_android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK*

If set in an Intent passed to 
Context.startActivity()(|android.content.Context|) , this flag will cause any 
existing task that would be associated with the activity to be cleared before 
the activity is started. That is, the activity becomes the new root of an 
otherwise empty task, and any old activities are finished. This can only be 
used in conjunction with (|android.content.Intent|) . 


*int_android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP*

If set, and the activity being launched is already running in the current task, 
then instead of launching a new instance of that activity, all of the other 
activities on top of it will be closed and this Intent will be delivered to the 
(now on top) old activity as a new Intent. 

For example, consider a task consisting of the activities: A, B, C, D. If D 
calls startActivity() with an Intent that resolves to the component of activity 
B, then C and D will be finished and B receive the given Intent, resulting in 
the stack now being: A, B. 

The currently running instance of activity B in the above example will either 
receive the new intent you are starting here in its onNewIntent() method, or be 
itself finished and restarted with the new intent. If it has declared its 
launch mode to be "multiple" (the default) and you have not set 
(|android.content.Intent|) in the same intent, then it will be finished and 
re-created; for all other launch modes or if (|android.content.Intent|) is set 
then this Intent will be delivered to the current instance's onNewIntent(). 

This launch mode can also be used to good effect in conjunction with 
(|android.content.Intent|) : if used to start the root activity of a task, it 
will bring any currently running instance of that task to the foreground, and 
then clear it to its root state. This is especially useful, for example, when 
launching an activity from the notification manager. 

See <a href="guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and 
Back Stack for more information about tasks. 


*int_android.content.Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET*

If set, this marks a point in the task's activity stack that should be cleared 
when the task is reset. That is, the next time the task is brought to the 
foreground with (|android.content.Intent|) (typically as a result of the user 
re-launching it from home), this activity and all on top of it will be finished 
so that the user does not return to them, but instead returns to whatever 
activity preceeded it. 

This is useful for cases where you have a logical break in your application. 
For example, an e-mail application may have a command to view an attachment, 
which launches an image view activity to display it. This activity should be 
part of the e-mail application's task, since it is a part of the task the user 
is involved in. However, if the user leaves that task, and later selects the 
e-mail app from home, we may like them to return to the conversation they were 
viewing, not the picture attachment, since that is confusing. By setting this 
flag when launching the image viewer, that viewer and any activities it starts 
will be removed the next time the user returns to mail. 


*int_android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS*

If set, the new activity is not kept in the list of recently launched 
activities. 


*int_android.content.Intent.FLAG_ACTIVITY_FORWARD_RESULT*

If set and this intent is being used to launch a new activity from an existing 
one, then the reply target of the existing activity will be transfered to the 
new activity. This way the new activity can call (|android.app.Activity|) and 
have that result sent back to the reply target of the original activity. 


*int_android.content.Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY*

This flag is not normally set by application code, but set for you by the 
system if this activity is being launched from history (longpress home key). 


*int_android.content.Intent.FLAG_ACTIVITY_MULTIPLE_TASK*

Do not use this flag unless you are implementing your own top-level application 
launcher. Used in conjunction with (|android.content.Intent|) to disable the 
behavior of bringing an existing task to the foreground. When set, a new task 
is always started to host the Activity for the Intent, regardless of whether 
there is already an existing task running the same thing. 

Because the default system does not include graphical task management, you 
should not use this flag unless you provide some way for a user to return back 
to the tasks you have launched. 

This flag is ignored if (|android.content.Intent|) is not set. 

See <a href="guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and 
Back Stack for more information about tasks. 


*int_android.content.Intent.FLAG_ACTIVITY_NEW_TASK*

If set, this activity will become the start of a new task on this history 
stack. A task (from the activity that started it to the next task activity) 
defines an atomic group of activities that the user can move to. Tasks can be 
moved to the foreground and background; all of the activities inside of a 
particular task always remain in the same order. See <a 
href="guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back Stack 
for more information about tasks. 

This flag is generally used by activities that want to present a "launcher" 
style behavior: they give the user a list of separate things that can be done, 
which otherwise run completely independently of the activity launching them. 

When using this flag, if a task is already running for the activity you are now 
starting, then a new activity will not be started; instead, the current task 
will simply be brought to the front of the screen with the state it was last 
in. See (|android.content.Intent|) for a flag to disable this behavior. 

This flag can not be used when the caller is requesting a result from the 
activity being launched. 


*int_android.content.Intent.FLAG_ACTIVITY_NO_ANIMATION*

If set in an Intent passed to 
Context.startActivity()(|android.content.Context|) , this flag will prevent the 
system from applying an activity transition animation to go to the next 
activity state. This doesn't mean an animation will never run -- if another 
activity change happens that doesn't specify this flag before the activity 
started here is displayed, then that transition will be used. This flag can be 
put to good use when you are going to do a series of activity operations but 
the animation seen by the user shouldn't be driven by the first activity change 
but rather a later one. 


*int_android.content.Intent.FLAG_ACTIVITY_NO_HISTORY*

If set, the new activity is not kept in the history stack. As soon as the user 
navigates away from it, the activity is finished. This may also be set with the 
noHistory(|android.R.styleable|) attribute. 


*int_android.content.Intent.FLAG_ACTIVITY_NO_USER_ACTION*

If set, this flag will prevent the normal (|android.app.Activity|) callback 
from occurring on the current frontmost activity before it is paused as the 
newly-started activity is brought to the front. 

Typically, an activity can rely on that callback to indicate that an explicit 
user action has caused their activity to be moved out of the foreground. The 
callback marks an appropriate point in the activity's lifecycle for it to 
dismiss any notifications that it intends to display "until the user has seen 
them," such as a blinking LED. 

If an activity is ever started via any non-user-driven events such as 
phone-call receipt or an alarm handler, this flag should be passed to 
Context.startActivity(|android.content.Context|) , ensuring that the pausing 
activity does not think the user has acknowledged its notification. 


*int_android.content.Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP*

If set and this intent is being used to launch a new activity from an existing 
one, the current activity will not be counted as the top activity for deciding 
whether the new intent should be delivered to the top instead of starting a new 
one. The previous activity will be used as the top, with the assumption being 
that the current activity will finish itself immediately. 


*int_android.content.Intent.FLAG_ACTIVITY_REORDER_TO_FRONT*

If set in an Intent passed to 
Context.startActivity()(|android.content.Context|) , this flag will cause the 
launched activity to be brought to the front of its task's history stack if it 
is already running. 

For example, consider a task consisting of four activities: A, B, C, D. If D 
calls startActivity() with an Intent that resolves to the component of activity 
B, then B will be brought to the front of the history stack, with this 
resulting order: A, C, D, B. 

This flag will be ignored if (|android.content.Intent|) is also specified. 


*int_android.content.Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED*

If set, and this activity is either being started in a new task or bringing to 
the top an existing task, then it will be launched as the front door of the 
task. This will result in the application of any affinities needed to have that 
task in the proper state (either moving activities to or from it), or simply 
resetting that task to its initial state if needed. 


*int_android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP*

If set, the activity will not be launched if it is already running at the top 
of the history stack. 


*int_android.content.Intent.FLAG_ACTIVITY_TASK_ON_HOME*

If set in an Intent passed to 
Context.startActivity()(|android.content.Context|) , this flag will cause a 
newly launching task to be placed on top of the current home activity task (if 
there is one). That is, pressing back from the task will always return the user 
to home even if that was not the last activity they saw. This can only be used 
in conjunction with (|android.content.Intent|) . 


*int_android.content.Intent.FLAG_DEBUG_LOG_RESOLUTION*

A flag you can enable for debugging: when set, log messages will be printed 
during the resolution of this intent to show you what has been found to create 
the final resolved list. 


*int_android.content.Intent.FLAG_EXCLUDE_STOPPED_PACKAGES*

If set, this intent will not match any components in packages that are 
currently stopped. If this is not set, then the default behavior is to include 
such applications in the result. 


*int_android.content.Intent.FLAG_FROM_BACKGROUND*

Can be set by the caller to indicate that this Intent is coming from a 
background operation, not from direct user interaction. 


*int_android.content.Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION*

When combined with (|android.content.Intent|) and/or (|android.content.Intent|) 
, the URI permission grant can be persisted across device reboots until 
explicitly revoked with (|android.content.Context|) . This flag only offers the 
grant for possible persisting; the receiving application must call 
(|android.content.ContentResolver|) to actually persist. 


*int_android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION*

If set, the recipient of this Intent will be granted permission to perform read 
operations on the URI in the Intent's data and any URIs specified in its 
ClipData. When applying to an Intent's ClipData, all URIs as well as recursive 
traversals through data or other ClipData in Intent items will be granted; only 
the grant flags of the top-level Intent are used. 


*int_android.content.Intent.FLAG_GRANT_WRITE_URI_PERMISSION*

If set, the recipient of this Intent will be granted permission to perform 
write operations on the URI in the Intent's data and any URIs specified in its 
ClipData. When applying to an Intent's ClipData, all URIs as well as recursive 
traversals through data or other ClipData in Intent items will be granted; only 
the grant flags of the top-level Intent are used. 


*int_android.content.Intent.FLAG_INCLUDE_STOPPED_PACKAGES*

If set, this intent will always match any components in packages that are 
currently stopped. This is the default behavior when (|android.content.Intent|) 
is not set. If both of these flags are set, this one wins (it allows overriding 
of exclude for places where the framework may automatically set the exclude 
flag). 


*int_android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE*

Set when this broadcast is for a boot upgrade, a special mode that allows the 
broadcast to be sent before the system is ready and launches the app process 
with no providers running in it. 


*int_android.content.Intent.FLAG_RECEIVER_FOREGROUND*

If set, when sending a broadcast the recipient is allowed to run at foreground 
priority, with a shorter timeout interval. During normal broadcasts the 
receivers are not automatically hoisted out of the background priority class. 


*int_android.content.Intent.FLAG_RECEIVER_NO_ABORT*

If this is an ordered broadcast, don't allow receivers to abort the broadcast. 
They can still propagate results through to later receivers, but they can not 
prevent later receivers from seeing the broadcast. 


*int_android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY*

If set, when sending a broadcast only registered receivers will be called -- no 
BroadcastReceiver components will be launched. 


*int_android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT*

If set, when sending a broadcast before boot has completed only registered 
receivers will be called -- no BroadcastReceiver components will be launched. 
Sticky intent state will be recorded properly even if no receivers wind up 
being called. If (|android.content.Intent|) is specified in the broadcast 
intent, this flag is unnecessary. 

This flag is only for use by system sevices as a convenience to avoid having to 
implement a more complex mechanism around detection of boot completion. 


*int_android.content.Intent.FLAG_RECEIVER_REPLACE_PENDING*

If set, when sending a broadcast the new broadcast will replace any existing 
pending broadcast that matches it. Matching is defined by 
Intent.filterEquals(|android.content.Intent|) returning true for the intents of 
the two broadcasts. When a match is found, the new broadcast (and receivers 
associated with it) will replace the existing one in the pending broadcast 
list, remaining at the same position in the list. 

This flag is most typically used with sticky broadcasts, which only care about 
delivering the most recent values of the broadcast to their receivers. 


*int_android.content.Intent.IMMUTABLE_FLAGS*




*java.lang.String_android.content.Intent.METADATA_DOCK_HOME*

Boolean that can be supplied as meta-data with a dock activity, to indicate 
that the dock should take over the home key when it is active. 


*java.lang.String_android.content.Intent.METADATA_SETUP_VERSION*

A string associated with a (|android.content.Intent|) activity describing the 
last run version of the platform that was setup. 


*int_android.content.Intent.URI_INTENT_SCHEME*

Flag for use with (|android.content.Intent|) and (|android.content.Intent|) : 
the URI string always has the "intent:" scheme. This syntax can be used when 
you want to later disambiguate between URIs that are intended to describe an 
Intent vs. all others that should be treated as raw URIs. When used with 
(|android.content.Intent|) , any other scheme will result in a generic VIEW 
action for that raw URI. 



*android.content.Intent()*

public Intent()

Create an empty intent. 


*android.content.Intent(Context,Class<?>)*

public Intent(
  android.content.Context packageContext,
  java.lang.Class<?> cls)

Create an intent for a specific component. All other fields (action, data, 
type, class) are null, though they can be modified later with explicit calls. 
This provides a convenient way to create an intent that is intended to execute 
a hard-coded class name, rather than relying on the system to find an 
appropriate class for you; see (|android.content.Intent|) for more information 
on the repercussions of this. 

    packageContext - A Context of the application package implementing this class. 
    cls - The component class that is to be used for the intent. 

*android.content.Intent(Intent)*

public Intent(android.content.Intent o)

Copy constructor. 


*android.content.Intent(Parcel)*

protected Intent(android.os.Parcel in)




*android.content.Intent(String)*

public Intent(java.lang.String action)

Create an intent with a given action. All other fields (data, type, class) are 
null. Note that the action must be in a namespace because Intents are used 
globally in the system -- for example the system VIEW action is 
android.intent.action.VIEW; an application's custom action would be something 
like com.google.app.myapp.CUSTOM_ACTION. 

    action - The Intent action, such as ACTION_VIEW. 

*android.content.Intent(String,Uri)*

public Intent(
  java.lang.String action,
  android.net.Uri uri)

Create an intent with a given action and for a given data url. Note that the 
action must be in a namespace because Intents are used globally in the system 
-- for example the system VIEW action is android.intent.action.VIEW; an 
application's custom action would be something like 
com.google.app.myapp.CUSTOM_ACTION. 

Note: scheme and host name matching in the Android framework is case-sensitive, 
unlike the formal RFC. As a result, you should always ensure that you write 
your Uri with these elements using lower case letters, and normalize any Uris 
you receive from outside of Android to ensure the scheme and host is lower 
case. 

    action - The Intent action, such as ACTION_VIEW. 
    uri - The Intent data URI. 

*android.content.Intent(String,Uri,Context,Class<?>)*

public Intent(
  java.lang.String action,
  android.net.Uri uri,
  android.content.Context packageContext,
  java.lang.Class<?> cls)

Create an intent for a specific component with a specified action and data. 
This is equivalent using (|android.content.Intent|) to construct the Intent and 
then calling (|android.content.Intent|) to set its class. 

Note: scheme and host name matching in the Android framework is case-sensitive, 
unlike the formal RFC. As a result, you should always ensure that you write 
your Uri with these elements using lower case letters, and normalize any Uris 
you receive from outside of Android to ensure the scheme and host is lower 
case. 

    action - The Intent action, such as ACTION_VIEW. 
    uri - The Intent data URI. 
    packageContext - A Context of the application package implementing this class. 
    cls - The component class that is to be used for the intent. 

*android.content.Intent.addCategory(String)*

public |android.content.Intent| addCategory(java.lang.String category)

Add a new category to the intent. Categories provide additional detail about 
the action the intent performs. When resolving an intent, only activities that 
provide all of the requested categories will be used. 


    category - The desired category. This can be either one of the predefined Intent 
       categories, or a custom category in your own namespace. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.addFlags(int)*

public |android.content.Intent| addFlags(int flags)

Add additional flags to the intent (or with existing flags value). 


    flags - The new flags to set. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.clone()*

public |java.lang.Object| clone()





*android.content.Intent.cloneFilter()*

public |android.content.Intent| cloneFilter()

Make a clone of only the parts of the Intent that are relevant for filter 
matching: the action, data, type, component, and categories. 



*android.content.Intent.createChooser(Intent,CharSequence)*

public static |android.content.Intent| createChooser(
  android.content.Intent target,
  java.lang.CharSequence title)

Convenience function for creating a (|android.content.Intent|) Intent. 

Builds a new (|android.content.Intent|) Intent that wraps the given target 
intent, also optionally supplying a title. If the target intent has specified 
(|android.content.Intent|) or (|android.content.Intent|) , then these flags 
will also be set in the returned chooser intent, with its ClipData set 
appropriately: either a direct reflection of (|android.content.Intent|) if that 
is non-null, or a new ClipData build from (|android.content.Intent|) . 


    target - The Intent that the user will be selecting an activity to perform. 
    title - Optional title that will be displayed in the chooser. 

    Returns: Return a new Intent object that you can hand to {@link 
             Context#startActivity(Intent) Context.startActivity()} and related 
             methods. 

*android.content.Intent.describeContents()*

public int describeContents()





*android.content.Intent.fillIn(Intent,int)*

public int fillIn(
  android.content.Intent other,
  int flags)

Copy the contents of other in to this object, but only where fields are not 
defined by this object. For purposes of a field being defined, the following 
pieces of data in the Intent are considered to be separate fields: 

action, as set by (|android.content.Intent|) . data Uri and MIME type, as set 
by (|android.content.Intent|) , (|android.content.Intent|) , or 
(|android.content.Intent|) . categories, as set by (|android.content.Intent|) . 
package, as set by (|android.content.Intent|) . component, as set by 
(|android.content.Intent|) or related methods. source bounds, as set by 
(|android.content.Intent|) . selector, as set by (|android.content.Intent|) . 
clip data, as set by (|android.content.Intent|) . each top-level name in the 
associated extras. 

In addition, you can use the (|android.content.Intent|) , 
(|android.content.Intent|) , (|android.content.Intent|) , 
(|android.content.Intent|) , (|android.content.Intent|) , 
(|android.content.Intent|) , (|android.content.Intent|) , and 
(|android.content.Intent|) to override the restriction where the corresponding 
field will not be replaced if it is already set. 

Note: The component field will only be copied if (|android.content.Intent|) is 
explicitly specified. The selector will only be copied if 
(|android.content.Intent|) is explicitly specified. 

For example, consider Intent A with {data="foo", categories="bar"} and Intent B 
with {action="gotit", data-type="some/thing", categories="one","two"}. 

Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now containing: 
{action="gotit", data-type="some/thing", categories="bar"}. 


    other - Another Intent whose values are to be used to fill in the current one. 
    flags - Options to control which fields can be filled in. 

    Returns: Returns a bit mask of {@link #FILL_IN_ACTION}, {@link #FILL_IN_DATA}, {@link 
             #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE}, {@link 
             #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and {@link 
             #FILL_IN_SELECTOR} indicating which fields were changed. 

*android.content.Intent.filterEquals(Intent)*

public boolean filterEquals(android.content.Intent other)

Determine if two intents are the same for the purposes of intent resolution 
(filtering). That is, if their action, data, type, class, and categories are 
the same. This does not compare any extra data included in the intents. 


    other - The other Intent to compare against. 

    Returns: Returns true if action, data, type, class, and categories are the same. 

*android.content.Intent.filterHashCode()*

public int filterHashCode()

Generate hash code that matches semantics of filterEquals(). 



    Returns: Returns the hash value of the action, data, type, class, and categories. 

*android.content.Intent.getAction()*

public |java.lang.String| getAction()

Retrieve the general action to be performed, such as (|android.content.Intent|) 
. The action describes the general way the rest of the information in the 
intent should be interpreted -- most importantly, what to do with the data 
returned by (|android.content.Intent|) . 



    Returns: The action of this intent or null if none is specified. 

*android.content.Intent.getBooleanArrayExtra(String)*

public boolean[] getBooleanArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             boolean array value was found. 

*android.content.Intent.getBooleanExtra(String,boolean)*

public boolean getBooleanExtra(
  java.lang.String name,
  boolean defaultValue)

Retrieve extended data from the intent. 


    name - The name of the desired item. 
    defaultValue - the value to be returned if no value of the desired type is stored with the 
       given name. 

    Returns: the value of an item that previously added with putExtra() or the default value 
             if none was found. 

*android.content.Intent.getBundleExtra(String)*

public |android.os.Bundle| getBundleExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no Bundle 
             value was found. 

*android.content.Intent.getByteArrayExtra(String)*

public byte[] getByteArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no byte 
             array value was found. 

*android.content.Intent.getByteExtra(String,byte)*

public byte getByteExtra(
  java.lang.String name,
  byte defaultValue)

Retrieve extended data from the intent. 


    name - The name of the desired item. 
    defaultValue - the value to be returned if no value of the desired type is stored with the 
       given name. 

    Returns: the value of an item that previously added with putExtra() or the default value 
             if none was found. 

*android.content.Intent.getCategories()*

public |java.util.Set|<String> getCategories()

Return the set of all categories in the intent. If there are no categories, 
returns NULL. 



    Returns: The set of categories you can examine. Do not modify! 

*android.content.Intent.getCharArrayExtra(String)*

public char[] getCharArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no char 
             array value was found. 

*android.content.Intent.getCharExtra(String,char)*

public char getCharExtra(
  java.lang.String name,
  char defaultValue)

Retrieve extended data from the intent. 


    name - The name of the desired item. 
    defaultValue - the value to be returned if no value of the desired type is stored with the 
       given name. 

    Returns: the value of an item that previously added with putExtra() or the default value 
             if none was found. 

*android.content.Intent.getCharSequenceArrayExtra(String)*

public |java.lang.CharSequence|[] getCharSequenceArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             CharSequence array value was found. 

*android.content.Intent.getCharSequenceArrayListExtra(String)*

public |java.util.ArrayList|<CharSequence> getCharSequenceArrayListExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             ArrayList value was found. 

*android.content.Intent.getCharSequenceExtra(String)*

public |java.lang.CharSequence| getCharSequenceExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             CharSequence value was found. 

*android.content.Intent.getClipData()*

public |android.content.ClipData| getClipData()

Return the (|android.content.ClipData|) associated with this Intent. If there 
is none, returns null. See (|android.content.Intent|) for more information. 



*android.content.Intent.getComponent()*

public |android.content.ComponentName| getComponent()

Retrieve the concrete component associated with the intent. When receiving an 
intent, this is the component that was found to best handle it (that is, 
yourself) and will always be non-null; in all other cases it will be null 
unless explicitly set. 



    Returns: The name of the application component to handle the intent. 

*android.content.Intent.getData()*

public |android.net.Uri| getData()

Retrieve data this intent is operating on. This URI specifies the name of the 
data; often it uses the content: scheme, specifying data in a content provider. 
Other schemes may be handled by specific activities, such as http: by the web 
browser. 



    Returns: The URI of the data this intent is targeting or null. 

*android.content.Intent.getDataString()*

public |java.lang.String| getDataString()

The same as (|android.content.Intent|) , but returns the URI as an encoded 
String. 



*android.content.Intent.getDoubleArrayExtra(String)*

public double[] getDoubleArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no double 
             array value was found. 

*android.content.Intent.getDoubleExtra(String,double)*

public double getDoubleExtra(
  java.lang.String name,
  double defaultValue)

Retrieve extended data from the intent. 


    name - The name of the desired item. 
    defaultValue - the value to be returned if no value of the desired type is stored with the 
       given name. 

    Returns: the value of an item that previously added with putExtra() or the default value 
             if none was found. 

*android.content.Intent.getExtra(String)*

public |java.lang.Object| getExtra(java.lang.String name)

Retrieve extended data from the intent. 

    Deprecated

    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if none was 
             found. 

*android.content.Intent.getExtra(String,Object)*

public |java.lang.Object| getExtra(
  java.lang.String name,
  java.lang.Object defaultValue)

Retrieve extended data from the intent. 

    Deprecated

    name - The name of the desired item. 
    defaultValue - The default value to return in case no item is associated with the key 'name' 

    Returns: the value of an item that previously added with putExtra() or defaultValue if 
             none was found. 

*android.content.Intent.getExtras()*

public |android.os.Bundle| getExtras()

Retrieves a map of extended data from the intent. 



    Returns: the map of all extras previously added with putExtra(), or null if none have 
             been added. 

*android.content.Intent.getFlags()*

public int getFlags()

Retrieve any special flags associated with this intent. You will normally just 
set them with (|android.content.Intent|) and let the system take the 
appropriate action with them. 



    Returns: int The currently set flags. 

*android.content.Intent.getFloatArrayExtra(String)*

public float[] getFloatArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no float 
             array value was found. 

*android.content.Intent.getFloatExtra(String,float)*

public float getFloatExtra(
  java.lang.String name,
  float defaultValue)

Retrieve extended data from the intent. 


    name - The name of the desired item. 
    defaultValue - the value to be returned if no value of the desired type is stored with the 
       given name. 

    Returns: the value of an item that previously added with putExtra(), or the default 
             value if no such item is present 

*android.content.Intent.getIBinderExtra(String)*

public |android.os.IBinder| getIBinderExtra(java.lang.String name)

Retrieve extended data from the intent. 

    Deprecated

    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             IBinder value was found. 

*android.content.Intent.getIntArrayExtra(String)*

public int[] getIntArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no int 
             array value was found. 

*android.content.Intent.getIntegerArrayListExtra(String)*

public |java.util.ArrayList|<Integer> getIntegerArrayListExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             ArrayList value was found. 

*android.content.Intent.getIntent(String)*

public static |android.content.Intent| getIntent(java.lang.String uri)
  throws |java.net.URISyntaxException|
         
Call (|android.content.Intent|) with 0 flags. 

    Deprecated: Use {@link #parseUri} instead.


*android.content.Intent.getIntentOld(String)*

public static |android.content.Intent| getIntentOld(java.lang.String uri)
  throws |java.net.URISyntaxException|
         




*android.content.Intent.getIntExtra(String,int)*

public int getIntExtra(
  java.lang.String name,
  int defaultValue)

Retrieve extended data from the intent. 


    name - The name of the desired item. 
    defaultValue - the value to be returned if no value of the desired type is stored with the 
       given name. 

    Returns: the value of an item that previously added with putExtra() or the default value 
             if none was found. 

*android.content.Intent.getLongArrayExtra(String)*

public long[] getLongArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no long 
             array value was found. 

*android.content.Intent.getLongExtra(String,long)*

public long getLongExtra(
  java.lang.String name,
  long defaultValue)

Retrieve extended data from the intent. 


    name - The name of the desired item. 
    defaultValue - the value to be returned if no value of the desired type is stored with the 
       given name. 

    Returns: the value of an item that previously added with putExtra() or the default value 
             if none was found. 

*android.content.Intent.getPackage()*

public |java.lang.String| getPackage()

Retrieve the application package name this Intent is limited to. When resolving 
an Intent, if non-null this limits the resolution to only components in the 
given application package. 



    Returns: The name of the application package for the Intent. 

*android.content.Intent.getParcelableArrayExtra(String)*

public |android.os.Parcelable|[] getParcelableArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             Parcelable[] value was found. 

*android.content.Intent.getParcelableArrayListExtra(String)*

public |java.util.ArrayList|<T extends android.os.Parcelable> getParcelableArrayListExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             ArrayList value was found. 

*android.content.Intent.getParcelableExtra(String)*

public |T| getParcelableExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             Parcelable value was found. 

*android.content.Intent.getScheme()*

public |java.lang.String| getScheme()

Return the scheme portion of the intent's data. If the data is null or does not 
include a scheme, null is returned. Otherwise, the scheme prefix without the 
final ':' is returned, i.e. "http". 

This is the same as calling getData().getScheme() (and checking for null data). 



    Returns: The scheme of this intent. 

*android.content.Intent.getSelector()*

public |android.content.Intent| getSelector()

Return the specific selector associated with this Intent. If there is none, 
returns null. See (|android.content.Intent|) for more information. 



*android.content.Intent.getSerializableExtra(String)*

public |java.io.Serializable| getSerializableExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             Serializable value was found. 

*android.content.Intent.getShortArrayExtra(String)*

public short[] getShortArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no short 
             array value was found. 

*android.content.Intent.getShortExtra(String,short)*

public short getShortExtra(
  java.lang.String name,
  short defaultValue)

Retrieve extended data from the intent. 


    name - The name of the desired item. 
    defaultValue - the value to be returned if no value of the desired type is stored with the 
       given name. 

    Returns: the value of an item that previously added with putExtra() or the default value 
             if none was found. 

*android.content.Intent.getSourceBounds()*

public Rect getSourceBounds()

Get the bounds of the sender of this intent, in screen coordinates. This can be 
used as a hint to the receiver for animations and the like. Null means that 
there is no source bounds. 



*android.content.Intent.getStringArrayExtra(String)*

public |java.lang.String|[] getStringArrayExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no String 
             array value was found. 

*android.content.Intent.getStringArrayListExtra(String)*

public |java.util.ArrayList|<String> getStringArrayListExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no 
             ArrayList value was found. 

*android.content.Intent.getStringExtra(String)*

public |java.lang.String| getStringExtra(java.lang.String name)

Retrieve extended data from the intent. 


    name - The name of the desired item. 

    Returns: the value of an item that previously added with putExtra() or null if no String 
             value was found. 

*android.content.Intent.getType()*

public |java.lang.String| getType()

Retrieve any explicit MIME type included in the intent. This is usually null, 
as the type is determined by the intent data. 



    Returns: If a type was manually set, it is returned; else null is returned. 

*android.content.Intent.hasCategory(String)*

public boolean hasCategory(java.lang.String category)

Check if a category exists in the intent. 


    category - The category to check. 

    Returns: boolean True if the intent contains the category, else false. 

*android.content.Intent.hasExtra(String)*

public boolean hasExtra(java.lang.String name)

Returns true if an extra value is associated with the given name. 


    name - the extra's name 

    Returns: true if the given extra is present. 

*android.content.Intent.hasFileDescriptors()*

public boolean hasFileDescriptors()

Returns true if the Intent's extras contain a parcelled file descriptor. 



    Returns: true if the Intent contains a parcelled file descriptor. 

*android.content.Intent.isExcludingStopped()*

public boolean isExcludingStopped()





*android.content.Intent.makeMainActivity(ComponentName)*

public static |android.content.Intent| makeMainActivity(android.content.ComponentName mainActivity)

Create an intent to launch the main (root) activity of a task. This is the 
Intent that is started when the application's is launched from Home. For 
anything else that wants to launch an application in the same way, it is 
important that they use an Intent structured the same way, and can use this 
function to ensure this is the case. 

The returned Intent has the given Activity component as its explicit component, 
(|android.content.Intent|) as its action, and includes the category 
(|android.content.Intent|) . This does not have (|android.content.Intent|) set, 
though typically you will want to do that through (|android.content.Intent|) on 
the returned Intent. 


    mainActivity - The main activity component that this Intent will launch. 

    Returns: Returns a newly created Intent that can be used to launch the activity as a 
             main application entry. 

*android.content.Intent.makeMainSelectorActivity(String,String)*

public static |android.content.Intent| makeMainSelectorActivity(
  java.lang.String selectorAction,
  java.lang.String selectorCategory)

Make an Intent for the main activity of an application, without specifying a 
specific activity to run but giving a selector to find the activity. This 
results in a final Intent that is structured the same as when the application 
is launched from Home. For anything else that wants to launch an application in 
the same way, it is important that they use an Intent structured the same way, 
and can use this function to ensure this is the case. 

The returned Intent has (|android.content.Intent|) as its action, and includes 
the category (|android.content.Intent|) . This does not have 
(|android.content.Intent|) set, though typically you will want to do that 
through (|android.content.Intent|) on the returned Intent. 


    selectorAction - The action name of the Intent's selector. 
    selectorCategory - The name of a category to add to the Intent's selector. 

    Returns: Returns a newly created Intent that can be used to launch the activity as a 
             main application entry. 

*android.content.Intent.makeRestartActivityTask(ComponentName)*

public static |android.content.Intent| makeRestartActivityTask(android.content.ComponentName mainActivity)

Make an Intent that can be used to re-launch an application's task in its base 
state. This is like (|android.content.Intent|) , but also sets the flags 
(|android.content.Intent|) and (|android.content.Intent|) . 


    mainActivity - The activity component that is the root of the task; this is the activity that 
       has been published in the application's manifest as the main launcher 
       icon. 

    Returns: Returns a newly created Intent that can be used to relaunch the activity's task 
             in its root state. 

*android.content.Intent.migrateExtraStreamToClipData()*

public boolean migrateExtraStreamToClipData()

Migrate any (|android.content.Intent|) in (|android.content.Intent|) and 
(|android.content.Intent|) to (|android.content.ClipData|) . Also inspects 
nested intents in (|android.content.Intent|) . 



    Returns: Whether any contents were migrated. 

*android.content.Intent.normalizeMimeType(String)*

public static |java.lang.String| normalizeMimeType(java.lang.String type)

Normalize a MIME data type. 

A normalized MIME type has white-space trimmed, content-type parameters 
removed, and is lower-case. This aligns the type with Android best practices 
for intent filtering. 

For example, "text/plain; charset=utf-8" becomes "text/plain". "text/x-vCard" 
becomes "text/x-vcard". 

All MIME types received from outside Android (such as user input, or external 
sources like Bluetooth, NFC, or the Internet) should be normalized before they 
are used to create an Intent. 


    type - MIME data type to normalize 

    Returns: normalized MIME data type, or null if the input was null 

*android.content.Intent.parseIntent(Resources,XmlPullParser,AttributeSet)*

public static |android.content.Intent| parseIntent(
  android.content.res.Resources resources,
  XmlPullParser parser,
  android.util.AttributeSet attrs)
  throws |java.io.IOException|
         |XmlPullParserException|
         
Parses the "intent" element (and its children) from XML and instantiates an 
Intent object. The given XML parser should be located at the tag where parsing 
should start (often named "intent"), from which the basic action, data, type, 
and package and class name will be retrieved. The function will then parse in 
to any child elements, looking for tags to add categories and to attach extra 
data to the intent. 


    resources - The Resources to use when inflating resources. 
    parser - The XML parser pointing at an "intent" tag. 
    attrs - The AttributeSet interface for retrieving extended attribute data at the 
       current parser location. 

    Returns: An Intent object matching the XML data. 

*android.content.Intent.parseUri(String,int)*

public static |android.content.Intent| parseUri(
  java.lang.String uri,
  int flags)
  throws |java.net.URISyntaxException|
         
Create an intent from a URI. This URI may encode the action, category, and 
other intent fields, if it was returned by (|android.content.Intent|) . If the 
Intent was not generate by toUri(), its data will be the entire URI and its 
action will be ACTION_VIEW. 

The URI given here must not be relative -- that is, it must include the scheme 
and full path. 


    uri - The URI to turn into an Intent. 
    flags - Additional processing flags. Either 0 or {@link #URI_INTENT_SCHEME}. 

    Returns: Intent The newly created Intent object. 

*android.content.Intent.prepareToLeaveProcess()*

public void prepareToLeaveProcess()

Prepare this (|android.content.Intent|) to leave an app process. 



*android.content.Intent.putCharSequenceArrayListExtra(String,ArrayList<CharSequence>)*

public |android.content.Intent| putCharSequenceArrayListExtra(
  java.lang.String name,
  java.util.ArrayList<java.lang.CharSequence> value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The ArrayList data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,boolean)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  boolean value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The boolean data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,boolean[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  boolean[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The boolean array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,Bundle)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  android.os.Bundle value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The Bundle data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,byte)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  byte value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The byte data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,byte[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  byte[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The byte array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,char)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  char value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The char data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,char[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  char[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The char array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,CharSequence)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  java.lang.CharSequence value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The CharSequence data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,CharSequence[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  java.lang.CharSequence[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The CharSequence array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,double)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  double value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The double data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,double[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  double[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The double array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,float)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  float value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The float data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,float[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  float[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The float array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,IBinder)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  android.os.IBinder value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 

    Deprecated

    name - The name of the extra data, with package prefix. 
    value - The IBinder data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,int)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  int value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The integer data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,int[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  int[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The int array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,long)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  long value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The long data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,long[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  long[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The byte array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,Parcelable)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  android.os.Parcelable value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The Parcelable data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,Parcelable[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  android.os.Parcelable[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The Parcelable[] data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,Serializable)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  java.io.Serializable value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The Serializable data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,short)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  short value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The short data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,short[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  short[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The short array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,String)*

public |android.content.Intent| putExtra(
  java.lang.String name,
  java.lang.String value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The String data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtra(String,String[])*

public |android.content.Intent| putExtra(
  java.lang.String name,
  java.lang.String[] value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The String array data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putExtras(Bundle)*

public |android.content.Intent| putExtras(android.os.Bundle extras)

Add a set of extended data to the intent. The keys must include a package 
prefix, for example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    extras - The Bundle of extras to add to this intent. 

*android.content.Intent.putExtras(Intent)*

public |android.content.Intent| putExtras(android.content.Intent src)

Copy all extras in 'src' in to this intent. 


    src - Contains the extras to copy. 

*android.content.Intent.putIntegerArrayListExtra(String,ArrayList<Integer>)*

public |android.content.Intent| putIntegerArrayListExtra(
  java.lang.String name,
  java.util.ArrayList<java.lang.Integer> value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The ArrayList data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putParcelableArrayListExtra(String,ArrayList<?extendsParcelable>)*

public |android.content.Intent| putParcelableArrayListExtra(
  java.lang.String name,
  java.util.ArrayList<? extends android.os.Parcelable> value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The ArrayList data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.putStringArrayListExtra(String,ArrayList<String>)*

public |android.content.Intent| putStringArrayListExtra(
  java.lang.String name,
  java.util.ArrayList<java.lang.String> value)

Add extended data to the intent. The name must include a package prefix, for 
example the app com.android.contacts would use names like 
"com.android.contacts.ShowAll". 


    name - The name of the extra data, with package prefix. 
    value - The ArrayList data value. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.readFromParcel(Parcel)*

public void readFromParcel(android.os.Parcel in)





*android.content.Intent.removeCategory(String)*

public void removeCategory(java.lang.String category)

Remove a category from an intent. 


    category - The category to remove. 

*android.content.Intent.removeExtra(String)*

public void removeExtra(java.lang.String name)

Remove extended data from the intent. 



*android.content.Intent.replaceExtras(Bundle)*

public |android.content.Intent| replaceExtras(android.os.Bundle extras)

Completely replace the extras in the Intent with the given Bundle of extras. 


    extras - The new set of extras in the Intent, or null to erase all extras. 

*android.content.Intent.replaceExtras(Intent)*

public |android.content.Intent| replaceExtras(android.content.Intent src)

Completely replace the extras in the Intent with the extras in the given 
Intent. 


    src - The exact extras contained in this Intent are copied into the target intent, 
       replacing any that were previously there. 

*android.content.Intent.resolveActivity(PackageManager)*

public |android.content.ComponentName| resolveActivity(android.content.pm.PackageManager pm)

Return the Activity component that should be used to handle this intent. The 
appropriate component is determined based on the information in the intent, 
evaluated as follows: 

If (|android.content.Intent|) returns an explicit class, that is returned 
without any further consideration. 

The activity must handle the (|android.content.Intent|) Intent category to be 
considered. 

If (|android.content.Intent|) is non-NULL, the activity must handle this 
action. 

If (|android.content.Intent|) returns non-NULL, the activity must handle this 
type. 

If (|android.content.Intent|) has added any categories, the activity must 
handle ALL of the categories specified. 

If (|android.content.Intent|) is non-NULL, only activity components in that 
application package will be considered. 

If there are no activities that satisfy all of these conditions, a null string 
is returned. 

If multiple activities are found to satisfy the intent, the one with the 
highest priority will be used. If there are multiple activities with the same 
priority, the system will either pick the best activity based on user 
preference, or resolve to a system class that will allow the user to pick an 
activity and forward from there. 

This method is implemented simply by calling 
(|android.content.pm.PackageManager|) with the "defaultOnly" parameter true. 
This API is called for you as part of starting an activity from an intent. You 
do not normally need to call it yourself. 


    pm - The package manager with which to resolve the Intent. 

    Returns: Name of the component implementing an activity that can display the intent. 

*android.content.Intent.resolveActivityInfo(PackageManager,int)*

public |android.content.pm.ActivityInfo| resolveActivityInfo(
  android.content.pm.PackageManager pm,
  int flags)

Resolve the Intent into an (|android.content.pm.ActivityInfo|) describing the 
activity that should execute the intent. Resolution follows the same rules as 
described for (|android.content.Intent|) , but you get back the completely 
information about the resolved activity instead of just its class name. 


    pm - The package manager with which to resolve the Intent. 
    flags - Addition information to retrieve as per {@link 
       PackageManager#getActivityInfo(ComponentName, int) 
       PackageManager.getActivityInfo()}. 

    Returns: PackageManager.ActivityInfo 

*android.content.Intent.resolveSystemService(PackageManager,int)*

public |android.content.ComponentName| resolveSystemService(
  android.content.pm.PackageManager pm,
  int flags)

Special function for use by the system to resolve service intents to system 
apps. Throws an exception if there are multiple potential matches to the 
Intent. Returns null if there are no matches. 



*android.content.Intent.resolveType(ContentResolver)*

public |java.lang.String| resolveType(android.content.ContentResolver resolver)

Return the MIME data type of this intent. If the type field is explicitly set, 
that is simply returned. Otherwise, if the data is set, the type of that data 
is returned. If neither fields are set, a null is returned. 


    resolver - A ContentResolver that can be used to determine the MIME type of the intent's 
       data. 

    Returns: The MIME type of this intent. 

*android.content.Intent.resolveType(Context)*

public |java.lang.String| resolveType(android.content.Context context)

Return the MIME data type of this intent. If the type field is explicitly set, 
that is simply returned. Otherwise, if the data is set, the type of that data 
is returned. If neither fields are set, a null is returned. 



    Returns: The MIME type of this intent. 

*android.content.Intent.resolveTypeIfNeeded(ContentResolver)*

public |java.lang.String| resolveTypeIfNeeded(android.content.ContentResolver resolver)

Return the MIME data type of this intent, only if it will be needed for intent 
resolution. This is not generally useful for application code; it is used by 
the frameworks for communicating with back-end system services. 


    resolver - A ContentResolver that can be used to determine the MIME type of the intent's 
       data. 

    Returns: The MIME type of this intent, or null if it is unknown or not needed. 

*android.content.Intent.setAction(String)*

public |android.content.Intent| setAction(java.lang.String action)

Set the general action to be performed. 


    action - An action name, such as ACTION_VIEW. Application-specific actions should be 
       prefixed with the vendor's package name. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setAllowFds(boolean)*

public void setAllowFds(boolean allowFds)





*android.content.Intent.setClass(Context,Class<?>)*

public |android.content.Intent| setClass(
  android.content.Context packageContext,
  java.lang.Class<?> cls)

Convenience for calling (|android.content.Intent|) with the name returned by a 
(|java.lang.Class|) object. 


    packageContext - A Context of the application package implementing this class. 
    cls - The class name to set, equivalent to setClassName(context, cls.getName()). 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setClassName(Context,String)*

public |android.content.Intent| setClassName(
  android.content.Context packageContext,
  java.lang.String className)

Convenience for calling (|android.content.Intent|) with an explicit class name. 


    packageContext - A Context of the application package implementing this class. 
    className - The name of a class inside of the application package that will be used as the 
       component for this Intent. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setClassName(String,String)*

public |android.content.Intent| setClassName(
  java.lang.String packageName,
  java.lang.String className)

Convenience for calling (|android.content.Intent|) with an explicit application 
package name and class name. 


    packageName - The name of the package implementing the desired component. 
    className - The name of a class inside of the application package that will be used as the 
       component for this Intent. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setClipData(ClipData)*

public void setClipData(android.content.ClipData clip)

Set a (|android.content.ClipData|) associated with this Intent. This replaces 
any previously set ClipData. 

The ClipData in an intent is not used for Intent matching or other such 
operations. Semantically it is like extras, used to transmit additional data 
with the Intent. The main feature of using this over the extras for data is 
that (|android.content.Intent|) and (|android.content.Intent|) will operate on 
any URI items included in the clip data. This is useful, in particular, if you 
want to transmit an Intent containing multiple content: URIs for which the 
recipient may not have global permission to access the content provider. 

If the ClipData contains items that are themselves Intents, any grant flags in 
those Intents will be ignored. Only the top-level flags of the main Intent are 
respected, and will be applied to all Uri or Intent items in the clip (or 
sub-items of the clip). 

The MIME type, label, and icon in the ClipData object are not directly used by 
Intent. Applications should generally rely on the MIME type of the Intent 
itself, not what it may find in the ClipData. A common practice is to construct 
a ClipData for use with an Intent with a MIME type of "*\/*". 


    clip - The new clip to set. May be null to clear the current clip. 

*android.content.Intent.setComponent(ComponentName)*

public |android.content.Intent| setComponent(android.content.ComponentName component)

(Usually optional) Explicitly set the component to handle the intent. If left 
with the default value of null, the system will determine the appropriate class 
to use based on the other fields (action, data, type, categories) in the 
Intent. If this class is defined, the specified class will always be used 
regardless of the other fields. You should only set this value when you know 
you absolutely want a specific class to be used; otherwise it is better to let 
the system find the appropriate class so that you will respect the installed 
applications and user preferences. 


    component - The name of the application component to handle the intent, or null to let the 
       system find one for you. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setData(Uri)*

public |android.content.Intent| setData(android.net.Uri data)

Set the data this intent is operating on. This method automatically clears any 
type that was previously set by (|android.content.Intent|) or 
(|android.content.Intent|) . 

Note: scheme matching in the Android framework is case-sensitive, unlike the 
formal RFC. As a result, you should always write your Uri with a lower case 
scheme, or use (|android.net.Uri|) or (|android.content.Intent|) to ensure that 
the scheme is converted to lower case. 


    data - The Uri of the data this intent is now targeting. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setDataAndNormalize(Uri)*

public |android.content.Intent| setDataAndNormalize(android.net.Uri data)

Normalize and set the data this intent is operating on. 

This method automatically clears any type that was previously set (for example, 
by (|android.content.Intent|) ). 

The data Uri is normalized using (|android.net.Uri|) before it is set, so 
really this is just a convenience method for 

setData(data.normalize()) 


    data - The Uri of the data this intent is now targeting. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setDataAndType(Uri,String)*

public |android.content.Intent| setDataAndType(
  android.net.Uri data,
  java.lang.String type)

(Usually optional) Set the data for the intent along with an explicit MIME data 
type. This method should very rarely be used -- it allows you to override the 
MIME type that would ordinarily be inferred from the data with your own type 
given here. 

Note: MIME type and Uri scheme matching in the Android framework is 
case-sensitive, unlike the formal RFC definitions. As a result, you should 
always write these elements with lower case letters, or use 
(|android.content.Intent|) or (|android.net.Uri|) or (|android.content.Intent|) 
to ensure that they are converted to lower case. 


    data - The Uri of the data this intent is now targeting. 
    type - The MIME type of the data being handled by this intent. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setDataAndTypeAndNormalize(Uri,String)*

public |android.content.Intent| setDataAndTypeAndNormalize(
  android.net.Uri data,
  java.lang.String type)

(Usually optional) Normalize and set both the data Uri and an explicit MIME 
data type. This method should very rarely be used -- it allows you to override 
the MIME type that would ordinarily be inferred from the data with your own 
type given here. 

The data Uri and the MIME type are normalize using (|android.net.Uri|) and 
(|android.content.Intent|) before they are set, so really this is just a 
convenience method for 

setDataAndType(data.normalize(), Intent.normalizeMimeType(type)) 


    data - The Uri of the data this intent is now targeting. 
    type - The MIME type of the data being handled by this intent. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setExtrasClassLoader(ClassLoader)*

public void setExtrasClassLoader(java.lang.ClassLoader loader)

Sets the ClassLoader that will be used when unmarshalling any Parcelable values 
from the extras of this Intent. 


    loader - a ClassLoader, or null to use the default loader at the time of unmarshalling. 

*android.content.Intent.setFlags(int)*

public |android.content.Intent| setFlags(int flags)

Set special flags controlling how this intent is handled. Most values here 
depend on the type of component being executed by the Intent, specifically the 
FLAG_ACTIVITY_* flags are all for use with 
Context.startActivity()(|android.content.Context|) and the FLAG_RECEIVER_* 
flags are all for use with Context.sendBroadcast()(|android.content.Context|) . 

See the <a href="guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and 
Back Stack documentation for important information on how some of these options 
impact the behavior of your application. 


    flags - The desired flags. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setPackage(String)*

public |android.content.Intent| setPackage(java.lang.String packageName)

(Usually optional) Set an explicit application package name that limits the 
components this Intent will resolve to. If left to the default value of null, 
all components in all applications will considered. If non-null, the Intent can 
only match the components in the given application package. 


    packageName - The name of the application package to handle the intent, or null to allow any 
       application package. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setSelector(Intent)*

public void setSelector(android.content.Intent selector)

Set a selector for this Intent. This is a modification to the kinds of things 
the Intent will match. If the selector is set, it will be used when trying to 
find entities that can handle the Intent, instead of the main contents of the 
Intent. This allows you build an Intent containing a generic protocol while 
targeting it more specifically. 

An example of where this may be used is with things like 
(|android.content.Intent|) . This category allows you to build an Intent that 
will launch the Browser application. However, the correct main entry point of 
an application is actually (|android.content.Intent|) 
(|android.content.Intent|) with (|android.content.Intent|) used to specify the 
actual Activity to launch. If you launch the browser with something different, 
undesired behavior may happen if the user has previously or later launches it 
the normal way, since they do not match. Instead, you can build an Intent with 
the MAIN action (but no ComponentName yet specified) and set a selector with 
(|android.content.Intent|) and (|android.content.Intent|) to point it 
specifically to the browser activity. 

Setting a selector does not impact the behavior of (|android.content.Intent|) 
and (|android.content.Intent|) . This is part of the desired behavior of a 
selector -- it does not impact the base meaning of the Intent, just what kinds 
of things will be matched against it when determining who can handle it. 

You can not use both a selector and (|android.content.Intent|) on the same base 
Intent. 


    selector - The desired selector Intent; set to null to not use a special selector. 

*android.content.Intent.setSourceBounds(Rect)*

public void setSourceBounds(Rect r)

Set the bounds of the sender of this intent, in screen coordinates. This can be 
used as a hint to the receiver for animations and the like. Null means that 
there is no source bounds. 



*android.content.Intent.setType(String)*

public |android.content.Intent| setType(java.lang.String type)

Set an explicit MIME data type. 

This is used to create intents that only specify a type and not data, for 
example to indicate the type of data to return. 

This method automatically clears any data that was previously set (for example 
by (|android.content.Intent|) ). 

Note: MIME type matching in the Android framework is case-sensitive, unlike 
formal RFC MIME types. As a result, you should always write your MIME types 
with lower case letters, or use (|android.content.Intent|) or 
(|android.content.Intent|) to ensure that it is converted to lower case. 


    type - The MIME type of the data being handled by this intent. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.setTypeAndNormalize(String)*

public |android.content.Intent| setTypeAndNormalize(java.lang.String type)

Normalize and set an explicit MIME data type. 

This is used to create intents that only specify a type and not data, for 
example to indicate the type of data to return. 

This method automatically clears any data that was previously set (for example 
by (|android.content.Intent|) ). 

The MIME type is normalized using (|android.content.Intent|) before it is set, 
so really this is just a convenience method for 

setType(Intent.normalizeMimeType(type)) 


    type - The MIME type of the data being handled by this intent. 

    Returns: Returns the same Intent object, for chaining multiple calls into a single 
             statement. 

*android.content.Intent.toInsecureString()*

public |java.lang.String| toInsecureString()





*android.content.Intent.toInsecureStringWithClip()*

public |java.lang.String| toInsecureStringWithClip()





*android.content.Intent.toShortString(boolean,boolean,boolean,boolean)*

public |java.lang.String| toShortString(
  boolean secure,
  boolean comp,
  boolean extras,
  boolean clip)





*android.content.Intent.toShortString(StringBuilder,boolean,boolean,boolean,boolean)*

public void toShortString(
  java.lang.StringBuilder b,
  boolean secure,
  boolean comp,
  boolean extras,
  boolean clip)





*android.content.Intent.toString()*

public |java.lang.String| toString()





*android.content.Intent.toURI()*

public |java.lang.String| toURI()

Call (|android.content.Intent|) with 0 flags. 

    Deprecated: Use {@link #toUri} instead.


*android.content.Intent.toUri(int)*

public |java.lang.String| toUri(int flags)

Convert this Intent into a String holding a URI representation of it. The 
returned URI string has been properly URI encoded, so it can be used with 
Uri.parse(String)(|android.net.Uri|) . The URI contains the Intent's data as 
the base URI, with an additional fragment describing the action, categories, 
type, flags, package, component, and extras. 

You can convert the returned string back to an Intent with 
(|android.content.Intent|) . 


    flags - Additional operating flags. Either 0 or {@link #URI_INTENT_SCHEME}. 

    Returns: Returns a URI encoding URI string describing the entire contents of the Intent. 

*android.content.Intent.writeToParcel(Parcel,int)*

public void writeToParcel(
  android.os.Parcel out,
  int flags)






