*android.net.ConnectivityManager* *ConnectivityManager* Class that answers queri

public class ConnectivityManager
  extends    |java.lang.Object|

|android.net.ConnectivityManager_Description|
|android.net.ConnectivityManager_Fields|
|android.net.ConnectivityManager_Constructors|
|android.net.ConnectivityManager_Methods|

================================================================================

*android.net.ConnectivityManager_Fields*
|java.lang.String_android.net.ConnectivityManager.ACTION_BACKGROUND_DATA_SETTING_CHANGED|
|java.lang.String_android.net.ConnectivityManager.ACTION_CAPTIVE_PORTAL_TEST_COMPLETED|
|java.lang.String_android.net.ConnectivityManager.ACTION_DATA_ACTIVITY_CHANGE|
|java.lang.String_android.net.ConnectivityManager.ACTION_TETHER_STATE_CHANGED|
|java.lang.String_android.net.ConnectivityManager.CONNECTIVITY_ACTION|
|java.lang.String_android.net.ConnectivityManager.CONNECTIVITY_ACTION_IMMEDIATE|
|int_android.net.ConnectivityManager.CONNECTIVITY_CHANGE_DELAY_DEFAULT|
|int_android.net.ConnectivityManager.DEFAULT_NETWORK_PREFERENCE|
|java.lang.String_android.net.ConnectivityManager.EXTRA_ACTIVE_TETHER|
|java.lang.String_android.net.ConnectivityManager.EXTRA_AVAILABLE_TETHER|
|java.lang.String_android.net.ConnectivityManager.EXTRA_DEVICE_TYPE|
|java.lang.String_android.net.ConnectivityManager.EXTRA_ERRORED_TETHER|
|java.lang.String_android.net.ConnectivityManager.EXTRA_EXTRA_INFO|
|java.lang.String_android.net.ConnectivityManager.EXTRA_INET_CONDITION|
|java.lang.String_android.net.ConnectivityManager.EXTRA_IS_ACTIVE|
|java.lang.String_android.net.ConnectivityManager.EXTRA_IS_CAPTIVE_PORTAL|
|java.lang.String_android.net.ConnectivityManager.EXTRA_IS_FAILOVER|
|java.lang.String_android.net.ConnectivityManager.EXTRA_NETWORK_INFO|
|java.lang.String_android.net.ConnectivityManager.EXTRA_NETWORK_TYPE|
|java.lang.String_android.net.ConnectivityManager.EXTRA_NO_CONNECTIVITY|
|java.lang.String_android.net.ConnectivityManager.EXTRA_OTHER_NETWORK_INFO|
|java.lang.String_android.net.ConnectivityManager.EXTRA_REASON|
|java.lang.String_android.net.ConnectivityManager.INET_CONDITION_ACTION|
|int_android.net.ConnectivityManager.MAX_NETWORK_TYPE|
|int_android.net.ConnectivityManager.MAX_RADIO_TYPE|
|int_android.net.ConnectivityManager.TETHER_ERROR_DISABLE_NAT_ERROR|
|int_android.net.ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR|
|int_android.net.ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR|
|int_android.net.ConnectivityManager.TETHER_ERROR_MASTER_ERROR|
|int_android.net.ConnectivityManager.TETHER_ERROR_NO_ERROR|
|int_android.net.ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL|
|int_android.net.ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR|
|int_android.net.ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE|
|int_android.net.ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE|
|int_android.net.ConnectivityManager.TETHER_ERROR_UNSUPPORTED|
|int_android.net.ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR|
|int_android.net.ConnectivityManager.TYPE_BLUETOOTH|
|int_android.net.ConnectivityManager.TYPE_DUMMY|
|int_android.net.ConnectivityManager.TYPE_ETHERNET|
|int_android.net.ConnectivityManager.TYPE_MOBILE|
|int_android.net.ConnectivityManager.TYPE_MOBILE_CBS|
|int_android.net.ConnectivityManager.TYPE_MOBILE_DUN|
|int_android.net.ConnectivityManager.TYPE_MOBILE_FOTA|
|int_android.net.ConnectivityManager.TYPE_MOBILE_HIPRI|
|int_android.net.ConnectivityManager.TYPE_MOBILE_IA|
|int_android.net.ConnectivityManager.TYPE_MOBILE_IMS|
|int_android.net.ConnectivityManager.TYPE_MOBILE_MMS|
|int_android.net.ConnectivityManager.TYPE_MOBILE_SUPL|
|int_android.net.ConnectivityManager.TYPE_NONE|
|int_android.net.ConnectivityManager.TYPE_WIFI|
|int_android.net.ConnectivityManager.TYPE_WIFI_P2P|
|int_android.net.ConnectivityManager.TYPE_WIMAX|

*android.net.ConnectivityManager_Constructors*
|android.net.ConnectivityManager(IConnectivityManager)|

*android.net.ConnectivityManager_Methods*
|android.net.ConnectivityManager.captivePortalCheckComplete(NetworkInfo)|Signal
|android.net.ConnectivityManager.captivePortalCheckCompleted(NetworkInfo,boolean)|
|android.net.ConnectivityManager.checkMobileProvisioning(int)|Check mobile prov
|android.net.ConnectivityManager.from(Context)|
|android.net.ConnectivityManager.getActiveLinkProperties()|Returns the IP infor
|android.net.ConnectivityManager.getActiveLinkQualityInfo()|get the information
|android.net.ConnectivityManager.getActiveNetworkInfo()|Returns details about t
|android.net.ConnectivityManager.getActiveNetworkInfoForUid(int)|Returns detail
|android.net.ConnectivityManager.getActiveNetworkQuotaInfo()|Return quota statu
|android.net.ConnectivityManager.getAllLinkQualityInfo()|get the information of
|android.net.ConnectivityManager.getAllNetworkInfo()|Returns connection status 
|android.net.ConnectivityManager.getBackgroundDataSetting()|Returns the value o
|android.net.ConnectivityManager.getGlobalProxy()|Retrieve any network-independ
|android.net.ConnectivityManager.getLastTetherError(String)|Get a more detailed
|android.net.ConnectivityManager.getLinkProperties(int)|Returns the IP informat
|android.net.ConnectivityManager.getLinkQualityInfo(int)|get the information ab
|android.net.ConnectivityManager.getMobileDataEnabled()|Gets the value of the s
|android.net.ConnectivityManager.getMobileProvisioningUrl()|Get the mobile prov
|android.net.ConnectivityManager.getMobileRedirectedProvisioningUrl()|Get the m
|android.net.ConnectivityManager.getNetworkInfo(int)|Returns connection status 
|android.net.ConnectivityManager.getNetworkPreference()|Retrieves the current p
|android.net.ConnectivityManager.getNetworkTypeName(int)|Returns a non-localize
|android.net.ConnectivityManager.getProvisioningOrActiveNetworkInfo()|Returns d
|android.net.ConnectivityManager.getProxy()|Get the HTTP proxy settings for the
|android.net.ConnectivityManager.getTetherableBluetoothRegexs()|Get the list of
|android.net.ConnectivityManager.getTetherableIfaces()|Get the set of tetherabl
|android.net.ConnectivityManager.getTetherableUsbRegexs()|Get the list of regul
|android.net.ConnectivityManager.getTetherableWifiRegexs()|Get the list of regu
|android.net.ConnectivityManager.getTetheredIfaces()|Get the set of tethered in
|android.net.ConnectivityManager.getTetheringErroredIfaces()|Get the set of int
|android.net.ConnectivityManager.isActiveNetworkMetered()|Returns if the curren
|android.net.ConnectivityManager.isNetworkSupported(int)|Returns true if the ha
|android.net.ConnectivityManager.isNetworkTypeExempt(int)|Checks if the given n
|android.net.ConnectivityManager.isNetworkTypeMobile(int)|Checks if a given typ
|android.net.ConnectivityManager.isNetworkTypeValid(int)|Tests if a given integ
|android.net.ConnectivityManager.isNetworkTypeWifi(int)|Checks if the given net
|android.net.ConnectivityManager.isTetheringSupported()|Check if the device all
|android.net.ConnectivityManager.reportInetCondition(int,int)|Report network co
|android.net.ConnectivityManager.requestNetworkTransitionWakelock(String)|Try t
|android.net.ConnectivityManager.requestRouteToHost(int,int)|Ensure that a netw
|android.net.ConnectivityManager.requestRouteToHostAddress(int,InetAddress)|Ens
|android.net.ConnectivityManager.setAirplaneMode(boolean)|Set the value for ena
|android.net.ConnectivityManager.setBackgroundDataSetting(boolean)|Sets the val
|android.net.ConnectivityManager.setDataDependency(int,boolean)|Sets a secondar
|android.net.ConnectivityManager.setGlobalProxy(ProxyProperties)|Set a network-
|android.net.ConnectivityManager.setMobileDataEnabled(boolean)|Sets the persist
|android.net.ConnectivityManager.setNetworkPreference(int)|Specifies the prefer
|android.net.ConnectivityManager.setProvisioningNotificationVisible(boolean,int,String,String)|
|android.net.ConnectivityManager.setRadio(int,boolean)|Tells a given networkTyp
|android.net.ConnectivityManager.setRadios(boolean)|Tells each network type to 
|android.net.ConnectivityManager.setUsbTethering(boolean)|Attempt to both alter
|android.net.ConnectivityManager.startUsingNetworkFeature(int,String)|Tells the
|android.net.ConnectivityManager.stopUsingNetworkFeature(int,String)|Tells the 
|android.net.ConnectivityManager.supplyMessenger(int,Messenger)|Supply the back
|android.net.ConnectivityManager.tether(String)|Attempt to tether the named int
|android.net.ConnectivityManager.untether(String)|Stop tethering the named inte
|android.net.ConnectivityManager.updateLockdownVpn()|If the LockdownVpn mechani

*android.net.ConnectivityManager_Description*

Class that answers queries about the state of network connectivity. It also 
notifies applications when network connectivity changes. Get an instance of 
this class by calling 
Context.getSystemService(Context.CONNECTIVITY_SERVICE)(|android.content.Context|)
. 

The primary responsibilities of this class are to: 

Monitor network connections (Wi-Fi, GPRS, UMTS, etc.) Send broadcast intents 
when network connectivity changes Attempt to "fail over" to another network 
when connectivity to a network is lost Provide an API that allows applications 
to query the coarse-grained or fine-grained state of the available networks 



*java.lang.String_android.net.ConnectivityManager.ACTION_BACKGROUND_DATA_SETTING_CHANGED*

Broadcast Action: The setting for background data usage has changed values. Use 
(|android.net.ConnectivityManager|) to get the current value. 

If an application uses the network in the background, it should listen for this 
broadcast and stop using the background data if the value isfalse. 


*java.lang.String_android.net.ConnectivityManager.ACTION_CAPTIVE_PORTAL_TEST_COMPLETED*

Broadcast Action: The captive portal tracker has finished its test. Sent only 
while running Setup Wizard, in lieu of showing a user notification. 


*java.lang.String_android.net.ConnectivityManager.ACTION_DATA_ACTIVITY_CHANGE*

Broadcast action to indicate the change of data activity status (idle or 
active) on a network in a recent period. The network becomes active when data 
transmission is started, or idle if there is no data transmission for a period 
of time. 


*java.lang.String_android.net.ConnectivityManager.ACTION_TETHER_STATE_CHANGED*

Broadcast Action: A tetherable connection has come or gone. 
UsesConnectivityManager.EXTRA_AVAILABLE_TETHER,ConnectivityManager.EXTRA_ACTIVE_TETHERandConnectivityManager.EXTRA_ERRORED_TETHERto
indicate the current state of tethering. Each include a list of interface names 
in that state (may be empty). 


*java.lang.String_android.net.ConnectivityManager.CONNECTIVITY_ACTION*

A change in network connectivity has occurred. A connection has either been 
established or lost. The NetworkInfo for the affected network is sent as an 
extra; it should be consulted to see what kind of connectivity event occurred. 

If this is a connection that was the result of failing over from a disconnected 
network, then the FAILOVER_CONNECTION boolean extra is set to true. 

For a loss of connectivity, if the connectivity manager is attempting to 
connect (or has already connected) to another network, the NetworkInfo for the 
new network is also passed as an extra. This lets any receivers of the 
broadcast know that they should not necessarily tell the user that no data 
traffic will be possible. Instead, the receiver should expect another broadcast 
soon, indicating either that the failover attempt succeeded (and so there is 
still overall data connectivity), or that the failover attempt failed, meaning 
that all connectivity has been lost. 

For a disconnect event, the boolean extra EXTRA_NO_CONNECTIVITY is set totrueif 
there are no connected networks at all. 


*java.lang.String_android.net.ConnectivityManager.CONNECTIVITY_ACTION_IMMEDIATE*

Identical to (|android.net.ConnectivityManager|) broadcast, but sent without 
any applicable (|Settings.Secure|) . 


*int_android.net.ConnectivityManager.CONNECTIVITY_CHANGE_DELAY_DEFAULT*

Default value for (|Settings.Global|) in milliseconds. This was introduced 
because IPv6 routes seem to take a moment to settle - trying network activity 
before the routes are adjusted can lead to packets using the wrong interface or 
having the wrong IP address. This delay is a bit crude, but in the future 
hopefully we will have kernel notifications letting us know when it's safe to 
use the new network. 


*int_android.net.ConnectivityManager.DEFAULT_NETWORK_PREFERENCE*

If you want to set the default network preference,you can directly change the 
networkAttributes array in framework's config.xml. 


*java.lang.String_android.net.ConnectivityManager.EXTRA_ACTIVE_TETHER*




*java.lang.String_android.net.ConnectivityManager.EXTRA_AVAILABLE_TETHER*




*java.lang.String_android.net.ConnectivityManager.EXTRA_DEVICE_TYPE*

The lookup key for an enum that indicates the network device type on which this 
data activity change happens. 


*java.lang.String_android.net.ConnectivityManager.EXTRA_ERRORED_TETHER*




*java.lang.String_android.net.ConnectivityManager.EXTRA_EXTRA_INFO*

The lookup key for a string that provides optionally supplied extra information 
about the network state. The information may be passed up from the lower 
networking layers, and its meaning may be specific to a particular network 
type. Retrieve it with (|android.content.Intent|) . 


*java.lang.String_android.net.ConnectivityManager.EXTRA_INET_CONDITION*

The lookup key for an int that provides information about our connection to the 
internet at large. 0 indicates no connection, 100 indicates a great connection. 
Retrieve it with (|android.content.Intent|) . 


*java.lang.String_android.net.ConnectivityManager.EXTRA_IS_ACTIVE*

The lookup key for a boolean that indicates the device is active or 
not.truemeans it is actively sending or receiving data andfalsemeans it is 
idle. 


*java.lang.String_android.net.ConnectivityManager.EXTRA_IS_CAPTIVE_PORTAL*

The lookup key for a boolean that indicates whether a captive portal was 
detected. Retrieve it with (|android.content.Intent|) . 


*java.lang.String_android.net.ConnectivityManager.EXTRA_IS_FAILOVER*

The lookup key for a boolean that indicates whether a connect event is for a 
network to which the connectivity manager was failing over following a 
disconnect on another network. Retrieve it with (|android.content.Intent|) . 


*java.lang.String_android.net.ConnectivityManager.EXTRA_NETWORK_INFO*

The lookup key for a (|android.net.NetworkInfo|) object. Retrieve with 
(|android.content.Intent|) . 


*java.lang.String_android.net.ConnectivityManager.EXTRA_NETWORK_TYPE*

Network type which triggered a (|android.net.ConnectivityManager|) broadcast. 
Can be used with (|android.net.ConnectivityManager|) to get 
(|android.net.NetworkInfo|) state based on the calling application. 


*java.lang.String_android.net.ConnectivityManager.EXTRA_NO_CONNECTIVITY*

The lookup key for a boolean that indicates whether there is a complete lack of 
connectivity, i.e., no network is available. Retrieve it with 
(|android.content.Intent|) . 


*java.lang.String_android.net.ConnectivityManager.EXTRA_OTHER_NETWORK_INFO*

The lookup key for a (|android.net.NetworkInfo|) object. This is supplied when 
there is another network that it may be possible to connect to. Retrieve with 
(|android.content.Intent|) . 


*java.lang.String_android.net.ConnectivityManager.EXTRA_REASON*

The lookup key for a string that indicates why an attempt to connect to a 
network failed. The string has no particular structure. It is intended to be 
used in notifications presented to users. Retrieve it with 
(|android.content.Intent|) . 


*java.lang.String_android.net.ConnectivityManager.INET_CONDITION_ACTION*

Broadcast Action: The network connection may not be good 
usesConnectivityManager.EXTRA_INET_CONDITIONandConnectivityManager.EXTRA_NETWORK_INFOto
specify the network and it's condition. 


*int_android.net.ConnectivityManager.MAX_NETWORK_TYPE*




*int_android.net.ConnectivityManager.MAX_RADIO_TYPE*




*int_android.net.ConnectivityManager.TETHER_ERROR_DISABLE_NAT_ERROR*




*int_android.net.ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR*




*int_android.net.ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR*




*int_android.net.ConnectivityManager.TETHER_ERROR_MASTER_ERROR*




*int_android.net.ConnectivityManager.TETHER_ERROR_NO_ERROR*




*int_android.net.ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL*




*int_android.net.ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR*




*int_android.net.ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE*




*int_android.net.ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE*




*int_android.net.ConnectivityManager.TETHER_ERROR_UNSUPPORTED*




*int_android.net.ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR*




*int_android.net.ConnectivityManager.TYPE_BLUETOOTH*

The Bluetooth data connection. When active, all data traffic will use this 
network type's interface by default (it has a default route). 


*int_android.net.ConnectivityManager.TYPE_DUMMY*

Dummy data connection. This should not be used on shipping devices. 


*int_android.net.ConnectivityManager.TYPE_ETHERNET*

The Ethernet data connection. When active, all data traffic will use this 
network type's interface by default (it has a default route). 


*int_android.net.ConnectivityManager.TYPE_MOBILE*

The Mobile data connection. When active, all data traffic will use this network 
type's interface by default (it has a default route) 


*int_android.net.ConnectivityManager.TYPE_MOBILE_CBS*

Carrier Branded Services. 


*int_android.net.ConnectivityManager.TYPE_MOBILE_DUN*

A DUN-specific Mobile data connection. This network type may use the same 
network interface as (|android.net.ConnectivityManager|) or it may use a 
different one. This is sometimes by the system when setting up an upstream 
connection for tethering so that the carrier is aware of DUN traffic. 


*int_android.net.ConnectivityManager.TYPE_MOBILE_FOTA*

Over the air Administration. 


*int_android.net.ConnectivityManager.TYPE_MOBILE_HIPRI*

A High Priority Mobile data connection. This network type uses the same network 
interface as (|android.net.ConnectivityManager|) but the routing setup is 
different. Only requesting processes will have access to the Mobile DNS servers 
and only IP's explicitly requested via (|android.net.ConnectivityManager|) will 
route over this interface if no default route exists. 


*int_android.net.ConnectivityManager.TYPE_MOBILE_IA*

The network to use for initially attaching to the network 


*int_android.net.ConnectivityManager.TYPE_MOBILE_IMS*

IP Multimedia Subsystem. 


*int_android.net.ConnectivityManager.TYPE_MOBILE_MMS*

An MMS-specific Mobile data connection. This network type may use the same 
network interface as (|android.net.ConnectivityManager|) or it may use a 
different one. This is used by applications needing to talk to the carrier's 
Multimedia Messaging Service servers. 


*int_android.net.ConnectivityManager.TYPE_MOBILE_SUPL*

A SUPL-specific Mobile data connection. This network type may use the same 
network interface as (|android.net.ConnectivityManager|) or it may use a 
different one. This is used by applications needing to talk to the carrier's 
Secure User Plane Location servers for help locating the device. 


*int_android.net.ConnectivityManager.TYPE_NONE*

The absence of a connection type. 


*int_android.net.ConnectivityManager.TYPE_WIFI*

The WIFI data connection. When active, all data traffic will use this network 
type's interface by default (it has a default route). 


*int_android.net.ConnectivityManager.TYPE_WIFI_P2P*

A Wi-Fi p2p connection. Only requesting processes will have access to the peers 
connected. 


*int_android.net.ConnectivityManager.TYPE_WIMAX*

The WiMAX data connection. When active, all data traffic will use this network 
type's interface by default (it has a default route). 



*android.net.ConnectivityManager(IConnectivityManager)*

public ConnectivityManager(IConnectivityManager service)




*android.net.ConnectivityManager.captivePortalCheckComplete(NetworkInfo)*

public void captivePortalCheckComplete(android.net.NetworkInfo info)

Signal that the captive portal check on the indicated network is complete and 
we can turn the network on for general use. 


    info - the {@link NetworkInfo} object for the networkType in question. 

This method requires the call to hold the permission {@link 
       android.Manifest.permission#CONNECTIVITY_INTERNAL}. {@hide} 

*android.net.ConnectivityManager.captivePortalCheckCompleted(NetworkInfo,boolean)*

public void captivePortalCheckCompleted(
  android.net.NetworkInfo info,
  boolean isCaptivePortal)

Signal that the captive portal check on the indicated network is complete and 
whether its a captive portal or not. 


    info - the {@link NetworkInfo} object for the networkType in question. 
    isCaptivePortal - true/false. 

This method requires the call to hold the permission {@link 
       android.Manifest.permission#CONNECTIVITY_INTERNAL}. {@hide} 

*android.net.ConnectivityManager.checkMobileProvisioning(int)*

public int checkMobileProvisioning(int suggestedTimeOutMs)

Check mobile provisioning. 


    suggestedTimeOutMs, - timeout in milliseconds 

    Returns: time out that will be used, maybe less that suggestedTimeOutMs -1 if an error. 



*android.net.ConnectivityManager.from(Context)*

public static |android.net.ConnectivityManager| from(android.content.Context context)





*android.net.ConnectivityManager.getActiveLinkProperties()*

public |android.net.LinkProperties| getActiveLinkProperties()

Returns the IP information for the current default network. 



    Returns: a {@link LinkProperties} object describing the IP info for the current default 
             network, or {@code null} if there is no current default network. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getActiveLinkQualityInfo()*

public |android.net.LinkQualityInfo| getActiveLinkQualityInfo()

get the information of currently active network link 



*android.net.ConnectivityManager.getActiveNetworkInfo()*

public |android.net.NetworkInfo| getActiveNetworkInfo()

Returns details about the currently active default data network. When 
connected, this network is the default route for outgoing connections. You 
should always check (|android.net.NetworkInfo|) before initiating network 
traffic. This may returnnullwhen there is no default network. 



    Returns: a {@link NetworkInfo} object for the current default network or {@code null} if 
             no network default network is currently active 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. 

*android.net.ConnectivityManager.getActiveNetworkInfoForUid(int)*

public |android.net.NetworkInfo| getActiveNetworkInfoForUid(int uid)

Returns details about the currently active default data network for a given 
uid. This is for internal use only to avoid spying other apps. 



    Returns: a {@link NetworkInfo} object for the current default network for the given uid 
             or {@code null} if no default network is available for the 
             specified uid. 

This method requires the caller to hold the permission {@link 
             android.Manifest.permission#CONNECTIVITY_INTERNAL} {@hide} 

*android.net.ConnectivityManager.getActiveNetworkQuotaInfo()*

public |android.net.NetworkQuotaInfo| getActiveNetworkQuotaInfo()

Return quota status for the current active network, ornullif no network is 
active. Quota status can change rapidly, so these values shouldn't be cached. 

This method requires the call to hold the permission 
(|android.Manifest.permission|) . 



*android.net.ConnectivityManager.getAllLinkQualityInfo()*

public |android.net.LinkQualityInfo|[] getAllLinkQualityInfo()

get the information of all network links 



*android.net.ConnectivityManager.getAllNetworkInfo()*

public |android.net.NetworkInfo|[] getAllNetworkInfo()

Returns connection status information about all network types supported by the 
device. 



    Returns: an array of {@link NetworkInfo} objects. Check each {@link NetworkInfo#getType} 
             for which type each applies. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. 

*android.net.ConnectivityManager.getBackgroundDataSetting()*

public boolean getBackgroundDataSetting()

Returns the value of the setting for background data usage. If false, 
applications should not use the network if the application is not in the 
foreground. Developers should respect this setting, and check the value of this 
before performing any background data operations. 

All applications that have background services that use the network should 
listen to (|android.net.ConnectivityManager|) . 

    Deprecated: As of {@link VERSION_CODES#ICE_CREAM_SANDWICH}, availability of
 background data depends on several combined factors, and this method will
 always return {@code true}. Instead, when background data is unavailable,
 {@link #getActiveNetworkInfo()} will now appear disconnected.


    Returns: Whether background data usage is allowed. 

*android.net.ConnectivityManager.getGlobalProxy()*

public |android.net.ProxyProperties| getGlobalProxy()

Retrieve any network-independent global HTTP proxy. 



    Returns: {@link ProxyProperties} for the current global HTTP proxy or {@code null} if no 
             global HTTP proxy is set. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getLastTetherError(String)*

public int getLastTetherError(java.lang.String iface)

Get a more detailed error code after a Tethering or Untethering request 
asynchronously failed. 


    iface - The name of the interface of interest 

    Returns: error The error code of the last error tethering or untethering the named 
             interface 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getLinkProperties(int)*

public |android.net.LinkProperties| getLinkProperties(int networkType)

Returns the IP information for a given network type. 


    networkType - the network type of interest. 

    Returns: a {@link LinkProperties} object describing the IP info for the given 
             networkType, or {@code null} if there is no current default 
             network. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getLinkQualityInfo(int)*

public |android.net.LinkQualityInfo| getLinkQualityInfo(int networkType)

get the information about a specific network link 



*android.net.ConnectivityManager.getMobileDataEnabled()*

public boolean getMobileDataEnabled()

Gets the value of the setting for enabling Mobile data. 



    Returns: Whether mobile data is enabled. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. 

*android.net.ConnectivityManager.getMobileProvisioningUrl()*

public |java.lang.String| getMobileProvisioningUrl()

Get the mobile provisioning url. 



*android.net.ConnectivityManager.getMobileRedirectedProvisioningUrl()*

public |java.lang.String| getMobileRedirectedProvisioningUrl()

Get the mobile redirected provisioning url. 



*android.net.ConnectivityManager.getNetworkInfo(int)*

public |android.net.NetworkInfo| getNetworkInfo(int networkType)

Returns connection status information about a particular network type. 


    networkType - integer specifying which networkType in which you're interested. 

    Returns: a {@link NetworkInfo} object for the requested network type or {@code null} if 
             the type is not supported by the device. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. 

*android.net.ConnectivityManager.getNetworkPreference()*

public int getNetworkPreference()

Retrieves the current preferred network type. Note that this made sense when we 
only had 2 network types, but with more and more default networks we need an 
array to list their ordering. This will be deprecated soon. 



    Returns: an integer representing the preferred network type 

This method requires the caller to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. 

*android.net.ConnectivityManager.getNetworkTypeName(int)*

public static |java.lang.String| getNetworkTypeName(int type)

Returns a non-localized string representing a given network type. ONLY used for 
debugging output. 


    type - the type needing naming 

    Returns: a String for the given type, or a string version of the type ("87") if no name 
             is known. {@hide} 

*android.net.ConnectivityManager.getProvisioningOrActiveNetworkInfo()*

public |android.net.NetworkInfo| getProvisioningOrActiveNetworkInfo()

Returns details about the Provisioning or currently active default data 
network. When connected, this network is the default route for outgoing 
connections. You should always check (|android.net.NetworkInfo|) before 
initiating network traffic. This may returnnullwhen there is no default 
network. 



    Returns: a {@link NetworkInfo} object for the current default network or {@code null} if 
             no network default network is currently active 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. 



*android.net.ConnectivityManager.getProxy()*

public |android.net.ProxyProperties| getProxy()

Get the HTTP proxy settings for the current default network. Note that if a 
global proxy is set, it will override any per-network setting. 



    Returns: the {@link ProxyProperties} for the current HTTP proxy, or {@code null} if no 
             HTTP proxy is active. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getTetherableBluetoothRegexs()*

public |java.lang.String|[] getTetherableBluetoothRegexs()

Get the list of regular expressions that define any tetherable Bluetooth 
network interfaces. If Bluetooth tethering is not supported by the device, this 
list should be empty. 



    Returns: an array of 0 or more regular expression Strings defining what interfaces are 
             considered tetherable bluetooth interfaces. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getTetherableIfaces()*

public |java.lang.String|[] getTetherableIfaces()

Get the set of tetherable, available interfaces. This list is limited by device 
configuration and current interface existence. 



    Returns: an array of 0 or more Strings of tetherable interface names. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getTetherableUsbRegexs()*

public |java.lang.String|[] getTetherableUsbRegexs()

Get the list of regular expressions that define any tetherable USB network 
interfaces. If USB tethering is not supported by the device, this list should 
be empty. 



    Returns: an array of 0 or more regular expression Strings defining what interfaces are 
             considered tetherable usb interfaces. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getTetherableWifiRegexs()*

public |java.lang.String|[] getTetherableWifiRegexs()

Get the list of regular expressions that define any tetherable Wifi network 
interfaces. If Wifi tethering is not supported by the device, this list should 
be empty. 



    Returns: an array of 0 or more regular expression Strings defining what interfaces are 
             considered tetherable wifi interfaces. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getTetheredIfaces()*

public |java.lang.String|[] getTetheredIfaces()

Get the set of tethered interfaces. 



    Returns: an array of 0 or more String of currently tethered interface names. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.getTetheringErroredIfaces()*

public |java.lang.String|[] getTetheringErroredIfaces()

Get the set of interface names which attempted to tether but failed. 
Re-attempting to tether may cause them to reset to the Tethered state. 
Alternatively, causing the interface to be destroyed and recreated may cause 
them to reset to the available state. (|android.net.ConnectivityManager|) can 
be used to get more information on the cause of the errors. 



    Returns: an array of 0 or more String indicating the interface names which failed to 
             tether. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.isActiveNetworkMetered()*

public boolean isActiveNetworkMetered()

Returns if the currently active data network is metered. A network is 
classified as metered when the user is sensitive to heavy data usage on that 
connection due to monetary costs, data limitations or battery/performance 
issues. You should check this before doing large data transfers, and warn the 
user or delay the operation until another network is available. 



    Returns: {@code true} if large transfers should be avoided, otherwise {@code false}. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. 

*android.net.ConnectivityManager.isNetworkSupported(int)*

public boolean isNetworkSupported(int networkType)

Returns true if the hardware supports the given network type else it returns 
false. This doesn't indicate we have coverage or are authorized onto a network, 
just whether or not the hardware supports it. For example a GSM phone without a 
SIM should still returntruefor mobile data, but a wifi only tablet would 
returnfalse. 


    networkType - The network type we'd like to check 

    Returns: {@code true} if supported, else {@code false} 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. 

*android.net.ConnectivityManager.isNetworkTypeExempt(int)*

public static boolean isNetworkTypeExempt(int networkType)

Checks if the given network type should be exempt from VPN routing rules 



*android.net.ConnectivityManager.isNetworkTypeMobile(int)*

public static boolean isNetworkTypeMobile(int networkType)

Checks if a given type uses the cellular data connection. This should be 
replaced in the future by a network property. 


    networkType - the type to check 

    Returns: a boolean - {@code true} if uses cellular network, else {@code false} {@hide} 

*android.net.ConnectivityManager.isNetworkTypeValid(int)*

public static boolean isNetworkTypeValid(int networkType)

Tests if a given integer represents a valid network type. 


    networkType - the type to be tested 

    Returns: a boolean. {@code true} if the type is valid, else {@code false} 

*android.net.ConnectivityManager.isNetworkTypeWifi(int)*

public static boolean isNetworkTypeWifi(int networkType)

Checks if the given network type is backed by a Wi-Fi radio. 



*android.net.ConnectivityManager.isTetheringSupported()*

public boolean isTetheringSupported()

Check if the device allows for tethering. It may be disabled 
viaro.tether.deniedsystem property, (|android.provider.Settings|) or due to 
device configuration. 



    Returns: a boolean - {@code true} indicating Tethering is supported. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#ACCESS_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.reportInetCondition(int,int)*

public void reportInetCondition(
  int networkType,
  int percentage)

Report network connectivity status. This is currently used only to alter status 
bar UI. 


    networkType - The type of network you want to report on 
    percentage - The quality of the connection 0 is bad, 100 is good 

This method requires the call to hold the permission {@link 
       android.Manifest.permission#STATUS_BAR}. {@hide} 

*android.net.ConnectivityManager.requestNetworkTransitionWakelock(String)*

public boolean requestNetworkTransitionWakelock(java.lang.String forWhom)

Try to ensure the device stays awake until we connect with the next network. 
Actually just holds a wakelock for a number of seconds while we try to connect 
to any default networks. This will expire if the timeout passes or if we 
connect to a default after this is called. For internal use only. 


    forWhom - the name of the network going down for logging purposes 

    Returns: {@code true} on success, {@code false} on failure 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#CONNECTIVITY_INTERNAL}. {@hide} 

*android.net.ConnectivityManager.requestRouteToHost(int,int)*

public boolean requestRouteToHost(
  int networkType,
  int hostAddress)

Ensure that a network route exists to deliver traffic to the specified host via 
the specified network interface. An attempt to add a route that already exists 
is ignored, but treated as successful. This method requires the caller to hold 
the permission (|android.Manifest.permission|) . 


    networkType - the type of the network over which traffic to the specified host is to be 
       routed 
    hostAddress - the IP address of the host to which the route is desired 

    Returns: {@code true} on success, {@code false} on failure 

*android.net.ConnectivityManager.requestRouteToHostAddress(int,InetAddress)*

public boolean requestRouteToHostAddress(
  int networkType,
  java.net.InetAddress hostAddress)

Ensure that a network route exists to deliver traffic to the specified host via 
the specified network interface. An attempt to add a route that already exists 
is ignored, but treated as successful. 


    networkType - the type of the network over which traffic to the specified host is to be 
       routed 
    hostAddress - the IP address of the host to which the route is desired 

    Returns: {@code true} on success, {@code false} on failure 

*android.net.ConnectivityManager.setAirplaneMode(boolean)*

public void setAirplaneMode(boolean enable)

Set the value for enabling/disabling airplane mode 


    enable - whether to enable airplane mode or not 

This method requires the call to hold the permission {@link 
       android.Manifest.permission#CONNECTIVITY_INTERNAL}. 

*android.net.ConnectivityManager.setBackgroundDataSetting(boolean)*

public void setBackgroundDataSetting(boolean allowBackgroundData)

Sets the value of the setting for background data usage. 


    allowBackgroundData - Whether an application should use data while it is in the background. 

*android.net.ConnectivityManager.setDataDependency(int,boolean)*

public void setDataDependency(
  int networkType,
  boolean met)

Sets a secondary requirement bit for the given networkType. This requirement 
bit is generally under the control of the carrier or its agents and is not 
directly controlled by the user. 


    networkType - The network who's dependence has changed 
    met - Boolean - true if network use is OK, false if not 

This method requires the call to hold the permission {@link 
       android.Manifest.permission#CONNECTIVITY_INTERNAL}. {@hide} 

*android.net.ConnectivityManager.setGlobalProxy(ProxyProperties)*

public void setGlobalProxy(android.net.ProxyProperties p)

Set a network-independent global http proxy. This is not normally what you want 
for typical HTTP proxies - they are general network dependent. However if 
you're doing something unusual like general internal filtering this may be 
useful. On a private network where the proxy is not accessible, you may break 
HTTP using this. 


    proxyProperties - The a {@link ProxyProperites} object defining the new global HTTP proxy. A 
       {@code null} value will clear the global HTTP proxy. 

This method requires the call to hold the permission {@link 
       android.Manifest.permission#CONNECTIVITY_INTERNAL}. {@hide} 

*android.net.ConnectivityManager.setMobileDataEnabled(boolean)*

public void setMobileDataEnabled(boolean enabled)

Sets the persisted value for enabling/disabling Mobile data. 


    enabled - Whether the user wants the mobile data connection used or not. 

*android.net.ConnectivityManager.setNetworkPreference(int)*

public void setNetworkPreference(int preference)

Specifies the preferred network type. When the device has more than one type 
available the preferred network type will be used. Note that this made sense 
when we only had 2 network types, but with more and more default networks we 
need an array to list their ordering. This will be deprecated soon. 


    preference - the network type to prefer over all others. It is unspecified what happens to 
       the old preferred network in the overall ordering. 

*android.net.ConnectivityManager.setProvisioningNotificationVisible(boolean,int,String,String)*

public void setProvisioningNotificationVisible(
  boolean visible,
  int networkType,
  java.lang.String extraInfo,
  java.lang.String url)

Set sign in error notification to visible or in visible 


    visible - 
    networkType - {@hide} 

*android.net.ConnectivityManager.setRadio(int,boolean)*

public boolean setRadio(
  int networkType,
  boolean turnOn)

Tells a given networkType to set its radio power state as directed. 


    networkType - the int networkType of interest. 
    turnOn - a boolean, {@code true} to turn the radio on, {@code} false to turn it off. 

    Returns: a boolean, {@code true} indicating success. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#CHANGE_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.setRadios(boolean)*

public boolean setRadios(boolean turnOn)

Tells each network type to set its radio power state as directed. 


    turnOn - a boolean, {@code true} to turn the radios on, {@code false} to turn them off. 

    Returns: a boolean, {@code true} indicating success. All network types will be tried, 
             even if some fail. 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#CHANGE_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.setUsbTethering(boolean)*

public int setUsbTethering(boolean enable)

Attempt to both alter the mode of USB and Tethering of USB. A utility method to 
deal with some of the complexity of USB - will attempt to switch to Rndis and 
subsequently tether the resulting interface ontrueor turn off tethering and 
switch off Rndis onfalse. 


    enable - a boolean - {@code true} to enable tethering 

    Returns: error a {@code TETHER_ERROR} value indicating success or failure type 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#CHANGE_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.startUsingNetworkFeature(int,String)*

public int startUsingNetworkFeature(
  int networkType,
  java.lang.String feature)

Tells the underlying networking system that the caller wants to begin using the 
named feature. The interpretation offeatureis completely up to each networking 
implementation. This method requires the caller to hold the permission 
(|android.Manifest.permission|) . 


    networkType - specifies which network the request pertains to 
    feature - the name of the feature to be used 

    Returns: an integer value representing the outcome of the request. The interpretation of 
             this value is specific to each networking implementation+feature 
             combination, except that the value {@code -1} always indicates 
             failure. 

*android.net.ConnectivityManager.stopUsingNetworkFeature(int,String)*

public int stopUsingNetworkFeature(
  int networkType,
  java.lang.String feature)

Tells the underlying networking system that the caller is finished using the 
named feature. The interpretation offeatureis completely up to each networking 
implementation. This method requires the caller to hold the permission 
(|android.Manifest.permission|) . 


    networkType - specifies which network the request pertains to 
    feature - the name of the feature that is no longer needed 

    Returns: an integer value representing the outcome of the request. The interpretation of 
             this value is specific to each networking implementation+feature 
             combination, except that the value {@code -1} always indicates 
             failure. 

*android.net.ConnectivityManager.supplyMessenger(int,Messenger)*

public void supplyMessenger(
  int networkType,
  android.os.Messenger messenger)

Supply the backend messenger for a network tracker 


    type - NetworkType to set 
    messenger - {@link Messenger} {@hide} 

*android.net.ConnectivityManager.tether(String)*

public int tether(java.lang.String iface)

Attempt to tether the named interface. This will setup a dhcp server on the 
interface, forward and NAT IP packets and forward DNS requests to the best 
active upstream network interface. Note that if no upstream IP network 
interface is available, dhcp will still run and traffic will be allowed between 
the tethered devices and this device, though upstream net access will of course 
fail until an upstream network interface becomes active. 


    iface - the interface name to tether. 

    Returns: error a {@code TETHER_ERROR} value indicating success or failure type 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#CHANGE_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.untether(String)*

public int untether(java.lang.String iface)

Stop tethering the named interface. 


    iface - the interface name to untether. 

    Returns: error a {@code TETHER_ERROR} value indicating success or failure type 

This method requires the call to hold the permission {@link 
             android.Manifest.permission#CHANGE_NETWORK_STATE}. {@hide} 

*android.net.ConnectivityManager.updateLockdownVpn()*

public boolean updateLockdownVpn()

If the LockdownVpn mechanism is enabled, updates the vpn with a reload of its 
profile. 



    Returns: a boolean with {@code} indicating success 

This method can only be called by the system UID {@hide} 


