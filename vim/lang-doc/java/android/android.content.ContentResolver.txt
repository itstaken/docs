*android.content.ContentResolver* *ContentResolver* This class provides applicat

public abstract class ContentResolver
  extends    |java.lang.Object|

|android.content.ContentResolver_Description|
|android.content.ContentResolver_Fields|
|android.content.ContentResolver_Constructors|
|android.content.ContentResolver_Methods|

================================================================================

*android.content.ContentResolver_Fields*
|android.content.Intent_android.content.ContentResolver.ACTION_SYNC_CONN_STATUS_CHANGED|
|java.lang.String_android.content.ContentResolver.CONTENT_SERVICE_NAME|
|java.lang.String_android.content.ContentResolver.CURSOR_DIR_BASE_TYPE|
|java.lang.String_android.content.ContentResolver.CURSOR_ITEM_BASE_TYPE|
|java.lang.String_android.content.ContentResolver.SCHEME_ANDROID_RESOURCE|
|java.lang.String_android.content.ContentResolver.SCHEME_CONTENT|
|java.lang.String_android.content.ContentResolver.SCHEME_FILE|
|int_android.content.ContentResolver.SYNC_ERROR_AUTHENTICATION|
|int_android.content.ContentResolver.SYNC_ERROR_CONFLICT|
|int_android.content.ContentResolver.SYNC_ERROR_INTERNAL|
|int_android.content.ContentResolver.SYNC_ERROR_IO|
|int_android.content.ContentResolver.SYNC_ERROR_PARSE|
|int_android.content.ContentResolver.SYNC_ERROR_SYNC_ALREADY_IN_PROGRESS|
|int_android.content.ContentResolver.SYNC_ERROR_TOO_MANY_DELETIONS|
|int_android.content.ContentResolver.SYNC_ERROR_TOO_MANY_RETRIES|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_ACCOUNT|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_DISALLOW_METERED|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_EXPECTED_DOWNLOAD|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_EXPECTED_UPLOAD|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_EXPEDITED|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_FORCE|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_INITIALIZE|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_MANUAL|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_PRIORITY|
|java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_UPLOAD|
|int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_ACTIVE|
|int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_ALL|
|int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_PENDING|
|int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_SETTINGS|
|int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_STATUS|

*android.content.ContentResolver_Constructors*
|android.content.ContentResolver(Context)|

*android.content.ContentResolver_Methods*
|android.content.ContentResolver.acquireContentProviderClient(String)|Returns a
|android.content.ContentResolver.acquireContentProviderClient(Uri)|Returns aCon
|android.content.ContentResolver.acquireExistingProvider(Context,String)|Provid
|android.content.ContentResolver.acquireExistingProvider(Uri)|Returns the conte
|android.content.ContentResolver.acquireProvider(Context,String)|
|android.content.ContentResolver.acquireProvider(String)|
|android.content.ContentResolver.acquireProvider(Uri)|Returns the content provi
|android.content.ContentResolver.acquireUnstableContentProviderClient(String)|L
|android.content.ContentResolver.acquireUnstableContentProviderClient(Uri)|Like
|android.content.ContentResolver.acquireUnstableProvider(Context,String)|
|android.content.ContentResolver.acquireUnstableProvider(String)|
|android.content.ContentResolver.acquireUnstableProvider(Uri)|Returns the conte
|android.content.ContentResolver.addPeriodicSync(Account,String,Bundle,long)|Sp
|android.content.ContentResolver.addStatusChangeListener(int,SyncStatusObserver)|
|android.content.ContentResolver.applyBatch(String,ArrayList<ContentProviderOperation>)|
|android.content.ContentResolver.appNotRespondingViaProvider(IContentProvider)|
|android.content.ContentResolver.bulkInsert(Uri,ContentValues[])|Inserts multip
|android.content.ContentResolver.call(Uri,String,String,Bundle)|Call a provider
|android.content.ContentResolver.cancelSync(Account,String)|Cancel any active o
|android.content.ContentResolver.cancelSync(Uri)|Cancel any active or pending s
|android.content.ContentResolver.canonicalize(Uri)|Transform the given url to a
|android.content.ContentResolver.delete(Uri,String,String[])|Deletes row(s) spe
|android.content.ContentResolver.getContentService()|
|android.content.ContentResolver.getCurrentSync()|If a sync is active returns t
|android.content.ContentResolver.getCurrentSyncs()|Returns a list with informat
|android.content.ContentResolver.getIsSyncable(Account,String)|Check if this ac
|android.content.ContentResolver.getMasterSyncAutomatically()|Gets the master a
|android.content.ContentResolver.getOutgoingPersistedUriPermissions()|Return li
|android.content.ContentResolver.getPackageName()|
|android.content.ContentResolver.getPeriodicSyncs(Account,String)|Get the list 
|android.content.ContentResolver.getPersistedUriPermissions()|Return list of al
|android.content.ContentResolver.getResourceId(Uri)|Resolves an android.resourc
|android.content.ContentResolver.getStreamTypes(Uri,String)|Query for the possi
|android.content.ContentResolver.getSyncAdapterTypes()|Get information about th
|android.content.ContentResolver.getSyncAutomatically(Account,String)|Check if 
|android.content.ContentResolver.getSyncStatus(Account,String)|Returns the stat
|android.content.ContentResolver.getType(Uri)|Return the MIME type of the given
|android.content.ContentResolver.insert(Uri,ContentValues)|Inserts a row into a
|android.content.ContentResolver.isSyncActive(Account,String)|Returns true if t
|android.content.ContentResolver.isSyncPending(Account,String)|Return true if t
|android.content.ContentResolver.notifyChange(Uri,ContentObserver)|Notify regis
|android.content.ContentResolver.notifyChange(Uri,ContentObserver,boolean)|Noti
|android.content.ContentResolver.notifyChange(Uri,ContentObserver,boolean,int)|
|android.content.ContentResolver.openAssetFileDescriptor(Uri,String)|Open a raw
|android.content.ContentResolver.openAssetFileDescriptor(Uri,String,CancellationSignal)|
|android.content.ContentResolver.openFileDescriptor(Uri,String)|Open a raw file
|android.content.ContentResolver.openFileDescriptor(Uri,String,CancellationSignal)|
|android.content.ContentResolver.openInputStream(Uri)|Open a stream on to the c
|android.content.ContentResolver.openOutputStream(Uri)|Synonym for#openOutputSt
|android.content.ContentResolver.openOutputStream(Uri,String)|Open a stream on 
|android.content.ContentResolver.openTypedAssetFileDescriptor(Uri,String,Bundle)|
|android.content.ContentResolver.openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)|
|android.content.ContentResolver.query(Uri,String[],String,String[],String)|Que
|android.content.ContentResolver.query(Uri,String[],String,String[],String,CancellationSignal)|
|android.content.ContentResolver.registerContentObserver(Uri,boolean,ContentObserver)|
|android.content.ContentResolver.registerContentObserver(Uri,boolean,ContentObserver,int)|
|android.content.ContentResolver.releasePersistableUriPermission(Uri,int)|Relin
|android.content.ContentResolver.releaseProvider(IContentProvider)|
|android.content.ContentResolver.releaseUnstableProvider(IContentProvider)|
|android.content.ContentResolver.removePeriodicSync(Account,String,Bundle)|Remo
|android.content.ContentResolver.removeStatusChangeListener(Object)|Remove a pr
|android.content.ContentResolver.requestSync(Account,String,Bundle)|Start an as
|android.content.ContentResolver.requestSync(SyncRequest)|Register a sync with 
|android.content.ContentResolver.setIsSyncable(Account,String,int)|Set whether 
|android.content.ContentResolver.setMasterSyncAutomatically(boolean)|Sets the m
|android.content.ContentResolver.setSyncAutomatically(Account,String,boolean)|S
|android.content.ContentResolver.startSync(Uri,Bundle)|Start an asynchronous sy
|android.content.ContentResolver.syncErrorStringToInt(String)|
|android.content.ContentResolver.syncErrorToString(int)|
|android.content.ContentResolver.takePersistableUriPermission(Uri,int)|Take a p
|android.content.ContentResolver.uncanonicalize(Uri)|Given a canonical Uri prev
|android.content.ContentResolver.unregisterContentObserver(ContentObserver)|Unr
|android.content.ContentResolver.unstableProviderDied(IContentProvider)|
|android.content.ContentResolver.update(Uri,ContentValues,String,String[])|Upda
|android.content.ContentResolver.validateSyncExtrasBundle(Bundle)|Check that on

*android.content.ContentResolver_Description*

This class provides applications access to the content model. 

Developer Guides For more information about using a ContentResolver with 
content providers, read the <a 
href="guide/topics/providers/content-providers.html">Content Providers 
developer guide. 



*android.content.Intent_android.content.ContentResolver.ACTION_SYNC_CONN_STATUS_CHANGED*




*java.lang.String_android.content.ContentResolver.CONTENT_SERVICE_NAME*




*java.lang.String_android.content.ContentResolver.CURSOR_DIR_BASE_TYPE*

This is the Android platform's base MIME type for a content: URI containing a 
Cursor of zero or more items. Applications should use this as the base type 
along with their own sub-type of their content: URIs that represent a directory 
of items. For example, hypothetical IMAP email client may have a URI 
content://com.company.provider.imap/inbox for all of the messages in its inbox, 
whose MIME type would be reported as CURSOR_DIR_BASE_TYPE + 
"/vnd.company.imap-msg" 

Note how the base MIME type varies between this and 
(|android.content.ContentResolver|) depending on whether there is one single 
item or multiple items in the data set, while the sub-type remains the same 
because in either case the data structure contained in the cursor is the same. 


*java.lang.String_android.content.ContentResolver.CURSOR_ITEM_BASE_TYPE*

This is the Android platform's base MIME type for a content: URI containing a 
Cursor of a single item. Applications should use this as the base type along 
with their own sub-type of their content: URIs that represent a particular 
item. For example, hypothetical IMAP email client may have a URI 
content://com.company.provider.imap/inbox/1 for a particular message in the 
inbox, whose MIME type would be reported as CURSOR_ITEM_BASE_TYPE + 
"/vnd.company.imap-msg" 

Compare with (|android.content.ContentResolver|) . 


*java.lang.String_android.content.ContentResolver.SCHEME_ANDROID_RESOURCE*




*java.lang.String_android.content.ContentResolver.SCHEME_CONTENT*




*java.lang.String_android.content.ContentResolver.SCHEME_FILE*




*int_android.content.ContentResolver.SYNC_ERROR_AUTHENTICATION*




*int_android.content.ContentResolver.SYNC_ERROR_CONFLICT*




*int_android.content.ContentResolver.SYNC_ERROR_INTERNAL*




*int_android.content.ContentResolver.SYNC_ERROR_IO*




*int_android.content.ContentResolver.SYNC_ERROR_PARSE*




*int_android.content.ContentResolver.SYNC_ERROR_SYNC_ALREADY_IN_PROGRESS*




*int_android.content.ContentResolver.SYNC_ERROR_TOO_MANY_DELETIONS*




*int_android.content.ContentResolver.SYNC_ERROR_TOO_MANY_RETRIES*




*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_ACCOUNT*




*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_DISALLOW_METERED*

Flag to allow sync to occur on metered network. 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS*

Indicates that the sync adapter should not proceed with the delete operations, 
if it determines that there are too many. See (|android.content.SyncResult|) 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY*

If this extra is set to true then the request will not be retried if it fails. 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_EXPECTED_DOWNLOAD*

User-specified flag for expected download size. 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_EXPECTED_UPLOAD*

User-specified flag for expected upload size. 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_EXPEDITED*

If this extra is set to true, the sync request will be scheduled at the front 
of the sync request queue and without any delay 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_FORCE*




*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF*

If this extra is set to true then any backoffs for the initial attempt (e.g. 
due to retries) are ignored by the sync scheduler. If this request fails and 
gets rescheduled then the retries will still honor the backoff. 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS*

If this extra is set to true then the sync settings (like 
getSyncAutomatically()) are ignored by the sync scheduler. 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_INITIALIZE*

Set by the SyncManager to request that the SyncAdapter initialize itself for 
the given account/authority pair. One required initialization step is to ensure 
that (|android.content.ContentResolver|) has been called with a >= 0 value. 
When this flag is set the SyncAdapter does not need to do a full sync, though 
it is allowed to do so. 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_MANUAL*

Setting this extra is the equivalent of setting both 
(|android.content.ContentResolver|) and (|android.content.ContentResolver|) 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS*

Indicates that the sync adapter should proceed with the delete operations, even 
if it determines that there are too many. See (|android.content.SyncResult|) 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_PRIORITY*

Priority of this sync with respect to other syncs scheduled for this 
application. 


*java.lang.String_android.content.ContentResolver.SYNC_EXTRAS_UPLOAD*

Indicates that this sync is intended to only upload local changes to the 
server. For example, this will be set to true if the sync is initiated by a 
call to (|android.content.ContentResolver|) 


*int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_ACTIVE*




*int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_ALL*




*int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_PENDING*




*int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_SETTINGS*




*int_android.content.ContentResolver.SYNC_OBSERVER_TYPE_STATUS*





*android.content.ContentResolver(Context)*

public ContentResolver(android.content.Context context)




*android.content.ContentResolver.acquireContentProviderClient(String)*

public final |android.content.ContentProviderClient| acquireContentProviderClient(java.lang.String name)

Returns a (|android.content.ContentProviderClient|) that is associated with the 
(|android.content.ContentProvider|) with the authority of name, starting the 
provider if necessary. Returns null if there is no provider associated wih the 
uri. The caller must indicate that they are done with the provider by calling 
(|android.content.ContentProviderClient|) which will allow the system to 
release the provider it it determines that there is no other reason for keeping 
it active. 


    name - specifies which provider should be acquired 

    Returns: a {@link ContentProviderClient} that is associated with the {@link 
             ContentProvider} with the authority of name or null if there isn't 
             one. 

*android.content.ContentResolver.acquireContentProviderClient(Uri)*

public final |android.content.ContentProviderClient| acquireContentProviderClient(android.net.Uri uri)

Returns a (|android.content.ContentProviderClient|) that is associated with the 
(|android.content.ContentProvider|) that services the content at uri, starting 
the provider if necessary. Returns null if there is no provider associated wih 
the uri. The caller must indicate that they are done with the provider by 
calling (|android.content.ContentProviderClient|) which will allow the system 
to release the provider it it determines that there is no other reason for 
keeping it active. 


    uri - specifies which provider should be acquired 

    Returns: a {@link ContentProviderClient} that is associated with the {@link 
             ContentProvider} that services the content at uri or null if there 
             isn't one. 

*android.content.ContentResolver.acquireExistingProvider(Context,String)*

protected |android.content.IContentProvider| acquireExistingProvider(
  android.content.Context c,
  java.lang.String name)

Providing a default implementation of this, to avoid having to change a lot of 
other things, but implementations of ContentResolver should implement it. 



*android.content.ContentResolver.acquireExistingProvider(Uri)*

public final |android.content.IContentProvider| acquireExistingProvider(android.net.Uri uri)

Returns the content provider for the given content URI if the process already 
has a reference on it. 


    uri - The URI to a content provider 

    Returns: The ContentProvider for the given URI, or null if no content provider is found. 

*android.content.ContentResolver.acquireProvider(Context,String)*

protected abstract |android.content.IContentProvider| acquireProvider(
  android.content.Context c,
  java.lang.String name)





*android.content.ContentResolver.acquireProvider(String)*

public final |android.content.IContentProvider| acquireProvider(java.lang.String name)





*android.content.ContentResolver.acquireProvider(Uri)*

public final |android.content.IContentProvider| acquireProvider(android.net.Uri uri)

Returns the content provider for the given content URI. 


    uri - The URI to a content provider 

    Returns: The ContentProvider for the given URI, or null if no content provider is found. 

*android.content.ContentResolver.acquireUnstableContentProviderClient(String)*

public final |android.content.ContentProviderClient| acquireUnstableContentProviderClient(java.lang.String name)

Like (|android.content.ContentResolver|) , but for use when you do not trust 
the stability of the target content provider. This turns off the mechanism in 
the platform clean up processes that are dependent on a content provider if 
that content provider's process goes away. Normally you can safely assume that 
once you have acquired a provider, you can freely use it as needed and it won't 
disappear, even if your process is in the background. If using this method, you 
need to take care to deal with any failures when communicating with the 
provider, and be sure to close it so that it can be re-opened later. In 
particular, catching a (|android.os.DeadObjectException|) from the calls there 
will let you know that the content provider has gone away; at that point the 
current ContentProviderClient object is invalid, and you should release it. You 
can acquire a new one if you would like to try to restart the provider and 
perform new operations on it. 



*android.content.ContentResolver.acquireUnstableContentProviderClient(Uri)*

public final |android.content.ContentProviderClient| acquireUnstableContentProviderClient(android.net.Uri uri)

Like (|android.content.ContentResolver|) , but for use when you do not trust 
the stability of the target content provider. This turns off the mechanism in 
the platform clean up processes that are dependent on a content provider if 
that content provider's process goes away. Normally you can safely assume that 
once you have acquired a provider, you can freely use it as needed and it won't 
disappear, even if your process is in the background. If using this method, you 
need to take care to deal with any failures when communicating with the 
provider, and be sure to close it so that it can be re-opened later. In 
particular, catching a (|android.os.DeadObjectException|) from the calls there 
will let you know that the content provider has gone away; at that point the 
current ContentProviderClient object is invalid, and you should release it. You 
can acquire a new one if you would like to try to restart the provider and 
perform new operations on it. 



*android.content.ContentResolver.acquireUnstableProvider(Context,String)*

protected abstract |android.content.IContentProvider| acquireUnstableProvider(
  android.content.Context c,
  java.lang.String name)





*android.content.ContentResolver.acquireUnstableProvider(String)*

public final |android.content.IContentProvider| acquireUnstableProvider(java.lang.String name)





*android.content.ContentResolver.acquireUnstableProvider(Uri)*

public final |android.content.IContentProvider| acquireUnstableProvider(android.net.Uri uri)

Returns the content provider for the given content URI. 


    uri - The URI to a content provider 

    Returns: The ContentProvider for the given URI, or null if no content provider is found. 

*android.content.ContentResolver.addPeriodicSync(Account,String,Bundle,long)*

public static void addPeriodicSync(
  android.accounts.Account account,
  java.lang.String authority,
  android.os.Bundle extras,
  long pollFrequency)

Specifies that a sync should be requested with the specified the account, 
authority, and extras at the given frequency. If there is already another 
periodic sync scheduled with the account, authority and extras then a new 
periodic sync won't be added, instead the frequency of the previous one will be 
updated. 

These periodic syncs honor the "syncAutomatically" and 
"masterSyncAutomatically" settings. Although these sync are scheduled at the 
specified frequency, it may take longer for it to actually be started if other 
syncs are ahead of it in the sync operation queue. This means that the actual 
start time may drift. 

Periodic syncs are not allowed to have any of 
(|android.content.ContentResolver|) , (|android.content.ContentResolver|) , 
(|android.content.ContentResolver|) , (|android.content.ContentResolver|) , 
(|android.content.ContentResolver|) , (|android.content.ContentResolver|) , 
(|android.content.ContentResolver|) set to true. If any are supplied then an 
(|java.lang.IllegalArgumentException|) will be thrown. As of API level 19 this 
function introduces a default flexibility of ~4% (up to a maximum of one hour 
in the day) into the requested period. Use 
(|android.content.SyncRequest.Builder|) to set this flexibility manually. 

This method requires the caller to hold the permission 
(|android.Manifest.permission|) . 


    account - the account to specify in the sync 
    authority - the provider to specify in the sync request 
    extras - extra parameters to go along with the sync request 
    pollFrequency - how frequently the sync should be performed, in seconds. 

*android.content.ContentResolver.addStatusChangeListener(int,SyncStatusObserver)*

public static |java.lang.Object| addStatusChangeListener(
  int mask,
  android.content.SyncStatusObserver callback)

Request notifications when the different aspects of the SyncManager change. The 
different items that can be requested are: 

(|android.content.ContentResolver|) (|android.content.ContentResolver|) 
(|android.content.ContentResolver|) The caller can set one or more of the 
status types in the mask for any given listener registration. 


    mask - the status change types that will cause the callback to be invoked 
    callback - observer to be invoked when the status changes 

    Returns: a handle that can be used to remove the listener at a later time 

*android.content.ContentResolver.applyBatch(String,ArrayList<ContentProviderOperation>)*

public |android.content.ContentProviderResult|[] applyBatch(
  java.lang.String authority,
  java.util.ArrayList<android.content.ContentProviderOperation> operations)
  throws |android.content.OperationApplicationException|
         |android.os.RemoteException|
         
Applies each of the (|android.content.ContentProviderOperation|) objects and 
returns an array of their results. Passes through 
OperationApplicationException, which may be thrown by the call to 
(|android.content.ContentProviderOperation|) . If all the applications succeed 
then a (|android.content.ContentProviderResult|) array with the same number of 
elements as the operations will be returned. It is implementation-specific how 
many, if any, operations will have been successfully applied if a call to apply 
results in a (|android.content.OperationApplicationException|) . 


    authority - the authority of the ContentProvider to which this batch should be applied 
    operations - the operations to apply 

    Returns: the results of the applications 

*android.content.ContentResolver.appNotRespondingViaProvider(IContentProvider)*

public void appNotRespondingViaProvider(android.content.IContentProvider icp)





*android.content.ContentResolver.bulkInsert(Uri,ContentValues[])*

public final int bulkInsert(
  android.net.Uri url,
  android.content.ContentValues[] values)

Inserts multiple rows into a table at the given URL. 

This function make no guarantees about the atomicity of the insertions. 


    url - The URL of the table to insert into. 
    values - The initial values for the newly inserted rows. The key is the column name for 
       the field. Passing null will create an empty row. 

    Returns: the number of newly created rows. 

*android.content.ContentResolver.call(Uri,String,String,Bundle)*

public final |android.os.Bundle| call(
  android.net.Uri uri,
  java.lang.String method,
  java.lang.String arg,
  android.os.Bundle extras)

Call a provider-defined method. This can be used to implement read or write 
interfaces which are cheaper than using a Cursor and/or do not fit into the 
traditional table model. 


    method - provider-defined method name to call. Opaque to framework, but must be 
       non-null. 
    arg - provider-defined String argument. May be null. 
    extras - provider-defined Bundle argument. May be null. 

    Returns: a result Bundle, possibly null. Will be null if the ContentProvider does not 
             implement call. 

*android.content.ContentResolver.cancelSync(Account,String)*

public static void cancelSync(
  android.accounts.Account account,
  java.lang.String authority)

Cancel any active or pending syncs that match account and authority. The 
account and authority can each independently be set to null, which means that 
syncs with any account or authority, respectively, will match. 


    account - filters the syncs that match by this account 
    authority - filters the syncs that match by this authority 

*android.content.ContentResolver.cancelSync(Uri)*

public void cancelSync(android.net.Uri uri)

Cancel any active or pending syncs that match the Uri. If the uri is null then 
all syncs will be canceled. 

    Deprecated: instead use {@link #cancelSync(android.accounts.Account, String)}

    uri - the uri of the provider to sync or null to sync all providers. 

*android.content.ContentResolver.canonicalize(Uri)*

public final |android.net.Uri| canonicalize(android.net.Uri url)

Transform the given url to a canonical representation of its referenced 
resource, which can be used across devices, persisted, backed up and restored, 
etc. The returned Uri is still a fully capable Uri for use with its content 
provider, allowing you to do all of the same content provider operations as 
with the original Uri -- (|android.content.ContentResolver|) , 
(|android.content.ContentResolver|) , etc. The only difference in behavior 
between the original and new Uris is that the content provider may need to do 
some additional work at each call using it to resolve it to the correct 
resource, especially if the canonical Uri has been moved to a different 
environment. 

If you are moving a canonical Uri between environments, you should perform 
another call to (|android.content.ContentResolver|) with that original Uri to 
re-canonicalize it for the current environment. Alternatively, you may want to 
use (|android.content.ContentResolver|) to transform it to a non-canonical Uri 
that works only in the current environment but potentially more efficiently 
than the canonical representation. 


    url - The {@link Uri} that is to be transformed to a canonical representation. Like 
       all resolver calls, the input can be either a non-canonical or canonical 
       Uri. 

    Returns: Returns the official canonical representation of url, or null if the content 
             provider does not support a canonical representation of the given 
             Uri. Many providers may not support canonicalization of some or 
             all of their Uris. 

*android.content.ContentResolver.delete(Uri,String,String[])*

public final int delete(
  android.net.Uri url,
  java.lang.String where,
  java.lang.String[] selectionArgs)

Deletes row(s) specified by a content URI. 

If the content provider supports transactions, the deletion will be atomic. 


    url - The URL of the row to delete. 
    where - A filter to apply to rows before deleting, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). 

    Returns: The number of rows deleted. 

*android.content.ContentResolver.getContentService()*

public static IContentService getContentService()





*android.content.ContentResolver.getCurrentSync()*

public static |android.content.SyncInfo| getCurrentSync()

If a sync is active returns the information about it, otherwise returns null. 

This method requires the caller to hold the permission 
(|android.Manifest.permission|) . 

    Deprecated: Since multiple concurrent syncs are now supported you should use
 {@link #getCurrentSyncs()} to get the accurate list of current syncs.
 This method returns the first item from the list of current syncs
 or null if there are none.


    Returns: the SyncInfo for the currently active sync or null if one is not active. 

*android.content.ContentResolver.getCurrentSyncs()*

public static |java.util.List|<SyncInfo> getCurrentSyncs()

Returns a list with information about all the active syncs. This list will be 
empty if there are no active syncs. 

This method requires the caller to hold the permission 
(|android.Manifest.permission|) . 



    Returns: a List of SyncInfo objects for the currently active syncs. 

*android.content.ContentResolver.getIsSyncable(Account,String)*

public static int getIsSyncable(
  android.accounts.Account account,
  java.lang.String authority)

Check if this account/provider is syncable. This method requires the caller to 
hold the permission (|android.Manifest.permission|) . 



    Returns: >0 if it is syncable, 0 if not, and <0 if the state isn't known yet. 

*android.content.ContentResolver.getMasterSyncAutomatically()*

public static boolean getMasterSyncAutomatically()

Gets the master auto-sync setting that applies to all the providers and 
accounts. If this is false then the per-provider auto-sync setting is ignored. 
This method requires the caller to hold the permission 
(|android.Manifest.permission|) . 



    Returns: the master auto-sync setting that applies to all the providers and accounts 

*android.content.ContentResolver.getOutgoingPersistedUriPermissions()*

public |java.util.List|<UriPermission> getOutgoingPersistedUriPermissions()

Return list of all persisted URI permission grants that are hosted by the 
calling app. That is, the returned permissions have been granted from the 
calling app. Only grants taken with (|android.content.ContentResolver|) are 
returned. 



*android.content.ContentResolver.getPackageName()*

public |java.lang.String| getPackageName()





*android.content.ContentResolver.getPeriodicSyncs(Account,String)*

public static |java.util.List|<PeriodicSync> getPeriodicSyncs(
  android.accounts.Account account,
  java.lang.String authority)

Get the list of information about the periodic syncs for the given account and 
authority. This method requires the caller to hold the permission 
(|android.Manifest.permission|) . 


    account - the account whose periodic syncs we are querying 
    authority - the provider whose periodic syncs we are querying 

    Returns: a list of PeriodicSync objects. This list may be empty but will never be null. 

*android.content.ContentResolver.getPersistedUriPermissions()*

public |java.util.List|<UriPermission> getPersistedUriPermissions()

Return list of all URI permission grants that have been persisted by the 
calling app. That is, the returned permissions have been granted to the calling 
app. Only persistable grants taken with (|android.content.ContentResolver|) are 
returned. 



*android.content.ContentResolver.getResourceId(Uri)*

public |android.content.ContentResolver.OpenResourceIdResult| getResourceId(android.net.Uri uri)
  throws |java.io.FileNotFoundException|
         
Resolves an android.resource URI to a (|android.content.res.Resources|) and a 
resource id. 



*android.content.ContentResolver.getStreamTypes(Uri,String)*

public |java.lang.String|[] getStreamTypes(
  android.net.Uri url,
  java.lang.String mimeTypeFilter)

Query for the possible MIME types for the representations the given content URL 
can be returned when opened as as stream with 
(|android.content.ContentResolver|) . Note that the types here are not 
necessarily a superset of the type returned by 
(|android.content.ContentResolver|) -- many content providers cannot return a 
raw stream for the structured data that they contain. 


    url - A Uri identifying content (either a list or specific type), using the 
       content:// scheme. 
    mimeTypeFilter - The desired MIME type. This may be a pattern, such as *\/*, to query for all 
       available MIME types that match the pattern. 

    Returns: Returns an array of MIME type strings for all available data streams that match 
             the given mimeTypeFilter. If there are none, null is returned. 

*android.content.ContentResolver.getSyncAdapterTypes()*

public static |android.content.SyncAdapterType|[] getSyncAdapterTypes()

Get information about the SyncAdapters that are known to the system. 



    Returns: an array of SyncAdapters that have registered with the system 

*android.content.ContentResolver.getSyncAutomatically(Account,String)*

public static boolean getSyncAutomatically(
  android.accounts.Account account,
  java.lang.String authority)

Check if the provider should be synced when a network tickle is received This 
method requires the caller to hold the permission 
(|android.Manifest.permission|) . 


    account - the account whose setting we are querying 
    authority - the provider whose setting we are querying 

    Returns: true if the provider should be synced when a network tickle is received 

*android.content.ContentResolver.getSyncStatus(Account,String)*

public static |android.content.SyncStatusInfo| getSyncStatus(
  android.accounts.Account account,
  java.lang.String authority)

Returns the status that matches the authority. 


    account - the account whose setting we are querying 
    authority - the provider whose behavior is being queried 

    Returns: the SyncStatusInfo for the authority, or null if none exists 

*android.content.ContentResolver.getType(Uri)*

public final |java.lang.String| getType(android.net.Uri url)

Return the MIME type of the given content URL. 


    url - A Uri identifying content (either a list or specific type), using the 
       content:// scheme. 

    Returns: A MIME type for the content, or null if the URL is invalid or the type is 
             unknown 

*android.content.ContentResolver.insert(Uri,ContentValues)*

public final |android.net.Uri| insert(
  android.net.Uri url,
  android.content.ContentValues values)

Inserts a row into a table at the given URL. 

If the content provider supports transactions the insertion will be atomic. 


    url - The URL of the table to insert into. 
    values - The initial values for the newly inserted row. The key is the column name for 
       the field. Passing an empty ContentValues will create an empty row. 

    Returns: the URL of the newly created row. 

*android.content.ContentResolver.isSyncActive(Account,String)*

public static boolean isSyncActive(
  android.accounts.Account account,
  java.lang.String authority)

Returns true if there is currently a sync operation for the given account or 
authority in the pending list, or actively being processed. This method 
requires the caller to hold the permission (|android.Manifest.permission|) . 


    account - the account whose setting we are querying 
    authority - the provider whose behavior is being queried 

    Returns: true if a sync is active for the given account or authority. 

*android.content.ContentResolver.isSyncPending(Account,String)*

public static boolean isSyncPending(
  android.accounts.Account account,
  java.lang.String authority)

Return true if the pending status is true of any matching authorities. This 
method requires the caller to hold the permission 
(|android.Manifest.permission|) . 


    account - the account whose setting we are querying 
    authority - the provider whose behavior is being queried 

    Returns: true if there is a pending sync with the matching account and authority 

*android.content.ContentResolver.notifyChange(Uri,ContentObserver)*

public void notifyChange(
  android.net.Uri uri,
  android.database.ContentObserver observer)

Notify registered observers that a row was updated and attempt to sync changes 
to the network. To register, call 
registerContentObserver()(|android.content.ContentResolver|) . By default, 
CursorAdapter objects will get this notification. 


    uri - The uri of the content that was changed. 
    observer - The observer that originated the change, may be null. The observer that 
       originated the change will only receive the notification if it has 
       requested to receive self-change notifications by implementing {@link 
       ContentObserver#deliverSelfNotifications()} to return true. 

*android.content.ContentResolver.notifyChange(Uri,ContentObserver,boolean)*

public void notifyChange(
  android.net.Uri uri,
  android.database.ContentObserver observer,
  boolean syncToNetwork)

Notify registered observers that a row was updated. To register, call 
registerContentObserver()(|android.content.ContentResolver|) . By default, 
CursorAdapter objects will get this notification. If syncToNetwork is true, 
this will attempt to schedule a local sync using the sync adapter that's 
registered for the authority of the provided uri. No account will be passed to 
the sync adapter, so all matching accounts will be synchronized. 


    uri - The uri of the content that was changed. 
    observer - The observer that originated the change, may be null. The observer that 
       originated the change will only receive the notification if it has 
       requested to receive self-change notifications by implementing {@link 
       ContentObserver#deliverSelfNotifications()} to return true. 
    syncToNetwork - If true, attempt to sync the change to the network. 

*android.content.ContentResolver.notifyChange(Uri,ContentObserver,boolean,int)*

public void notifyChange(
  android.net.Uri uri,
  android.database.ContentObserver observer,
  boolean syncToNetwork,
  int userHandle)

Notify registered observers within the designated user(s) that a row was 
updated. 



*android.content.ContentResolver.openAssetFileDescriptor(Uri,String)*

public final |android.content.res.AssetFileDescriptor| openAssetFileDescriptor(
  android.net.Uri uri,
  java.lang.String mode)
  throws |java.io.FileNotFoundException|
         
Open a raw file descriptor to access data under a URI. This interacts with the 
underlying (|android.content.ContentProvider|) method of the provider 
associated with the given URI, to retrieve any file stored there. 

Accepts the following URI schemes: 

content ( (|android.content.ContentResolver|) ) android.resource ( 
(|android.content.ContentResolver|) ) file ( 
(|android.content.ContentResolver|) ) 

The android.resource ( (|android.content.ContentResolver|) ) Scheme 

A Uri object can be used to reference a resource in an APK file. The Uri should 
be one of the following formats: 

android.resource://package_name/id_number package_name is your package name as 
listed in your AndroidManifest.xml. For example com.example.myapp id_number is 
the int form of the ID. The easiest way to construct this form is 

Uri uri = Uri.parse("android.resource://com.example.myapp/" + 
R.raw.my_resource"); 

android.resource://package_name/type/name package_name is your package name as 
listed in your AndroidManifest.xml. For example com.example.myapp type is the 
string form of the resource type. For example, raw or drawable. name is the 
string form of the resource name. That is, whatever the file name was in your 
res directory, without the type extension. The easiest way to construct this 
form is 

Uri uri = Uri.parse("android.resource://com.example.myapp/raw/my_resource"); 



Note that if this function is called for read-only input (mode is "r") on a 
content: URI, it will instead call (|android.content.ContentResolver|) for you 
with a MIME type of "*\/*". This allows such callers to benefit from any 
built-in data conversion that a provider implements. 


    uri - The desired URI to open. 
    mode - The file mode to use, as per {@link ContentProvider#openAssetFile 
       ContentProvider.openAssetFile}. 

    Returns: Returns a new ParcelFileDescriptor pointing to the file. You own this 
             descriptor and are responsible for closing it when done. 

*android.content.ContentResolver.openAssetFileDescriptor(Uri,String,CancellationSignal)*

public final |android.content.res.AssetFileDescriptor| openAssetFileDescriptor(
  android.net.Uri uri,
  java.lang.String mode,
  android.os.CancellationSignal cancellationSignal)
  throws |java.io.FileNotFoundException|
         
Open a raw file descriptor to access data under a URI. This interacts with the 
underlying (|android.content.ContentProvider|) method of the provider 
associated with the given URI, to retrieve any file stored there. 

Accepts the following URI schemes: 

content ( (|android.content.ContentResolver|) ) android.resource ( 
(|android.content.ContentResolver|) ) file ( 
(|android.content.ContentResolver|) ) 

The android.resource ( (|android.content.ContentResolver|) ) Scheme 

A Uri object can be used to reference a resource in an APK file. The Uri should 
be one of the following formats: 

android.resource://package_name/id_number package_name is your package name as 
listed in your AndroidManifest.xml. For example com.example.myapp id_number is 
the int form of the ID. The easiest way to construct this form is 

Uri uri = Uri.parse("android.resource://com.example.myapp/" + 
R.raw.my_resource"); 

android.resource://package_name/type/name package_name is your package name as 
listed in your AndroidManifest.xml. For example com.example.myapp type is the 
string form of the resource type. For example, raw or drawable. name is the 
string form of the resource name. That is, whatever the file name was in your 
res directory, without the type extension. The easiest way to construct this 
form is 

Uri uri = Uri.parse("android.resource://com.example.myapp/raw/my_resource"); 



Note that if this function is called for read-only input (mode is "r") on a 
content: URI, it will instead call (|android.content.ContentResolver|) for you 
with a MIME type of "*\/*". This allows such callers to benefit from any 
built-in data conversion that a provider implements. 


    uri - The desired URI to open. 
    mode - The file mode to use, as per {@link ContentProvider#openAssetFile 
       ContentProvider.openAssetFile}. 
    cancellationSignal - A signal to cancel the operation in progress, or null if none. If the operation 
       is canceled, then {@link OperationCanceledException} will be thrown. 

    Returns: Returns a new ParcelFileDescriptor pointing to the file. You own this 
             descriptor and are responsible for closing it when done. 

*android.content.ContentResolver.openFileDescriptor(Uri,String)*

public final |android.os.ParcelFileDescriptor| openFileDescriptor(
  android.net.Uri uri,
  java.lang.String mode)
  throws |java.io.FileNotFoundException|
         
Open a raw file descriptor to access data under a URI. This is like 
(|android.content.ContentResolver|) , but uses the underlying 
(|android.content.ContentProvider|) ContentProvider.openFile()} method, so will 
not work with providers that return sub-sections of files. If at all possible, 
you should use (|android.content.ContentResolver|) . You will receive a 
FileNotFoundException exception if the provider returns a sub-section of a 
file. 

Accepts the following URI schemes: 

content ( (|android.content.ContentResolver|) ) file ( 
(|android.content.ContentResolver|) ) 

See (|android.content.ContentResolver|) for more information on these schemes. 

If opening with the exclusive "r" or "w" modes, the returned 
ParcelFileDescriptor could be a pipe or socket pair to enable streaming of 
data. Opening with the "rw" mode implies a file on disk that supports seeking. 
If possible, always use an exclusive mode to give the underlying 
(|android.content.ContentProvider|) the most flexibility. 

If you are writing a file, and need to communicate an error to the provider, 
use (|android.os.ParcelFileDescriptor|) . 


    uri - The desired URI to open. 
    mode - The file mode to use, as per {@link ContentProvider#openFile 
       ContentProvider.openFile}. 

    Returns: Returns a new ParcelFileDescriptor pointing to the file. You own this 
             descriptor and are responsible for closing it when done. 

*android.content.ContentResolver.openFileDescriptor(Uri,String,CancellationSignal)*

public final |android.os.ParcelFileDescriptor| openFileDescriptor(
  android.net.Uri uri,
  java.lang.String mode,
  android.os.CancellationSignal cancellationSignal)
  throws |java.io.FileNotFoundException|
         
Open a raw file descriptor to access data under a URI. This is like 
(|android.content.ContentResolver|) , but uses the underlying 
(|android.content.ContentProvider|) ContentProvider.openFile()} method, so will 
not work with providers that return sub-sections of files. If at all possible, 
you should use (|android.content.ContentResolver|) . You will receive a 
FileNotFoundException exception if the provider returns a sub-section of a 
file. 

Accepts the following URI schemes: 

content ( (|android.content.ContentResolver|) ) file ( 
(|android.content.ContentResolver|) ) 

See (|android.content.ContentResolver|) for more information on these schemes. 

If opening with the exclusive "r" or "w" modes, the returned 
ParcelFileDescriptor could be a pipe or socket pair to enable streaming of 
data. Opening with the "rw" mode implies a file on disk that supports seeking. 
If possible, always use an exclusive mode to give the underlying 
(|android.content.ContentProvider|) the most flexibility. 

If you are writing a file, and need to communicate an error to the provider, 
use (|android.os.ParcelFileDescriptor|) . 


    uri - The desired URI to open. 
    mode - The file mode to use, as per {@link ContentProvider#openFile 
       ContentProvider.openFile}. 
    cancellationSignal - A signal to cancel the operation in progress, or null if none. If the operation 
       is canceled, then {@link OperationCanceledException} will be thrown. 

    Returns: Returns a new ParcelFileDescriptor pointing to the file. You own this 
             descriptor and are responsible for closing it when done. 

*android.content.ContentResolver.openInputStream(Uri)*

public final |java.io.InputStream| openInputStream(android.net.Uri uri)
  throws |java.io.FileNotFoundException|
         
Open a stream on to the content associated with a content URI. If there is no 
data associated with the URI, FileNotFoundException is thrown. 

Accepts the following URI schemes: 

content ( (|android.content.ContentResolver|) ) android.resource ( 
(|android.content.ContentResolver|) ) file ( 
(|android.content.ContentResolver|) ) 

See (|android.content.ContentResolver|) for more information on these schemes. 


    uri - The desired URI. 

    Returns: 

*android.content.ContentResolver.openOutputStream(Uri)*

public final |java.io.OutputStream| openOutputStream(android.net.Uri uri)
  throws |java.io.FileNotFoundException|
         
Synonym for openOutputStream(uri, "w")(|android.content.ContentResolver|) . 



*android.content.ContentResolver.openOutputStream(Uri,String)*

public final |java.io.OutputStream| openOutputStream(
  android.net.Uri uri,
  java.lang.String mode)
  throws |java.io.FileNotFoundException|
         
Open a stream on to the content associated with a content URI. If there is no 
data associated with the URI, FileNotFoundException is thrown. 

Accepts the following URI schemes: 

content ( (|android.content.ContentResolver|) ) file ( 
(|android.content.ContentResolver|) ) 

See (|android.content.ContentResolver|) for more information on these schemes. 


    uri - The desired URI. 
    mode - May be "w", "wa", "rw", or "rwt". 

    Returns: 

*android.content.ContentResolver.openTypedAssetFileDescriptor(Uri,String,Bundle)*

public final |android.content.res.AssetFileDescriptor| openTypedAssetFileDescriptor(
  android.net.Uri uri,
  java.lang.String mimeType,
  android.os.Bundle opts)
  throws |java.io.FileNotFoundException|
         
Open a raw file descriptor to access (potentially type transformed) data from a 
"content:" URI. This interacts with the underlying 
(|android.content.ContentProvider|) method of the provider associated with the 
given URI, to retrieve retrieve any appropriate data stream for the data stored 
there. 

Unlike (|android.content.ContentResolver|) , this function only works with 
"content:" URIs, because content providers are the only facility with an 
associated MIME type to ensure that the returned data stream is of the desired 
type. 

All text/* streams are encoded in UTF-8. 


    uri - The desired URI to open. 
    mimeType - The desired MIME type of the returned data. This can be a pattern such as *\/*, 
       which will allow the content provider to select a type, though there is 
       no way for you to determine what type it is returning. 
    opts - Additional provider-dependent options. 

    Returns: Returns a new ParcelFileDescriptor from which you can read the data stream from 
             the provider. Note that this may be a pipe, meaning you can't seek 
             in it. The only seek you should do is if the AssetFileDescriptor 
             contains an offset, to move to that offset before reading. You own 
             this descriptor and are responsible for closing it when done. 

*android.content.ContentResolver.openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)*

public final |android.content.res.AssetFileDescriptor| openTypedAssetFileDescriptor(
  android.net.Uri uri,
  java.lang.String mimeType,
  android.os.Bundle opts,
  android.os.CancellationSignal cancellationSignal)
  throws |java.io.FileNotFoundException|
         
Open a raw file descriptor to access (potentially type transformed) data from a 
"content:" URI. This interacts with the underlying 
(|android.content.ContentProvider|) method of the provider associated with the 
given URI, to retrieve retrieve any appropriate data stream for the data stored 
there. 

Unlike (|android.content.ContentResolver|) , this function only works with 
"content:" URIs, because content providers are the only facility with an 
associated MIME type to ensure that the returned data stream is of the desired 
type. 

All text/* streams are encoded in UTF-8. 


    uri - The desired URI to open. 
    mimeType - The desired MIME type of the returned data. This can be a pattern such as *\/*, 
       which will allow the content provider to select a type, though there is 
       no way for you to determine what type it is returning. 
    opts - Additional provider-dependent options. 
    cancellationSignal - A signal to cancel the operation in progress, or null if none. If the operation 
       is canceled, then {@link OperationCanceledException} will be thrown. 

    Returns: Returns a new ParcelFileDescriptor from which you can read the data stream from 
             the provider. Note that this may be a pipe, meaning you can't seek 
             in it. The only seek you should do is if the AssetFileDescriptor 
             contains an offset, to move to that offset before reading. You own 
             this descriptor and are responsible for closing it when done. 

*android.content.ContentResolver.query(Uri,String[],String,String[],String)*

public final |android.database.Cursor| query(
  android.net.Uri uri,
  java.lang.String[] projection,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String sortOrder)

Query the given URI, returning a (|android.database.Cursor|) over the result 
set. 

For best performance, the caller should follow these guidelines: 

Provide an explicit projection, to prevent reading data from storage that 
aren't going to be used. Use question mark parameter markers such as 'phone=?' 
instead of explicit values in theselectionparameter, so that queries that 
differ only by those values will be recognized as the same for caching 
purposes. 




    uri - The URI, using the content:// scheme, for the content to retrieve. 
    projection - A list of which columns to return. Passing null will return all columns, which 
       is inefficient. 
    selection - A filter declaring which rows to return, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). Passing null will return all rows for the 
       given URI. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in the order that they appear in the selection. The 
       values will be bound as Strings. 
    sortOrder - How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER 
       BY itself). Passing null will use the default sort order, which may be 
       unordered. 

    Returns: A Cursor object, which is positioned before the first entry, or null 

*android.content.ContentResolver.query(Uri,String[],String,String[],String,CancellationSignal)*

public final |android.database.Cursor| query(
  android.net.Uri uri,
  java.lang.String[] projection,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String sortOrder,
  android.os.CancellationSignal cancellationSignal)

Query the given URI, returning a (|android.database.Cursor|) over the result 
set. 

For best performance, the caller should follow these guidelines: 

Provide an explicit projection, to prevent reading data from storage that 
aren't going to be used. Use question mark parameter markers such as 'phone=?' 
instead of explicit values in theselectionparameter, so that queries that 
differ only by those values will be recognized as the same for caching 
purposes. 




    uri - The URI, using the content:// scheme, for the content to retrieve. 
    projection - A list of which columns to return. Passing null will return all columns, which 
       is inefficient. 
    selection - A filter declaring which rows to return, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). Passing null will return all rows for the 
       given URI. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in the order that they appear in the selection. The 
       values will be bound as Strings. 
    sortOrder - How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER 
       BY itself). Passing null will use the default sort order, which may be 
       unordered. 
    cancellationSignal - A signal to cancel the operation in progress, or null if none. If the operation 
       is canceled, then {@link OperationCanceledException} will be thrown when 
       the query is executed. 

    Returns: A Cursor object, which is positioned before the first entry, or null 

*android.content.ContentResolver.registerContentObserver(Uri,boolean,ContentObserver)*

public final void registerContentObserver(
  android.net.Uri uri,
  boolean notifyForDescendents,
  android.database.ContentObserver observer)

Register an observer class that gets callbacks when data identified by a given 
content URI changes. 


    uri - The URI to watch for changes. This can be a specific row URI, or a base URI for 
       a whole class of content. 
    notifyForDescendents - If true changes to URIs beginning with uri will also cause notifications to be 
       sent. If false only changes to the exact URI specified by uri will cause 
       notifications to be sent. If true, than any URI values at or below the 
       specified URI will also trigger a match. 
    observer - The object that receives callbacks when changes occur. 

*android.content.ContentResolver.registerContentObserver(Uri,boolean,ContentObserver,int)*

public final void registerContentObserver(
  android.net.Uri uri,
  boolean notifyForDescendents,
  android.database.ContentObserver observer,
  int userHandle)





*android.content.ContentResolver.releasePersistableUriPermission(Uri,int)*

public void releasePersistableUriPermission(
  android.net.Uri uri,
  int modeFlags)

Relinquish a persisted URI permission grant. The URI must have been previously 
made persistent with (|android.content.ContentResolver|) . Any non-persistent 
grants to the calling package will remain intact. 



*android.content.ContentResolver.releaseProvider(IContentProvider)*

public abstract boolean releaseProvider(android.content.IContentProvider icp)





*android.content.ContentResolver.releaseUnstableProvider(IContentProvider)*

public abstract boolean releaseUnstableProvider(android.content.IContentProvider icp)





*android.content.ContentResolver.removePeriodicSync(Account,String,Bundle)*

public static void removePeriodicSync(
  android.accounts.Account account,
  java.lang.String authority,
  android.os.Bundle extras)

Remove a periodic sync. Has no affect if account, authority and extras don't 
match an existing periodic sync. This method requires the caller to hold the 
permission (|android.Manifest.permission|) . 


    account - the account of the periodic sync to remove 
    authority - the provider of the periodic sync to remove 
    extras - the extras of the periodic sync to remove 

*android.content.ContentResolver.removeStatusChangeListener(Object)*

public static void removeStatusChangeListener(java.lang.Object handle)

Remove a previously registered status change listener. 


    handle - the handle that was returned by {@link #addStatusChangeListener} 

*android.content.ContentResolver.requestSync(Account,String,Bundle)*

public static void requestSync(
  android.accounts.Account account,
  java.lang.String authority,
  android.os.Bundle extras)

Start an asynchronous sync operation. If you want to monitor the progress of 
the sync you may register a SyncObserver. Only values of the following types 
may be used in the extras bundle: 

Integer Long Boolean Float Double String Account null 


    account - which account should be synced 
    authority - which authority should be synced 
    extras - any extras to pass to the SyncAdapter. 

*android.content.ContentResolver.requestSync(SyncRequest)*

public static void requestSync(android.content.SyncRequest request)

Register a sync with the SyncManager. These requests are built using the 
(|android.content.SyncRequest.Builder|) . 


    request - The immutable SyncRequest object containing the sync parameters. Use {@link 
       SyncRequest.Builder} to construct these. 

*android.content.ContentResolver.setIsSyncable(Account,String,int)*

public static void setIsSyncable(
  android.accounts.Account account,
  java.lang.String authority,
  int syncable)

Set whether this account/provider is syncable. This method requires the caller 
to hold the permission (|android.Manifest.permission|) . 


    syncable - >0 denotes syncable, 0 means not syncable, <0 means unknown 

*android.content.ContentResolver.setMasterSyncAutomatically(boolean)*

public static void setMasterSyncAutomatically(boolean sync)

Sets the master auto-sync setting that applies to all the providers and 
accounts. If this is false then the per-provider auto-sync setting is ignored. 
This method requires the caller to hold the permission 
(|android.Manifest.permission|) . 


    sync - the master auto-sync setting that applies to all the providers and accounts 

*android.content.ContentResolver.setSyncAutomatically(Account,String,boolean)*

public static void setSyncAutomatically(
  android.accounts.Account account,
  java.lang.String authority,
  boolean sync)

Set whether or not the provider is synced when it receives a network tickle. 
This method requires the caller to hold the permission 
(|android.Manifest.permission|) . 


    account - the account whose setting we are querying 
    authority - the provider whose behavior is being controlled 
    sync - true if the provider should be synced when tickles are received for it 

*android.content.ContentResolver.startSync(Uri,Bundle)*

public void startSync(
  android.net.Uri uri,
  android.os.Bundle extras)

Start an asynchronous sync operation. If you want to monitor the progress of 
the sync you may register a SyncObserver. Only values of the following types 
may be used in the extras bundle: 

Integer Long Boolean Float Double String Account null 

    Deprecated: instead use
 {@link #requestSync(android.accounts.Account, String, android.os.Bundle)}

    uri - the uri of the provider to sync or null to sync all providers. 
    extras - any extras to pass to the SyncAdapter. 

*android.content.ContentResolver.syncErrorStringToInt(String)*

public static int syncErrorStringToInt(java.lang.String error)





*android.content.ContentResolver.syncErrorToString(int)*

public static |java.lang.String| syncErrorToString(int error)





*android.content.ContentResolver.takePersistableUriPermission(Uri,int)*

public void takePersistableUriPermission(
  android.net.Uri uri,
  int modeFlags)

Take a persistable URI permission grant that has been offered. Once taken, the 
permission grant will be remembered across device reboots. Only URI permissions 
granted with (|android.content.Intent|) can be persisted. If the grant has 
already been persisted, taking it again will touch 
(|android.content.UriPermission|) . 



*android.content.ContentResolver.uncanonicalize(Uri)*

public final |android.net.Uri| uncanonicalize(android.net.Uri url)

Given a canonical Uri previously generated by 
(|android.content.ContentResolver|) , convert it to its local non-canonical 
form. This can be useful in some cases where you know that you will only be 
using the Uri in the current environment and want to avoid any possible 
overhead when using it with the content provider or want to verify that the 
referenced data exists at all in the new environment. 


    url - The canonical {@link Uri} that is to be convered back to its non-canonical 
       form. 

    Returns: Returns the non-canonical representation of url. This will return null if data 
             identified by the canonical Uri can not be found in the current 
             environment; callers must always check for null and deal with that 
             by appropriately falling back to an alternative. 

*android.content.ContentResolver.unregisterContentObserver(ContentObserver)*

public final void unregisterContentObserver(android.database.ContentObserver observer)

Unregisters a change observer. 


    observer - The previously registered observer that is no longer needed. 

*android.content.ContentResolver.unstableProviderDied(IContentProvider)*

public abstract void unstableProviderDied(android.content.IContentProvider icp)





*android.content.ContentResolver.update(Uri,ContentValues,String,String[])*

public final int update(
  android.net.Uri uri,
  android.content.ContentValues values,
  java.lang.String where,
  java.lang.String[] selectionArgs)

Update row(s) in a content URI. 

If the content provider supports transactions the update will be atomic. 


    uri - The URI to modify. 
    values - The new field values. The key is the column name for the field. A null value 
       will remove an existing field value. 
    where - A filter to apply to rows before updating, formatted as an SQL WHERE clause 
       (excluding the WHERE itself). 

    Returns: the number of rows updated. 

*android.content.ContentResolver.validateSyncExtrasBundle(Bundle)*

public static void validateSyncExtrasBundle(android.os.Bundle extras)

Check that only values of the following types are in the Bundle: 

Integer Long Boolean Float Double String Account null 


    extras - the Bundle to check 


