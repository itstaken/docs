*android.app.Activity* *Activity* An activity is a single, focused thing that th

public class Activity
  extends    |android.view.ContextThemeWrapper|
  implements |android.view.LayoutInflater.Factory2|
             |android.view.Window.Callback|
             |android.view.KeyEvent.Callback|
             |android.view.View.OnCreateContextMenuListener|
             |android.content.ComponentCallbacks2|

|android.app.Activity_Description|
|android.app.Activity_Fields|
|android.app.Activity_Constructors|
|android.app.Activity_Methods|

================================================================================

*android.app.Activity_Fields*
|int_android.app.Activity.DEFAULT_KEYS_DIALER|
|int_android.app.Activity.DEFAULT_KEYS_DISABLE|
|int_android.app.Activity.DEFAULT_KEYS_SEARCH_GLOBAL|
|int_android.app.Activity.DEFAULT_KEYS_SEARCH_LOCAL|
|int_android.app.Activity.DEFAULT_KEYS_SHORTCUT|
|int[]_android.app.Activity.FOCUSED_STATE_SET|
|int_android.app.Activity.RESULT_CANCELED|
|int_android.app.Activity.RESULT_FIRST_USER|
|int_android.app.Activity.RESULT_OK|

*android.app.Activity_Constructors*
|android.app.Activity()|

*android.app.Activity_Methods*
|android.app.Activity.addContentView(View,ViewGroup.LayoutParams)|Add an additi
|android.app.Activity.closeContextMenu()|Programmatically closes the most recen
|android.app.Activity.closeOptionsMenu()|Progammatically closes the options men
|android.app.Activity.convertFromTranslucent()|Convert a translucent themed Act
|android.app.Activity.convertToTranslucent(Activity.TranslucentConversionListener)|
|android.app.Activity.createPendingResult(int,Intent,int)|Create a new PendingI
|android.app.Activity.dismissDialog(int)|Dismiss a dialog that was previously s
|android.app.Activity.dispatchGenericMotionEvent(MotionEvent)|Called to process
|android.app.Activity.dispatchKeyEvent(KeyEvent)|Called to process key events.
|android.app.Activity.dispatchKeyShortcutEvent(KeyEvent)|Called to process a ke
|android.app.Activity.dispatchPopulateAccessibilityEvent(AccessibilityEvent)|
|android.app.Activity.dispatchTouchEvent(MotionEvent)|Called to process touch s
|android.app.Activity.dispatchTrackballEvent(MotionEvent)|Called to process tra
|android.app.Activity.dump(String,FileDescriptor,PrintWriter,String[])|Print th
|android.app.Activity.findViewById(int)|Finds a view that was identified by the
|android.app.Activity.finish()|Call this when your activity is done and should 
|android.app.Activity.finishActivity(int)|Force finish another activity that yo
|android.app.Activity.finishActivityFromChild(Activity,int)|This is called when
|android.app.Activity.finishAffinity()|Finish this activity as well as all acti
|android.app.Activity.finishFromChild(Activity)|This is called when a child act
|android.app.Activity.getActionBar()|Retrieve a reference to this activity's Ac
|android.app.Activity.getActivityToken()|
|android.app.Activity.getApplication()|Return the application that owns this ac
|android.app.Activity.getCallingActivity()|Return the name of the activity that
|android.app.Activity.getCallingPackage()|Return the name of the package that i
|android.app.Activity.getChangingConfigurations()|If this activity is being des
|android.app.Activity.getComponentName()|Returns complete component name of thi
|android.app.Activity.getCurrentFocus()|Callsandroid.view.Window#getCurrentFocu
|android.app.Activity.getFragmentManager()|Return the FragmentManager for inter
|android.app.Activity.getIntent()|Return the intent that started this activity.
|android.app.Activity.getLastNonConfigurationInstance()|Retrieve the non-config
|android.app.Activity.getLayoutInflater()|Convenience for callingandroid.view.W
|android.app.Activity.getLoaderManager()|Return the LoaderManager for this frag
|android.app.Activity.getLocalClassName()|Returns class name for this activity 
|android.app.Activity.getMenuInflater()|Returns aMenuInflaterwith this context.
|android.app.Activity.getParent()|Return the parent activity if this view is an
|android.app.Activity.getParentActivityIntent()|Obtain anIntentthat will launch
|android.app.Activity.getPreferences(int)|Retrieve aSharedPreferencesobject for
|android.app.Activity.getRequestedOrientation()|Return the current requested or
|android.app.Activity.getSystemService(String)|
|android.app.Activity.getTaskId()|Return the identifier of the task this activi
|android.app.Activity.getTitle()|
|android.app.Activity.getTitleColor()|
|android.app.Activity.getVolumeControlStream()|Gets the suggested audio stream 
|android.app.Activity.getWindow()|Retrieve the currentandroid.view.Windowfor th
|android.app.Activity.getWindowManager()|Retrieve the window manager for showin
|android.app.Activity.hasWindowFocus()|Returns true if this activity's main win
|android.app.Activity.invalidateOptionsMenu()|Declare that the options menu has
|android.app.Activity.isChangingConfigurations()|Check to see whether this acti
|android.app.Activity.isChild()|Is this activity embedded inside of another act
|android.app.Activity.isDestroyed()|Returns true if the final#onDestroy()call h
|android.app.Activity.isFinishing()|Check to see whether this activity is in th
|android.app.Activity.isImmersive()|Bit indicating that this activity is "immer
|android.app.Activity.isResumed()|
|android.app.Activity.isTaskRoot()|Return whether this activity is the root of 
|android.app.Activity.managedQuery(Uri,String[],String,String)|Wrapper aroundCo
|android.app.Activity.managedQuery(Uri,String[],String,String[],String)|Wrapper
|android.app.Activity.moveTaskToBack(boolean)|Move the task containing this act
|android.app.Activity.navigateUpTo(Intent)|Navigate from this activity to the a
|android.app.Activity.navigateUpToFromChild(Activity,Intent)|This is called whe
|android.app.Activity.onActionModeFinished(ActionMode)|Notifies the activity th
|android.app.Activity.onActionModeStarted(ActionMode)|Notifies the Activity tha
|android.app.Activity.onActivityResult(int,int,Intent)|Called when an activity 
|android.app.Activity.onApplyThemeResource(Resources.Theme,int,boolean)|
|android.app.Activity.onAttachedToWindow()|Called when the main window associat
|android.app.Activity.onAttachFragment(Fragment)|Called when a Fragment is bein
|android.app.Activity.onBackPressed()|Called when the activity has detected the
|android.app.Activity.onChildTitleChanged(Activity,CharSequence)|
|android.app.Activity.onConfigurationChanged(Configuration)|Called by the syste
|android.app.Activity.onContentChanged()|
|android.app.Activity.onContextItemSelected(MenuItem)|This hook is called whene
|android.app.Activity.onContextMenuClosed(Menu)|This hook is called whenever th
|android.app.Activity.onCreate(Bundle)|Called when the activity is starting.
|android.app.Activity.onCreateContextMenu(ContextMenu,View,ContextMenu.ContextMenuInfo)|
|android.app.Activity.onCreateDescription()|Generate a new description for this
|android.app.Activity.onCreateDialog(int)|
|android.app.Activity.onCreateDialog(int,Bundle)|Callback for creating dialogs 
|android.app.Activity.onCreateNavigateUpTaskStack(TaskStackBuilder)|Define the 
|android.app.Activity.onCreateOptionsMenu(Menu)|Initialize the contents of the 
|android.app.Activity.onCreatePanelMenu(int,Menu)|Default implementation ofandr
|android.app.Activity.onCreatePanelView(int)|Default implementation ofandroid.v
|android.app.Activity.onCreateThumbnail(Bitmap,Canvas)|Generate a new thumbnail
|android.app.Activity.onCreateView(String,Context,AttributeSet)|Standard implem
|android.app.Activity.onCreateView(View,String,Context,AttributeSet)|Standard i
|android.app.Activity.onDestroy()|Perform any final cleanup before an activity 
|android.app.Activity.onDetachedFromWindow()|Called when the main window associ
|android.app.Activity.onGenericMotionEvent(MotionEvent)|Called when a generic m
|android.app.Activity.onKeyDown(int,KeyEvent)|Called when a key was pressed dow
|android.app.Activity.onKeyLongPress(int,KeyEvent)|Default implementation ofKey
|android.app.Activity.onKeyMultiple(int,int,KeyEvent)|Default implementation of
|android.app.Activity.onKeyShortcut(int,KeyEvent)|Called when a key shortcut ev
|android.app.Activity.onKeyUp(int,KeyEvent)|Called when a key was released and 
|android.app.Activity.onLowMemory()|
|android.app.Activity.onMenuItemSelected(int,MenuItem)|Default implementation o
|android.app.Activity.onMenuOpened(int,Menu)|
|android.app.Activity.onNavigateUp()|This method is called whenever the user ch
|android.app.Activity.onNavigateUpFromChild(Activity)|This is called when a chi
|android.app.Activity.onNewIntent(Intent)|This is called for activities that se
|android.app.Activity.onOptionsItemSelected(MenuItem)|This hook is called whene
|android.app.Activity.onOptionsMenuClosed(Menu)|This hook is called whenever th
|android.app.Activity.onPanelClosed(int,Menu)|Default implementation ofandroid.
|android.app.Activity.onPause()|Called as part of the activity lifecycle when a
|android.app.Activity.onPostCreate(Bundle)|Called when activity start-up is com
|android.app.Activity.onPostResume()|Called when activity resume is complete (a
|android.app.Activity.onPrepareDialog(int,Dialog)|
|android.app.Activity.onPrepareDialog(int,Dialog,Bundle)|Provides an opportunit
|android.app.Activity.onPrepareNavigateUpTaskStack(TaskStackBuilder)|Prepare th
|android.app.Activity.onPrepareOptionsMenu(Menu)|Prepare the Screen's standard 
|android.app.Activity.onPreparePanel(int,View,Menu)|Default implementation ofan
|android.app.Activity.onProvideAssistData(Bundle)|This is called when the user 
|android.app.Activity.onRestart()|Called after#onStopwhen the current activity 
|android.app.Activity.onRestoreInstanceState(Bundle)|This method is called afte
|android.app.Activity.onResume()|Called after#onRestoreInstanceState,#onRestart
|android.app.Activity.onRetainNonConfigurationInstance()|Called by the system, 
|android.app.Activity.onSaveInstanceState(Bundle)|Called to retrieve per-instan
|android.app.Activity.onSearchRequested()|This hook is called when the user sig
|android.app.Activity.onStart()|Called after#onCreate or after#onRestartwhen   
|android.app.Activity.onStop()|Called when you are no longer visible to the use
|android.app.Activity.onTitleChanged(CharSequence,int)|
|android.app.Activity.onTouchEvent(MotionEvent)|Called when a touch screen even
|android.app.Activity.onTrackballEvent(MotionEvent)|Called when the trackball w
|android.app.Activity.onTrimMemory(int)|
|android.app.Activity.onUserInteraction()|Called whenever a key, touch, or trac
|android.app.Activity.onUserLeaveHint()|Called as part of the activity lifecycl
|android.app.Activity.onWindowAttributesChanged(WindowManager.LayoutParams)|
|android.app.Activity.onWindowFocusChanged(boolean)|Called when the currentWind
|android.app.Activity.onWindowStartingActionMode(ActionMode.Callback)|Give the 
|android.app.Activity.openContextMenu(View)|Programmatically opens the context 
|android.app.Activity.openOptionsMenu()|Programmatically opens the options menu
|android.app.Activity.overridePendingTransition(int,int)|Call immediately after
|android.app.Activity.recreate()|Cause this Activity to be recreated with a new
|android.app.Activity.registerForContextMenu(View)|Registers a context menu to 
|android.app.Activity.removeDialog(int)|Removes any internal references to a di
|android.app.Activity.reportFullyDrawn()|Report to the system that your app is 
|android.app.Activity.requestWindowFeature(int)|Enable extended window features
|android.app.Activity.runOnUiThread(Runnable)|Runs the specified action on the 
|android.app.Activity.setContentView(int)|Set the activity content from a layou
|android.app.Activity.setContentView(View)|Set the activity content to an expli
|android.app.Activity.setContentView(View,ViewGroup.LayoutParams)|Set the activ
|android.app.Activity.setDefaultKeyMode(int)|Select the default key handling fo
|android.app.Activity.setFeatureDrawable(int,Drawable)|Convenience for callinga
|android.app.Activity.setFeatureDrawableAlpha(int,int)|Convenience for callinga
|android.app.Activity.setFeatureDrawableResource(int,int)|Convenience for calli
|android.app.Activity.setFeatureDrawableUri(int,Uri)|Convenience for callingand
|android.app.Activity.setFinishOnTouchOutside(boolean)|Sets whether this activi
|android.app.Activity.setImmersive(boolean)|Adjust the current immersive mode s
|android.app.Activity.setIntent(Intent)|Change the intent returned by#getIntent
|android.app.Activity.setPersistent(boolean)|
|android.app.Activity.setProgress(int)|Sets the progress for the progress bars 
|android.app.Activity.setProgressBarIndeterminate(boolean)|Sets whether the hor
|android.app.Activity.setProgressBarIndeterminateVisibility(boolean)|Sets the v
|android.app.Activity.setProgressBarVisibility(boolean)|Sets the visibility of 
|android.app.Activity.setRequestedOrientation(int)|Change the desired orientati
|android.app.Activity.setResult(int)|Call this to set the result that your acti
|android.app.Activity.setResult(int,Intent)|Call this to set the result that yo
|android.app.Activity.setSecondaryProgress(int)|Sets the secondary progress for
|android.app.Activity.setTitle(CharSequence)|Change the title associated with t
|android.app.Activity.setTitle(int)|Change the title associated with this activ
|android.app.Activity.setTitleColor(int)|
|android.app.Activity.setVisible(boolean)|Control whether this activity's main 
|android.app.Activity.setVolumeControlStream(int)|Suggests an audio stream whos
|android.app.Activity.shouldUpRecreateTask(Intent)|Returns true if the app shou
|android.app.Activity.showDialog(int)|Simple version of#showDialog(int, Bundle)
|android.app.Activity.showDialog(int,Bundle)|Show a dialog managed by this acti
|android.app.Activity.startActionMode(ActionMode.Callback)|Start an action mode
|android.app.Activity.startActivities(Intent[])|Same as#startActivities(Intent[
|android.app.Activity.startActivities(Intent[],Bundle)|Launch a new activity.
|android.app.Activity.startActivity(Intent)|Same as#startActivity(Intent, Bundl
|android.app.Activity.startActivity(Intent,Bundle)|Launch a new activity.
|android.app.Activity.startActivityAsUser(Intent,Bundle,UserHandle)|
|android.app.Activity.startActivityAsUser(Intent,UserHandle)|
|android.app.Activity.startActivityForResult(Intent,int)|Same as calling#startA
|android.app.Activity.startActivityForResult(Intent,int,Bundle)|Launch an activ
|android.app.Activity.startActivityFromChild(Activity,Intent,int)|Same as calli
|android.app.Activity.startActivityFromChild(Activity,Intent,int,Bundle)|This i
|android.app.Activity.startActivityFromFragment(Fragment,Intent,int)|Same as ca
|android.app.Activity.startActivityFromFragment(Fragment,Intent,int,Bundle)|Thi
|android.app.Activity.startActivityIfNeeded(Intent,int)|Same as calling#startAc
|android.app.Activity.startActivityIfNeeded(Intent,int,Bundle)|A special variat
|android.app.Activity.startIntentSender(IntentSender,Intent,int,int,int)|Same a
|android.app.Activity.startIntentSender(IntentSender,Intent,int,int,int,Bundle)|
|android.app.Activity.startIntentSenderForResult(IntentSender,int,Intent,int,int,int)|
|android.app.Activity.startIntentSenderForResult(IntentSender,int,Intent,int,int,int,Bundle)|
|android.app.Activity.startIntentSenderFromChild(Activity,IntentSender,int,Intent,int,int,int)|
|android.app.Activity.startIntentSenderFromChild(Activity,IntentSender,int,Intent,int,int,int,Bundle)|
|android.app.Activity.startManagingCursor(Cursor)|This method allows the activi
|android.app.Activity.startNextMatchingActivity(Intent)|Same as calling#startNe
|android.app.Activity.startNextMatchingActivity(Intent,Bundle)|Special version 
|android.app.Activity.startSearch(String,boolean,Bundle,boolean)|This hook is c
|android.app.Activity.stopManagingCursor(Cursor)|Given a Cursor that was previo
|android.app.Activity.takeKeyEvents(boolean)|Request that key events come to th
|android.app.Activity.triggerSearch(String,Bundle)|Similar to#startSearch, but 
|android.app.Activity.unregisterForContextMenu(View)|Prevents a context menu to

*android.app.Activity_Description*

An activity is a single, focused thing that the user can do. Almost all 
activities interact with the user, so the Activity class takes care of creating 
a window for you in which you can place your UI with (|android.app.Activity|) . 
While activities are often presented to the user as full-screen windows, they 
can also be used in other ways: as floating windows (via a theme with 
(|android.R.attr|) set) or embedded inside of another activity (using 
(|android.app.ActivityGroup|) ). 

There are two methods almost all subclasses of Activity will implement: 

(|android.app.Activity|) is where you initialize your activity. Most 
importantly, here you will usually call (|android.app.Activity|) with a layout 
resource defining your UI, and using (|android.app.Activity|) to retrieve the 
widgets in that UI that you need to interact with programmatically. 

(|android.app.Activity|) is where you deal with the user leaving your activity. 
Most importantly, any changes made by the user should at this point be 
committed (usually to the (|android.content.ContentProvider|) holding the 
data). 

To be of use with Context.startActivity()(|android.content.Context|) , all 
activity classes must have a corresponding 
&lt;activity&gt;(|android.R.styleable|) declaration in their package's 
AndroidManifest.xml. 

Topics covered here: 

Fragments Activity Lifecycle Configuration Changes Starting Activities and 
Getting Results Saving Persistent State Permissions Process Lifecycle 

Developer Guides The Activity class is an important part of an application's 
overall lifecycle, and the way activities are launched and put together is a 
fundamental part of the platform's application model. For a detailed 
perspective on the structure of an Android application and how activities 
behave, please read the <a href="guide/topics/fundamentals.html">Application 
Fundamentals and <a 
href="guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back Stack 
developer guides. 

You can also find a detailed discussion about how to create activities in the 
<a href="guide/topics/fundamentals/activities.html">Activities developer guide. 

Fragments 

Starting with (|android.os.Build.VERSION_CODES|) , Activity implementations can 
make use of the (|android.app.Fragment|) class to better modularize their code, 
build more sophisticated user interfaces for larger screens, and help scale 
their application between small and large screens. 

Activity Lifecycle 

Activities in the system are managed as an activity stack. When a new activity 
is started, it is placed on the top of the stack and becomes the running 
activity -- the previous activity always remains below it in the stack, and 
will not come to the foreground again until the new activity exits. 

An activity has essentially four states: 

If an activity in the foreground of the screen (at the top of the stack), it is 
active or running. If an activity has lost focus but is still visible (that is, 
a new non-full-sized or transparent activity has focus on top of your 
activity), it is paused. A paused activity is completely alive (it maintains 
all state and member information and remains attached to the window manager), 
but can be killed by the system in extreme low memory situations. If an 
activity is completely obscured by another activity, it is stopped. It still 
retains all state and member information, however, it is no longer visible to 
the user so its window is hidden and it will often be killed by the system when 
memory is needed elsewhere. If an activity is paused or stopped, the system can 
drop the activity from memory by either asking it to finish, or simply killing 
its process. When it is displayed again to the user, it must be completely 
restarted and restored to its previous state. 

The following diagram shows the important state paths of an Activity. The 
square rectangles represent callback methods you can implement to perform 
operations when the Activity moves between states. The colored ovals are major 
states the Activity can be in. 



There are three key loops you may be interested in monitoring within your 
activity: 

The entire lifetime of an activity happens between the first call to 
(|android.app.Activity|) through to a single final call to 
(|android.app.Activity|) . An activity will do all setup of "global" state in 
onCreate(), and release all remaining resources in onDestroy(). For example, if 
it has a thread running in the background to download data from the network, it 
may create that thread in onCreate() and then stop the thread in onDestroy(). 

The visible lifetime of an activity happens between a call to 
(|android.app.Activity|) until a corresponding call to (|android.app.Activity|) 
. During this time the user can see the activity on-screen, though it may not 
be in the foreground and interacting with the user. Between these two methods 
you can maintain resources that are needed to show the activity to the user. 
For example, you can register a (|android.content.BroadcastReceiver|) in 
onStart() to monitor for changes that impact your UI, and unregister it in 
onStop() when the user no longer sees what you are displaying. The onStart() 
and onStop() methods can be called multiple times, as the activity becomes 
visible and hidden to the user. 

The foreground lifetime of an activity happens between a call to 
(|android.app.Activity|) until a corresponding call to (|android.app.Activity|) 
. During this time the activity is in front of all other activities and 
interacting with the user. An activity can frequently go between the resumed 
and paused states -- for example when the device goes to sleep, when an 
activity result is delivered, when a new intent is delivered -- so the code in 
these methods should be fairly lightweight. 

The entire lifecycle of an activity is defined by the following Activity 
methods. All of these are hooks that you can override to do appropriate work 
when the activity changes state. All activities will implement 
(|android.app.Activity|) to do their initial setup; many will also implement 
(|android.app.Activity|) to commit changes to data and otherwise prepare to 
stop interacting with the user. You should always call up to your superclass 
when implementing these methods. 



public class Activity extends ApplicationContext { protected void 
onCreate(Bundle savedInstanceState); 

protected void onStart(); 

protected void onRestart(); 

protected void onResume(); 

protected void onPause(); 

protected void onStop(); 

protected void onDestroy(); } 

In general the movement through an activity's lifecycle looks like this: 







Method Description Killable? Next 

onCreate()(|android.app.Activity|) Called when the activity is first created. 
This is where you should do all of your normal static set up: create views, 
bind data to lists, etc. This method also provides you with a Bundle containing 
the activity's previously frozen state, if there was one. Always followed by 
onStart(). No onStart() 

onRestart()(|android.app.Activity|) Called after your activity has been 
stopped, prior to it being started again. Always followed by onStart() No 
onStart() 

onStart()(|android.app.Activity|) Called when the activity is becoming visible 
to the user. Followed by onResume() if the activity comes to the foreground, or 
onStop() if it becomes hidden. No onResume() or onStop() 

onResume()(|android.app.Activity|) Called when the activity will start 
interacting with the user. At this point your activity is at the top of the 
activity stack, with user input going to it. Always followed by onPause(). No 
onPause() 

onPause()(|android.app.Activity|) Called when the system is about to start 
resuming a previous activity. This is typically used to commit unsaved changes 
to persistent data, stop animations and other things that may be consuming CPU, 
etc. Implementations of this method must be very quick because the next 
activity will not be resumed until this method returns. Followed by either 
onResume() if the activity returns back to the front, or onStop() if it becomes 
invisible to the user. Pre- (|android.os.Build.VERSION_CODES|) onResume() or 
onStop() 

onStop()(|android.app.Activity|) Called when the activity is no longer visible 
to the user, because another activity has been resumed and is covering this 
one. This may happen either because a new activity is being started, an 
existing one is being brought in front of this one, or this one is being 
destroyed. Followed by either onRestart() if this activity is coming back to 
interact with the user, or onDestroy() if this activity is going away. Yes 
onRestart() or onDestroy() 

onDestroy()(|android.app.Activity|) The final call you receive before your 
activity is destroyed. This can happen either because the activity is finishing 
(someone called (|android.app.Activity|) on it, or because the system is 
temporarily destroying this instance of the activity to save space. You can 
distinguish between these two scenarios with the (|android.app.Activity|) 
method. Yes nothing 



Note the "Killable" column in the above table -- for those methods that are 
marked as being killable, after that method returns the process hosting the 
activity may killed by the system at any time without another line of its code 
being executed. Because of this, you should use the (|android.app.Activity|) 
method to write any persistent data (such as user edits) to storage. In 
addition, the method (|android.app.Activity|) is called before placing the 
activity in such a background state, allowing you to save away any dynamic 
instance state in your activity into the given Bundle, to be later received in 
(|android.app.Activity|) if the activity needs to be re-created. See the 
Process Lifecycle section for more information on how the lifecycle of a 
process is tied to the activities it is hosting. Note that it is important to 
save persistent data in (|android.app.Activity|) instead of 
(|android.app.Activity|) because the latter is not part of the lifecycle 
callbacks, so will not be called in every situation as described in its 
documentation. 

Be aware that these semantics will change slightly between applications 
targeting platforms starting with (|android.os.Build.VERSION_CODES|) vs. those 
targeting prior platforms. Starting with Honeycomb, an application is not in 
the killable state until its (|android.app.Activity|) has returned. This 
impacts when (|android.app.Activity|) may be called (it may be safely called 
after (|android.app.Activity|) and allows and application to safely wait until 
(|android.app.Activity|) to save persistent state. 

For those methods that are not marked as being killable, the activity's process 
will not be killed by the system starting from the time the method is called 
and continuing after it returns. Thus an activity is in the killable state, for 
example, between after onPause() to the start of onResume(). 

Configuration Changes 

If the configuration of the device (as defined by the 
Resources.Configuration(|android.content.res.Configuration|) class) changes, 
then anything displaying a user interface will need to update to match that 
configuration. Because Activity is the primary mechanism for interacting with 
the user, it includes special support for handling configuration changes. 

Unless you specify otherwise, a configuration change (such as a change in 
screen orientation, language, input devices, etc) will cause your current 
activity to be destroyed, going through the normal activity lifecycle process 
of (|android.app.Activity|) , (|android.app.Activity|) , and 
(|android.app.Activity|) as appropriate. If the activity had been in the 
foreground or visible to the user, once (|android.app.Activity|) is called in 
that instance then a new instance of the activity will be created, with 
whatever savedInstanceState the previous instance had generated from 
(|android.app.Activity|) . 

This is done because any application resource, including layout files, can 
change based on any configuration value. Thus the only safe way to handle a 
configuration change is to re-retrieve all resources, including layouts, 
drawables, and strings. Because activities must already know how to save their 
state and re-create themselves from that state, this is a convenient way to 
have an activity restart itself with a new configuration. 

In some special cases, you may want to bypass restarting of your activity based 
on one or more types of configuration changes. This is done with the 
android:configChanges(|android.R.attr|) attribute in its manifest. For any 
types of configuration changes you say that you handle there, you will receive 
a call to your current activity's (|android.app.Activity|) method instead of 
being restarted. If a configuration change involves any that you do not handle, 
however, the activity will still be restarted and (|android.app.Activity|) will 
not be called. 

Starting Activities and Getting Results 

The (|android.app.Activity|) method is used to start a new activity, which will 
be placed at the top of the activity stack. It takes a single argument, an 
Intent(|android.content.Intent|) , which describes the activity to be executed. 

Sometimes you want to get a result back from an activity when it ends. For 
example, you may start an activity that lets the user pick a person in a list 
of contacts; when it ends, it returns the person that was selected. To do this, 
you call the (|android.app.Activity|) version with a second integer parameter 
identifying the call. The result will come back through your 
(|android.app.Activity|) method. 

When an activity exits, it can call (|android.app.Activity|) to return data 
back to its parent. It must always supply a result code, which can be the 
standard results RESULT_CANCELED, RESULT_OK, or any custom values starting at 
RESULT_FIRST_USER. In addition, it can optionally return back an Intent 
containing any additional data it wants. All of this information appears back 
on the parent's Activity.onActivityResult(), along with the integer identifier 
it originally supplied. 

If a child activity fails for any reason (such as crashing), the parent 
activity will receive a result with the code RESULT_CANCELED. 

public class MyActivity extends Activity { ... 

static final int PICK_CONTACT_REQUEST = 0; 

protected boolean onKeyDown(int keyCode, KeyEvent event) { if (keyCode == 
KeyEvent.KEYCODE_DPAD_CENTER) { // When the user center presses, let them pick 
a contact. startActivityForResult( new Intent(Intent.ACTION_PICK, new 
Uri("content://contacts")), PICK_CONTACT_REQUEST); return true; } return false; 
} 

protected void onActivityResult(int requestCode, int resultCode, Intent data) { 
if (requestCode == PICK_CONTACT_REQUEST) { if (resultCode == RESULT_OK) { // A 
contact was picked. Here we will just display it // to the user. 
startActivity(new Intent(Intent.ACTION_VIEW, data)); } } } } 

Saving Persistent State 

There are generally two kinds of persistent state than an activity will deal 
with: shared document-like data (typically stored in a SQLite database using a 
content provider(|android.content.ContentProvider|) ) and internal state such 
as user preferences. 

For content provider data, we suggest that activities use a "edit in place" 
user model. That is, any edits a user makes are effectively made immediately 
without requiring an additional confirmation step. Supporting this model is 
generally a simple matter of following two rules: 

When creating a new document, the backing database entry or file for it is 
created immediately. For example, if the user chooses to write a new e-mail, a 
new entry for that e-mail is created as soon as they start entering data, so 
that if they go to any other activity after that point this e-mail will now 
appear in the list of drafts. When an activity's onPause() method is called, it 
should commit to the backing content provider or file any changes the user has 
made. This ensures that those changes will be seen by any other activity that 
is about to run. You will probably want to commit your data even more 
aggressively at key times during your activity's lifecycle: for example before 
starting a new activity, before finishing your own activity, when the user 
switches between input fields, etc. 

This model is designed to prevent data loss when a user is navigating between 
activities, and allows the system to safely kill an activity (because system 
resources are needed somewhere else) at any time after it has been paused. Note 
this implies that the user pressing BACK from your activity does not mean 
"cancel" -- it means to leave the activity with its current contents saved 
away. Canceling edits in an activity must be provided through some other 
mechanism, such as an explicit "revert" or "undo" option. 

See the content package(|android.content.ContentProvider|) for more information 
about content providers. These are a key aspect of how different activities 
invoke and propagate data between themselves. 

The Activity class also provides an API for managing internal persistent state 
associated with an activity. This can be used, for example, to remember the 
user's preferred initial display in a calendar (day view or week view) or the 
user's default home page in a web browser. 

Activity persistent state is managed with the method (|android.app.Activity|) , 
allowing you to retrieve and modify a set of name/value pairs associated with 
the activity. To use preferences that are shared across multiple application 
components (activities, receivers, services, providers), you can use the 
underlying Context.getSharedPreferences()(|android.content.Context|) method to 
retrieve a preferences object stored under a specific name. (Note that it is 
not possible to share settings data across application packages -- for that you 
will need a content provider.) 

Here is an excerpt from a calendar activity that stores the user's preferred 
view mode in its persistent settings: 

public class CalendarActivity extends Activity { ... 

static final int DAY_VIEW_MODE = 0; static final int WEEK_VIEW_MODE = 1; 

private SharedPreferences mPrefs; private int mCurViewMode; 

protected void onCreate(Bundle savedInstanceState) { 
super.onCreate(savedInstanceState); 

SharedPreferences mPrefs = getSharedPreferences(); mCurViewMode = 
mPrefs.getInt("view_mode", DAY_VIEW_MODE); } 

protected void onPause() { super.onPause(); 

SharedPreferences.Editor ed = mPrefs.edit(); ed.putInt("view_mode", 
mCurViewMode); ed.commit(); } } 



Permissions 

The ability to start a particular Activity can be enforced when it is declared 
in its manifest's &lt;activity&gt;(|android.R.styleable|) tag. By doing so, 
other applications will need to declare a corresponding 
&lt;uses-permission&gt;(|android.R.styleable|) element in their own manifest to 
be able to start that activity. 

When starting an Activity you can set 
Intent.FLAG_GRANT_READ_URI_PERMISSION(|android.content.Intent|) and/or 
Intent.FLAG_GRANT_WRITE_URI_PERMISSION(|android.content.Intent|) on the Intent. 
This will grant the Activity access to the specific URIs in the Intent. Access 
will remain until the Activity has finished (it will remain across the hosting 
process being killed and other temporary destruction). As of 
(|android.os.Build.VERSION_CODES|) , if the Activity was already created and a 
new Intent is being delivered to (|android.app.Activity|) , any newly granted 
URI permissions will be added to the existing ones it holds. 

See the <a href="guide/topics/security/security.html">Security and Permissions 
document for more information on permissions and security in general. 

Process Lifecycle 

The Android system attempts to keep application process around for as long as 
possible, but eventually will need to remove old processes when memory runs 
low. As described in Activity Lifecycle, the decision about which process to 
remove is intimately tied to the state of the user's interaction with it. In 
general, there are four states a process can be in based on the activities 
running in it, listed here in order of importance. The system will kill less 
important processes (the last ones) before it resorts to killing more important 
processes (the first ones). 

The foreground activity (the activity at the top of the screen that the user is 
currently interacting with) is considered the most important. Its process will 
only be killed as a last resort, if it uses more memory than is available on 
the device. Generally at this point the device has reached a memory paging 
state, so this is required in order to keep the user interface responsive. A 
visible activity (an activity that is visible to the user but not in the 
foreground, such as one sitting behind a foreground dialog) is considered 
extremely important and will not be killed unless that is required to keep the 
foreground activity running. A background activity (an activity that is not 
visible to the user and has been paused) is no longer critical, so the system 
may safely kill its process to reclaim memory for other foreground or visible 
processes. If its process needs to be killed, when the user navigates back to 
the activity (making it visible on the screen again), its 
(|android.app.Activity|) method will be called with the savedInstanceState it 
had previously supplied in (|android.app.Activity|) so that it can restart 
itself in the same state as the user last left it. An empty process is one 
hosting no activities or other application components (such as 
(|android.app.Service|) or (|android.content.BroadcastReceiver|) classes). 
These are killed very quickly by the system as memory becomes low. For this 
reason, any background operation you do outside of an activity must be executed 
in the context of an activity BroadcastReceiver or Service to ensure that the 
system knows it needs to keep your process around. 

Sometimes an Activity may need to do a long-running operation that exists 
independently of the activity lifecycle itself. An example may be a camera 
application that allows you to upload a picture to a web site. The upload may 
take a long time, and the application should allow the user to leave the 
application will it is executing. To accomplish this, your Activity should 
start a (|android.app.Service|) in which the upload takes place. This allows 
the system to properly prioritize your process (considering it to be more 
important than other non-visible applications) for the duration of the upload, 
independent of whether the original activity is paused, stopped, or finished. 



*int_android.app.Activity.DEFAULT_KEYS_DIALER*

Use with (|android.app.Activity|) to launch the dialer during default key 
handling. 


*int_android.app.Activity.DEFAULT_KEYS_DISABLE*

Use with (|android.app.Activity|) to turn off default handling of keys. 


*int_android.app.Activity.DEFAULT_KEYS_SEARCH_GLOBAL*

Use with (|android.app.Activity|) to specify that unhandled keystrokes will 
start a global search (typically web search, but some platforms may define 
alternate methods for global search) 

See android.app.SearchManager(|android.app.SearchManager|) for more details. 


*int_android.app.Activity.DEFAULT_KEYS_SEARCH_LOCAL*

Use with (|android.app.Activity|) to specify that unhandled keystrokes will 
start an application-defined search. (If the application or activity does not 
actually define a search, the the keys will be ignored.) 

See android.app.SearchManager(|android.app.SearchManager|) for more details. 


*int_android.app.Activity.DEFAULT_KEYS_SHORTCUT*

Use with (|android.app.Activity|) to execute a menu shortcut in default key 
handling. 

That is, the user does not need to hold down the menu key to execute menu 
shortcuts. 


*int[]_android.app.Activity.FOCUSED_STATE_SET*




*int_android.app.Activity.RESULT_CANCELED*

Standard activity result: operation canceled. 


*int_android.app.Activity.RESULT_FIRST_USER*

Start of user-defined activity results. 


*int_android.app.Activity.RESULT_OK*

Standard activity result: operation succeeded. 



*android.app.Activity()*

public Activity()




*android.app.Activity.addContentView(View,ViewGroup.LayoutParams)*

public void addContentView(
  android.view.View view,
  android.view.ViewGroup.LayoutParams params)

Add an additional content view to the activity. Added after any existing ones 
in the activity -- existing views are NOT removed. 


    view - The desired content to display. 
    params - Layout parameters for the view. 

*android.app.Activity.closeContextMenu()*

public void closeContextMenu()

Programmatically closes the most recently opened context menu, if showing. 



*android.app.Activity.closeOptionsMenu()*

public void closeOptionsMenu()

Progammatically closes the options menu. If the options menu is already closed, 
this method does nothing. 



*android.app.Activity.convertFromTranslucent()*

public void convertFromTranslucent()

Convert a translucent themed Activity (|android.R.attr|) to a fullscreen opaque 
Activity. 

Call this whenever the background of a translucent Activity has changed to 
become opaque. Doing so will allow the (|android.view.Surface|) of the Activity 
behind to be released. 

This call has no effect on non-translucent activities or on activities with the 
(|android.R.attr|) attribute. 



*android.app.Activity.convertToTranslucent(Activity.TranslucentConversionListener)*

public void convertToTranslucent(android.app.Activity.TranslucentConversionListener callback)

Convert a translucent themed Activity (|android.R.attr|) back from opaque to 
translucent following a call to (|android.app.Activity|) . 

Calling this allows the Activity behind this one to be seen again. Once all 
such Activities have been redrawn 
(|android.app.Activity.TranslucentConversionListener|) will be called 
indicating that it is safe to make this activity translucent again. Until 
(|android.app.Activity.TranslucentConversionListener|) is called the image 
behind the frontmost Activity will be indeterminate. 

This call has no effect on non-translucent activities or on activities with the 
(|android.R.attr|) attribute. 


    callback - the method to call when all visible Activities behind this one have been drawn 
       and it is safe to make this Activity translucent again. 

*android.app.Activity.createPendingResult(int,Intent,int)*

public |android.app.PendingIntent| createPendingResult(
  int requestCode,
  android.content.Intent data,
  int flags)

Create a new PendingIntent object which you can hand to others for them to use 
to send result data back to your (|android.app.Activity|) callback. The created 
object will be either one-shot (becoming invalid after a result is sent back) 
or multiple (allowing any number of results to be sent through it). 


    requestCode - Private request code for the sender that will be associated with the result 
       data when it is returned. The sender can not modify this value, allowing 
       you to identify incoming results. 
    data - Default data to supply in the result, which may be modified by the sender. 
    flags - May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT}, {@link 
       PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE}, {@link 
       PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT}, 
       {@link PendingIntent#FLAG_UPDATE_CURRENT 
       PendingIntent.FLAG_UPDATE_CURRENT}, or any of the flags as supported by 
       {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts 
       of the intent that can be supplied when the actual send happens. 

    Returns: Returns an existing or new PendingIntent matching the given parameters. May 
             return null only if {@link PendingIntent#FLAG_NO_CREATE 
             PendingIntent.FLAG_NO_CREATE} has been supplied. 

*android.app.Activity.dismissDialog(int)*

public final void dismissDialog(int id)

Dismiss a dialog that was previously shown via (|android.app.Activity|) . 

    Deprecated: Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.

    id - The id of the managed dialog. 

*android.app.Activity.dispatchGenericMotionEvent(MotionEvent)*

public boolean dispatchGenericMotionEvent(android.view.MotionEvent ev)

Called to process generic motion events. You can override this to intercept all 
generic motion events before they are dispatched to the window. Be sure to call 
this implementation for generic motion events that should be handled normally. 


    ev - The generic motion event. 

    Returns: boolean Return true if this event was consumed. 

*android.app.Activity.dispatchKeyEvent(KeyEvent)*

public boolean dispatchKeyEvent(android.view.KeyEvent event)

Called to process key events. You can override this to intercept all key events 
before they are dispatched to the window. Be sure to call this implementation 
for key events that should be handled normally. 


    event - The key event. 

    Returns: boolean Return true if this event was consumed. 

*android.app.Activity.dispatchKeyShortcutEvent(KeyEvent)*

public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)

Called to process a key shortcut event. You can override this to intercept all 
key shortcut events before they are dispatched to the window. Be sure to call 
this implementation for key shortcut events that should be handled normally. 


    event - The key shortcut event. 

    Returns: True if this event was consumed. 

*android.app.Activity.dispatchPopulateAccessibilityEvent(AccessibilityEvent)*

public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)





*android.app.Activity.dispatchTouchEvent(MotionEvent)*

public boolean dispatchTouchEvent(android.view.MotionEvent ev)

Called to process touch screen events. You can override this to intercept all 
touch screen events before they are dispatched to the window. Be sure to call 
this implementation for touch screen events that should be handled normally. 


    ev - The touch screen event. 

    Returns: boolean Return true if this event was consumed. 

*android.app.Activity.dispatchTrackballEvent(MotionEvent)*

public boolean dispatchTrackballEvent(android.view.MotionEvent ev)

Called to process trackball events. You can override this to intercept all 
trackball events before they are dispatched to the window. Be sure to call this 
implementation for trackball events that should be handled normally. 


    ev - The trackball event. 

    Returns: boolean Return true if this event was consumed. 

*android.app.Activity.dump(String,FileDescriptor,PrintWriter,String[])*

public void dump(
  java.lang.String prefix,
  java.io.FileDescriptor fd,
  java.io.PrintWriter writer,
  java.lang.String[] args)

Print the Activity's state into the given stream. This gets invoked if you run 
"adb shell dumpsys activity <activity_component_name>". 


    prefix - Desired prefix to prepend at each line of output. 
    fd - The raw file descriptor that the dump is being sent to. 
    writer - The PrintWriter to which you should dump your state. This will be closed for 
       you after you return. 
    args - additional arguments to the dump request. 

*android.app.Activity.findViewById(int)*

public |android.view.View| findViewById(int id)

Finds a view that was identified by the id attribute from the XML that was 
processed in (|android.app.Activity|) . 



    Returns: The view if found or null otherwise. 

*android.app.Activity.finish()*

public void finish()

Call this when your activity is done and should be closed. The ActivityResult 
is propagated back to whoever launched you via onActivityResult(). 



*android.app.Activity.finishActivity(int)*

public void finishActivity(int requestCode)

Force finish another activity that you had previously started with 
(|android.app.Activity|) . 


    requestCode - The request code of the activity that you had given to 
       startActivityForResult(). If there are multiple activities started with 
       this request code, they will all be finished. 

*android.app.Activity.finishActivityFromChild(Activity,int)*

public void finishActivityFromChild(
  android.app.Activity child,
  int requestCode)

This is called when a child activity of this one calls its finishActivity(). 


    child - The activity making the call. 
    requestCode - Request code that had been used to start the activity. 

*android.app.Activity.finishAffinity()*

public void finishAffinity()

Finish this activity as well as all activities immediately below it in the 
current task that have the same affinity. This is typically used when an 
application can be launched on to another task (such as from an ACTION_VIEW of 
a content type it understands) and the user has used the up navigation to 
switch out of the current task and in to its own task. In this case, if the 
user has navigated down into any other activities of the second application, 
all of those should be removed from the original task as part of the task 
switch. 

Note that this finish does not allow you to deliver results to the previous 
activity, and an exception will be thrown if you are trying to do so. 



*android.app.Activity.finishFromChild(Activity)*

public void finishFromChild(android.app.Activity child)

This is called when a child activity of this one calls its 
(|android.app.Activity|) method. The default implementation simply calls 
finish() on this activity (the parent), finishing the entire group. 


    child - The activity making the call. 

*android.app.Activity.getActionBar()*

public |android.app.ActionBar| getActionBar()

Retrieve a reference to this activity's ActionBar. 



    Returns: The Activity's ActionBar, or null if it does not have one. 

*android.app.Activity.getActivityToken()*

public final |android.os.IBinder| getActivityToken()





*android.app.Activity.getApplication()*

public final |android.app.Application| getApplication()

Return the application that owns this activity. 



*android.app.Activity.getCallingActivity()*

public |android.content.ComponentName| getCallingActivity()

Return the name of the activity that invoked this activity. This is who the 
data in setResult()(|android.app.Activity|) will be sent to. You can use this 
information to validate that the recipient is allowed to receive the data. 

Note: if the calling activity is not expecting a result (that is it did not use 
the (|android.app.Activity|) form that includes a request code), then the 
calling package will be null. 



    Returns: The ComponentName of the activity that will receive your reply, or null if 
             none. 

*android.app.Activity.getCallingPackage()*

public |java.lang.String| getCallingPackage()

Return the name of the package that invoked this activity. This is who the data 
in setResult()(|android.app.Activity|) will be sent to. You can use this 
information to validate that the recipient is allowed to receive the data. 

Note: if the calling activity is not expecting a result (that is it did not use 
the (|android.app.Activity|) form that includes a request code), then the 
calling package will be null. 

Note: prior to (|android.os.Build.VERSION_CODES|) , the result from this method 
was unstable. If the process hosting the calling package was no longer running, 
it would return null instead of the proper package name. You can use 
(|android.app.Activity|) and retrieve the package name from that instead. 



    Returns: The package of the activity that will receive your reply, or null if none. 

*android.app.Activity.getChangingConfigurations()*

public int getChangingConfigurations()

If this activity is being destroyed because it can not handle a configuration 
parameter being changed (and thus its (|android.app.Activity|) method is not 
being called), then you can use this method to discover the set of changes that 
have occurred while in the process of being destroyed. Note that there is no 
guarantee that these will be accurate (other changes could have happened at any 
time), so you should only use this as an optimization hint. 



    Returns: Returns a bit field of the configuration parameters that are changing, as 
             defined by the {@link android.content.res.Configuration} class. 

*android.app.Activity.getComponentName()*

public |android.content.ComponentName| getComponentName()

Returns complete component name of this activity. 



    Returns: Returns the complete component name for this activity 

*android.app.Activity.getCurrentFocus()*

public |android.view.View| getCurrentFocus()

Calls (|android.view.Window|) on the Window of this Activity to return the 
currently focused view. 



    Returns: View The current View with focus or null. 

*android.app.Activity.getFragmentManager()*

public |android.app.FragmentManager| getFragmentManager()

Return the FragmentManager for interacting with fragments associated with this 
activity. 



*android.app.Activity.getIntent()*

public |android.content.Intent| getIntent()

Return the intent that started this activity. 



*android.app.Activity.getLastNonConfigurationInstance()*

public |java.lang.Object| getLastNonConfigurationInstance()

Retrieve the non-configuration instance data that was previously returned by 
(|android.app.Activity|) . This will be available from the initial 
(|android.app.Activity|) and (|android.app.Activity|) calls to the new 
instance, allowing you to extract any useful dynamic state from the previous 
instance. 

Note that the data you retrieve here should only be used as an optimization for 
handling configuration changes. You should always be able to handle getting a 
null pointer back, and an activity must still be able to restore itself to its 
previous state (through the normal (|android.app.Activity|) mechanism) even if 
this function returns null. 

    Deprecated: Use the new {@link Fragment} API
 {@link Fragment#setRetainInstance(boolean)} instead; this is also
 available on older platforms through the Android compatibility package.


    Returns: Returns the object previously returned by {@link 
             #onRetainNonConfigurationInstance()}. 

*android.app.Activity.getLayoutInflater()*

public |android.view.LayoutInflater| getLayoutInflater()

Convenience for calling (|android.view.Window|) . 



*android.app.Activity.getLoaderManager()*

public |android.app.LoaderManager| getLoaderManager()

Return the LoaderManager for this fragment, creating it if needed. 



*android.app.Activity.getLocalClassName()*

public |java.lang.String| getLocalClassName()

Returns class name for this activity with the package prefix removed. This is 
the default name used to read and write settings. 



    Returns: The local class name. 

*android.app.Activity.getMenuInflater()*

public |android.view.MenuInflater| getMenuInflater()

Returns a (|android.view.MenuInflater|) with this context. 



*android.app.Activity.getParent()*

public final |android.app.Activity| getParent()

Return the parent activity if this view is an embedded child. 



*android.app.Activity.getParentActivityIntent()*

public |android.content.Intent| getParentActivityIntent()

Obtain an (|android.content.Intent|) that will launch an explicit target 
activity specified by this activity's logical parent. The logical parent is 
named in the application's manifest by the parentActivityName(|android.R.attr|) 
attribute. Activity subclasses may override this method to modify the Intent 
returned by super.getParentActivityIntent() or to implement a different 
mechanism of retrieving the parent intent entirely. 



    Returns: a new Intent targeting the defined parent of this activity or null if there is 
             no valid parent. 

*android.app.Activity.getPreferences(int)*

public |android.content.SharedPreferences| getPreferences(int mode)

Retrieve a (|android.content.SharedPreferences|) object for accessing 
preferences that are private to this activity. This simply calls the underlying 
(|android.app.Activity|) method by passing in this activity's class name as the 
preferences name. 


    mode - Operating mode. Use {@link #MODE_PRIVATE} for the default operation, {@link 
       #MODE_WORLD_READABLE} and {@link #MODE_WORLD_WRITEABLE} to control 
       permissions. 

    Returns: Returns the single SharedPreferences instance that can be used to retrieve and 
             modify the preference values. 

*android.app.Activity.getRequestedOrientation()*

public int getRequestedOrientation()

Return the current requested orientation of the activity. This will either be 
the orientation requested in its component's manifest, or the last requested 
orientation given to (|android.app.Activity|) . 



    Returns: Returns an orientation constant as used in {@link 
             ActivityInfo#screenOrientation ActivityInfo.screenOrientation}. 

*android.app.Activity.getSystemService(String)*

public |java.lang.Object| getSystemService(java.lang.String name)





*android.app.Activity.getTaskId()*

public int getTaskId()

Return the identifier of the task this activity is in. This identifier will 
remain the same for the lifetime of the activity. 



    Returns: Task identifier, an opaque integer. 

*android.app.Activity.getTitle()*

public final |java.lang.CharSequence| getTitle()





*android.app.Activity.getTitleColor()*

public final int getTitleColor()





*android.app.Activity.getVolumeControlStream()*

public final int getVolumeControlStream()

Gets the suggested audio stream whose volume should be changed by the harwdare 
volume controls. 



    Returns: The suggested audio stream type whose volume should be changed by the hardware 
             volume controls. 

*android.app.Activity.getWindow()*

public |android.view.Window| getWindow()

Retrieve the current (|android.view.Window|) for the activity. This can be used 
to directly access parts of the Window API that are not available through 
Activity/Screen. 



    Returns: Window The current window, or null if the activity is not visual. 

*android.app.Activity.getWindowManager()*

public |android.view.WindowManager| getWindowManager()

Retrieve the window manager for showing custom windows. 



*android.app.Activity.hasWindowFocus()*

public boolean hasWindowFocus()

Returns true if this activity's main window currently has window focus. Note 
that this is not the same as the view itself having focus. 



    Returns: True if this activity's main window currently has window focus. 

*android.app.Activity.invalidateOptionsMenu()*

public void invalidateOptionsMenu()

Declare that the options menu has changed, so should be recreated. The 
(|android.app.Activity|) method will be called the next time it needs to be 
displayed. 



*android.app.Activity.isChangingConfigurations()*

public boolean isChangingConfigurations()

Check to see whether this activity is in the process of being destroyed in 
order to be recreated with a new configuration. This is often used in 
(|android.app.Activity|) to determine whether the state needs to be cleaned up 
or will be passed on to the next instance of the activity via 
(|android.app.Activity|) . 



    Returns: If the activity is being torn down in order to be recreated with a new 
             configuration, returns true; else returns false. 

*android.app.Activity.isChild()*

public final boolean isChild()

Is this activity embedded inside of another activity? 



*android.app.Activity.isDestroyed()*

public boolean isDestroyed()

Returns true if the final (|android.app.Activity|) call has been made on the 
Activity, so this instance is now dead. 



*android.app.Activity.isFinishing()*

public boolean isFinishing()

Check to see whether this activity is in the process of finishing, either 
because you called (|android.app.Activity|) on it or someone else has requested 
that it finished. This is often used in (|android.app.Activity|) to determine 
whether the activity is simply pausing or completely finishing. 



    Returns: If the activity is finishing, returns true; else returns false. 

*android.app.Activity.isImmersive()*

public boolean isImmersive()

Bit indicating that this activity is "immersive" and should not be interrupted 
by notifications if possible. 

This value is initially set by the manifest property android:immersive but may 
be changed at runtime by (|android.app.Activity|) . 



*android.app.Activity.isResumed()*

public final boolean isResumed()





*android.app.Activity.isTaskRoot()*

public boolean isTaskRoot()

Return whether this activity is the root of a task. The root is the first 
activity in a task. 



    Returns: True if this is the root activity, else false. 

*android.app.Activity.managedQuery(Uri,String[],String,String)*

public final |android.database.Cursor| managedQuery(
  android.net.Uri uri,
  java.lang.String[] projection,
  java.lang.String selection,
  java.lang.String sortOrder)

Wrapper around (|android.content.ContentResolver|) that gives the resulting 
(|android.database.Cursor|) to call (|android.app.Activity|) so that the 
activity will manage its lifecycle for you. 

If you are targeting (|android.os.Build.VERSION_CODES|) or later, consider 
instead using (|android.app.LoaderManager|) instead, available via 
(|android.app.Activity|) . 

Warning: Do not call (|android.database.Cursor|) on a cursor obtained using 
this method, because the activity will do that for you at the appropriate time. 
However, if you call (|android.app.Activity|) on a cursor from a managed query, 
the system will not automatically close the cursor and, in that case, you must 
call (|android.database.Cursor|) . 

    Deprecated: Use {@link CursorLoader} instead.

    uri - The URI of the content provider to query. 
    projection - List of columns to return. 
    selection - SQL WHERE clause. 
    sortOrder - SQL ORDER BY clause. 

    Returns: The Cursor that was returned by query(). 

*android.app.Activity.managedQuery(Uri,String[],String,String[],String)*

public final |android.database.Cursor| managedQuery(
  android.net.Uri uri,
  java.lang.String[] projection,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String sortOrder)

Wrapper around (|android.content.ContentResolver|) that gives the resulting 
(|android.database.Cursor|) to call (|android.app.Activity|) so that the 
activity will manage its lifecycle for you. 

If you are targeting (|android.os.Build.VERSION_CODES|) or later, consider 
instead using (|android.app.LoaderManager|) instead, available via 
(|android.app.Activity|) . 

Warning: Do not call (|android.database.Cursor|) on a cursor obtained using 
this method, because the activity will do that for you at the appropriate time. 
However, if you call (|android.app.Activity|) on a cursor from a managed query, 
the system will not automatically close the cursor and, in that case, you must 
call (|android.database.Cursor|) . 

    Deprecated: Use {@link CursorLoader} instead.

    uri - The URI of the content provider to query. 
    projection - List of columns to return. 
    selection - SQL WHERE clause. 
    selectionArgs - The arguments to selection, if any ?s are pesent 
    sortOrder - SQL ORDER BY clause. 

    Returns: The Cursor that was returned by query(). 

*android.app.Activity.moveTaskToBack(boolean)*

public boolean moveTaskToBack(boolean nonRoot)

Move the task containing this activity to the back of the activity stack. The 
activity's order within the task is unchanged. 


    nonRoot - If false then this only works if the activity is the root of a task; if true it 
       will work for any activity in a task. 

    Returns: If the task was moved (or it was already at the back) true is returned, else 
             false. 

*android.app.Activity.navigateUpTo(Intent)*

public boolean navigateUpTo(android.content.Intent upIntent)

Navigate from this activity to the activity specified by upIntent, finishing 
this activity in the process. If the activity indicated by upIntent already 
exists in the task's history, this activity and all others before the indicated 
activity in the history stack will be finished. 

If the indicated activity does not appear in the history stack, this will 
finish each activity in this task until the root activity of the task is 
reached, resulting in an "in-app home" behavior. This can be useful in apps 
with a complex navigation hierarchy when an activity may be reached by a path 
not passing through a canonical parent activity. 

This method should be used when performing up navigation from within the same 
task as the destination. If up navigation should cross tasks in some cases, see 
(|android.app.Activity|) . 


    upIntent - An intent representing the target destination for up navigation 

    Returns: true if up navigation successfully reached the activity indicated by upIntent 
             and upIntent was delivered to it. false if an instance of the 
             indicated activity could not be found and this activity was simply 
             finished normally. 

*android.app.Activity.navigateUpToFromChild(Activity,Intent)*

public boolean navigateUpToFromChild(
  android.app.Activity child,
  android.content.Intent upIntent)

This is called when a child activity of this one calls its 
(|android.app.Activity|) method. The default implementation simply calls 
navigateUpTo(upIntent) on this activity (the parent). 


    child - The activity making the call. 
    upIntent - An intent representing the target destination for up navigation 

    Returns: true if up navigation successfully reached the activity indicated by upIntent 
             and upIntent was delivered to it. false if an instance of the 
             indicated activity could not be found and this activity was simply 
             finished normally. 

*android.app.Activity.onActionModeFinished(ActionMode)*

public void onActionModeFinished(android.view.ActionMode mode)

Notifies the activity that an action mode has finished. Activity subclasses 
overriding this method should call the superclass implementation. 


    mode - The action mode that just finished. 

*android.app.Activity.onActionModeStarted(ActionMode)*

public void onActionModeStarted(android.view.ActionMode mode)

Notifies the Activity that an action mode has been started. Activity subclasses 
overriding this method should call the superclass implementation. 


    mode - The new action mode. 

*android.app.Activity.onActivityResult(int,int,Intent)*

protected void onActivityResult(
  int requestCode,
  int resultCode,
  android.content.Intent data)

Called when an activity you launched exits, giving you the requestCode you 
started it with, the resultCode it returned, and any additional data from it. 
The resultCode will be (|android.app.Activity|) if the activity explicitly 
returned that, didn't return any result, or crashed during its operation. 

You will receive this call immediately before onResume() when your activity is 
re-starting. 


    requestCode - The integer request code originally supplied to startActivityForResult(), 
       allowing you to identify who this result came from. 
    resultCode - The integer result code returned by the child activity through its setResult(). 
    data - An Intent, which can return result data to the caller (various data can be 
       attached to Intent "extras"). 

*android.app.Activity.onApplyThemeResource(Resources.Theme,int,boolean)*

protected void onApplyThemeResource(
  android.content.res.Resources.Theme theme,
  int resid,
  boolean first)





*android.app.Activity.onAttachedToWindow()*

public void onAttachedToWindow()

Called when the main window associated with the activity has been attached to 
the window manager. See View.onAttachedToWindow()(|android.view.View|) for more 
information. 



*android.app.Activity.onAttachFragment(Fragment)*

public void onAttachFragment(android.app.Fragment fragment)

Called when a Fragment is being attached to this activity, immediately after 
the call to its Fragment.onAttach()(|android.app.Fragment|) method and before 
Fragment.onCreate()(|android.app.Fragment|) . 



*android.app.Activity.onBackPressed()*

public void onBackPressed()

Called when the activity has detected the user's press of the back key. The 
default implementation simply finishes the current activity, but you can 
override this to do whatever you want. 



*android.app.Activity.onChildTitleChanged(Activity,CharSequence)*

protected void onChildTitleChanged(
  android.app.Activity childActivity,
  java.lang.CharSequence title)





*android.app.Activity.onConfigurationChanged(Configuration)*

public void onConfigurationChanged(android.content.res.Configuration newConfig)

Called by the system when the device configuration changes while your activity 
is running. Note that this will only be called if you have selected 
configurations you would like to handle with the (|android.R.attr|) attribute 
in your manifest. If any configuration change occurs that is not selected to be 
reported by that attribute, then instead of reporting it the system will stop 
and restart the activity (to have it launched with the new configuration). 

At the time that this function has been called, your Resources object will have 
been updated to return resource values matching the new configuration. 


    newConfig - The new device configuration. 

*android.app.Activity.onContentChanged()*

public void onContentChanged()





*android.app.Activity.onContextItemSelected(MenuItem)*

public boolean onContextItemSelected(android.view.MenuItem item)

This hook is called whenever an item in a context menu is selected. The default 
implementation simply returns false to have the normal processing happen 
(calling the item's Runnable or sending a message to its Handler as 
appropriate). You can use this method for any items for which you would like to 
do processing without those other facilities. 

Use (|android.view.MenuItem|) to get extra information set by the View that 
added this menu item. 

Derived classes should call through to the base class for it to perform the 
default menu handling. 


    item - The context menu item that was selected. 

    Returns: boolean Return false to allow normal context menu processing to proceed, true 
             to consume it here. 

*android.app.Activity.onContextMenuClosed(Menu)*

public void onContextMenuClosed(android.view.Menu menu)

This hook is called whenever the context menu is being closed (either by the 
user canceling the menu with the back/menu button, or when an item is 
selected). 


    menu - The context menu that is being closed. 

*android.app.Activity.onCreate(Bundle)*

protected void onCreate(android.os.Bundle savedInstanceState)

Called when the activity is starting. This is where most initialization should 
go: calling (|android.app.Activity|) to inflate the activity's UI, using 
(|android.app.Activity|) to programmatically interact with widgets in the UI, 
calling (|android.app.Activity|) to retrieve cursors for data being displayed, 
etc. 

You can call (|android.app.Activity|) from within this function, in which case 
onDestroy() will be immediately called without any of the rest of the activity 
lifecycle ( (|android.app.Activity|) , (|android.app.Activity|) , 
(|android.app.Activity|) , etc) executing. 

Derived classes must call through to the super class's implementation of this 
method. If they do not, an exception will be thrown. 


    savedInstanceState - If the activity is being re-initialized after previously being shut down then 
       this Bundle contains the data it most recently supplied in {@link 
       #onSaveInstanceState}. Note: Otherwise it is null. 

*android.app.Activity.onCreateContextMenu(ContextMenu,View,ContextMenu.ContextMenuInfo)*

public void onCreateContextMenu(
  android.view.ContextMenu menu,
  android.view.View v,
  android.view.ContextMenu.ContextMenuInfo menuInfo)

Called when a context menu for theviewis about to be shown. Unlike 
(|android.app.Activity|) , this will be called every time the context menu is 
about to be shown and should be populated for the view (or item inside the view 
for (|android.widget.AdapterView|) subclasses, this can be found in 
themenuInfo)). 

Use (|android.app.Activity|) to know when an item has been selected. 

It is not safe to hold onto the context menu after this method returns. 



*android.app.Activity.onCreateDescription()*

public |java.lang.CharSequence| onCreateDescription()

Generate a new description for this activity. This method is called before 
pausing the activity and can, if desired, return some textual description of 
its current state to be displayed to the user. 

The default implementation returns null, which will cause you to inherit the 
description from the previous activity. If all activities return null, 
generally the label of the top activity will be used as the description. 



    Returns: A description of what the user is doing. It should be short and sweet (only a 
             few words). 

*android.app.Activity.onCreateDialog(int)*

protected |android.app.Dialog| onCreateDialog(int id)



    Deprecated: Old no-arguments version of {@link #onCreateDialog(int, Bundle)}.


*android.app.Activity.onCreateDialog(int,Bundle)*

protected |android.app.Dialog| onCreateDialog(
  int id,
  android.os.Bundle args)

Callback for creating dialogs that are managed (saved and restored) for you by 
the activity. The default implementation calls through to 
(|android.app.Activity|) for compatibility. 

If you are targeting (|android.os.Build.VERSION_CODES|) or later, consider 
instead using a (|android.app.DialogFragment|) instead. 

If you use (|android.app.Activity|) , the activity will call through to this 
method the first time, and hang onto it thereafter. Any dialog that is created 
by this method will automatically be saved and restored for you, including 
whether it is showing. 

If you would like the activity to manage saving and restoring dialogs for you, 
you should override this method and handle any ids that are passed to 
(|android.app.Activity|) . 

If you would like an opportunity to prepare your dialog before it is shown, 
override (|android.app.Activity|) . 

    Deprecated: Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.

    id - The id of the dialog. 
    args - The dialog arguments provided to {@link #showDialog(int, Bundle)}. 

    Returns: The dialog. If you return null, the dialog will not be created. 

*android.app.Activity.onCreateNavigateUpTaskStack(TaskStackBuilder)*

public void onCreateNavigateUpTaskStack(android.app.TaskStackBuilder builder)

Define the synthetic task stack that will be generated during Up navigation 
from a different task. 

The default implementation of this method adds the parent chain of this 
activity as specified in the manifest to the supplied 
(|android.app.TaskStackBuilder|) . Applications may choose to override this 
method to construct the desired task stack in a different way. 

This method will be invoked by the default implementation of 
(|android.app.Activity|) if (|android.app.Activity|) returns true when supplied 
with the intent returned by (|android.app.Activity|) . 

Applications that wish to supply extra Intent parameters to the parent stack 
defined by the manifest should override (|android.app.Activity|) . 


    builder - An empty TaskStackBuilder - the application should add intents representing the 
       desired task stack 

*android.app.Activity.onCreateOptionsMenu(Menu)*

public boolean onCreateOptionsMenu(android.view.Menu menu)

Initialize the contents of the Activity's standard options menu. You should 
place your menu items in to menu. 

This is only called once, the first time the options menu is displayed. To 
update the menu every time it is displayed, see (|android.app.Activity|) . 

The default implementation populates the menu with standard system menu items. 
These are placed in the (|android.view.Menu|) group so that they will be 
correctly ordered with application-defined menu items. Deriving classes should 
always call through to the base implementation. 

You can safely hold on to menu (and any items created from it), making 
modifications to it as desired, until the next time onCreateOptionsMenu() is 
called. 

When you add items to the menu, you can implement the Activity's 
(|android.app.Activity|) method to handle them there. 


    menu - The options menu in which you place your items. 

    Returns: You must return true for the menu to be displayed; if you return false it will 
             not be shown. 

*android.app.Activity.onCreatePanelMenu(int,Menu)*

public boolean onCreatePanelMenu(
  int featureId,
  android.view.Menu menu)

Default implementation of (|android.view.Window.Callback|) for activities. This 
calls through to the new (|android.app.Activity|) method for the 
(|android.view.Window|) panel, so that subclasses of Activity don't need to 
deal with feature codes. 



*android.app.Activity.onCreatePanelView(int)*

public |android.view.View| onCreatePanelView(int featureId)

Default implementation of (|android.view.Window.Callback|) for activities. This 
simply returns null so that all panel sub-windows will have the default menu 
behavior. 



*android.app.Activity.onCreateThumbnail(Bitmap,Canvas)*

public boolean onCreateThumbnail(
  Bitmap outBitmap,
  Canvas canvas)

Generate a new thumbnail for this activity. This method is called before 
pausing the activity, and should draw into outBitmap the imagery for the 
desired thumbnail in the dimensions of that bitmap. It can use the given 
canvas, which is configured to draw into the bitmap, for rendering if desired. 

The default implementation returns fails and does not draw a thumbnail; this 
will result in the platform creating its own thumbnail if needed. 


    outBitmap - The bitmap to contain the thumbnail. 
    canvas - Can be used to render into the bitmap. 

    Returns: Return true if you have drawn into the bitmap; otherwise after you return it 
             will be filled with a default thumbnail. 

*android.app.Activity.onCreateView(String,Context,AttributeSet)*

public |android.view.View| onCreateView(
  java.lang.String name,
  android.content.Context context,
  android.util.AttributeSet attrs)

Standard implementation of (|android.view.LayoutInflater.Factory|) used when 
inflating with the LayoutInflater returned by (|android.app.Activity|) . This 
implementation does nothing and is for pre- (|android.os.Build.VERSION_CODES|) 
apps. Newer apps should use (|android.app.Activity|) . 



*android.app.Activity.onCreateView(View,String,Context,AttributeSet)*

public |android.view.View| onCreateView(
  android.view.View parent,
  java.lang.String name,
  android.content.Context context,
  android.util.AttributeSet attrs)

Standard implementation of (|android.view.LayoutInflater.Factory2|) used when 
inflating with the LayoutInflater returned by (|android.app.Activity|) . This 
implementation handles tags to embed fragments inside of the activity. 



*android.app.Activity.onDestroy()*

protected void onDestroy()

Perform any final cleanup before an activity is destroyed. This can happen 
either because the activity is finishing (someone called 
(|android.app.Activity|) on it, or because the system is temporarily destroying 
this instance of the activity to save space. You can distinguish between these 
two scenarios with the (|android.app.Activity|) method. 

Note: do not count on this method being called as a place for saving data! For 
example, if an activity is editing data in a content provider, those edits 
should be committed in either (|android.app.Activity|) or 
(|android.app.Activity|) , not here. This method is usually implemented to free 
resources like threads that are associated with an activity, so that a 
destroyed activity does not leave such things around while the rest of its 
application is still running. There are situations where the system will simply 
kill the activity's hosting process without calling this method (or any others) 
in it, so it should not be used to do things that are intended to remain around 
after the process goes away. 

Derived classes must call through to the super class's implementation of this 
method. If they do not, an exception will be thrown. 



*android.app.Activity.onDetachedFromWindow()*

public void onDetachedFromWindow()

Called when the main window associated with the activity has been detached from 
the window manager. See View.onDetachedFromWindow()(|android.view.View|) for 
more information. 



*android.app.Activity.onGenericMotionEvent(MotionEvent)*

public boolean onGenericMotionEvent(android.view.MotionEvent event)

Called when a generic motion event was not handled by any of the views inside 
of the activity. 

Generic motion events describe joystick movements, mouse hovers, track pad 
touches, scroll wheel movements and other input events. The 
source(|android.view.MotionEvent|) of the motion event specifies the class of 
input that was received. Implementations of this method must examine the bits 
in the source before processing the event. The following code example shows how 
this is done. 

Generic motion events with source class (|android.view.InputDevice|) are 
delivered to the view under the pointer. All other generic motion events are 
delivered to the focused view. 

See (|android.view.View|) for an example of how to handle this event. 


    event - The generic motion event being processed. 

    Returns: Return true if you have consumed the event, false if you haven't. The default 
             implementation always returns false. 

*android.app.Activity.onKeyDown(int,KeyEvent)*

public boolean onKeyDown(
  int keyCode,
  android.view.KeyEvent event)

Called when a key was pressed down and not handled by any of the views inside 
of the activity. So, for example, key presses while the cursor is inside a 
TextView will not trigger the event (unless it is a navigation to another 
object) because TextView handles its own key presses. 

If the focused view didn't want this event, this method is called. 

The default implementation takes care of (|android.view.KeyEvent|) by calling 
(|android.app.Activity|) , though the behavior varies based on the application 
compatibility mode: for (|android.os.Build.VERSION_CODES|) or later 
applications, it will set up the dispatch to call (|android.app.Activity|) 
where the action will be performed; for earlier applications, it will perform 
the action immediately in on-down, as those versions of the platform behaved. 

Other additional default key handling may be performed if configured with 
(|android.app.Activity|) . 



    Returns: Return true to prevent this event from being propagated further, or false to 
             indicate that you have not handled this event and it should 
             continue to be propagated. 

*android.app.Activity.onKeyLongPress(int,KeyEvent)*

public boolean onKeyLongPress(
  int keyCode,
  android.view.KeyEvent event)

Default implementation of 
KeyEvent.Callback.onKeyLongPress()(|KeyEvent.Callback|) : always returns false 
(doesn't handle the event). 



*android.app.Activity.onKeyMultiple(int,int,KeyEvent)*

public boolean onKeyMultiple(
  int keyCode,
  int repeatCount,
  android.view.KeyEvent event)

Default implementation of 
KeyEvent.Callback.onKeyMultiple()(|KeyEvent.Callback|) : always returns false 
(doesn't handle the event). 



*android.app.Activity.onKeyShortcut(int,KeyEvent)*

public boolean onKeyShortcut(
  int keyCode,
  android.view.KeyEvent event)

Called when a key shortcut event is not handled by any of the views in the 
Activity. Override this method to implement global key shortcuts for the 
Activity. Key shortcuts can also be implemented by setting the 
shortcut(|android.view.MenuItem|) property of menu items. 


    keyCode - The value in event.getKeyCode(). 
    event - Description of the key event. 

    Returns: True if the key shortcut was handled. 

*android.app.Activity.onKeyUp(int,KeyEvent)*

public boolean onKeyUp(
  int keyCode,
  android.view.KeyEvent event)

Called when a key was released and not handled by any of the views inside of 
the activity. So, for example, key presses while the cursor is inside a 
TextView will not trigger the event (unless it is a navigation to another 
object) because TextView handles its own key presses. 

The default implementation handles KEYCODE_BACK to stop the activity and go 
back. 



    Returns: Return true to prevent this event from being propagated further, or false to 
             indicate that you have not handled this event and it should 
             continue to be propagated. 

*android.app.Activity.onLowMemory()*

public void onLowMemory()





*android.app.Activity.onMenuItemSelected(int,MenuItem)*

public boolean onMenuItemSelected(
  int featureId,
  android.view.MenuItem item)

Default implementation of (|android.view.Window.Callback|) for activities. This 
calls through to the new (|android.app.Activity|) method for the 
(|android.view.Window|) panel, so that subclasses of Activity don't need to 
deal with feature codes. 



*android.app.Activity.onMenuOpened(int,Menu)*

public boolean onMenuOpened(
  int featureId,
  android.view.Menu menu)





    Returns: The default implementation returns true. 

*android.app.Activity.onNavigateUp()*

public boolean onNavigateUp()

This method is called whenever the user chooses to navigate Up within your 
application's activity hierarchy from the action bar. 

If the attribute parentActivityName(|android.R.attr|) was specified in the 
manifest for this activity or an activity-alias to it, default Up navigation 
will be handled automatically. If any activity along the parent chain requires 
extra Intent arguments, the Activity subclass should override the method 
(|android.app.Activity|) to supply those arguments. 

See <a href="guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and 
Back Stack from the developer guide and <a 
href="design/patterns/navigation.html">Navigation from the design guide for 
more information about navigating within your app. 

See the (|android.app.TaskStackBuilder|) class and the Activity methods 
(|android.app.Activity|) , (|android.app.Activity|) , and 
(|android.app.Activity|) for help implementing custom Up navigation. The 
AppNavigation sample application in the Android SDK is also available for 
reference. 



    Returns: true if Up navigation completed successfully and this Activity was finished, 
             false otherwise. 

*android.app.Activity.onNavigateUpFromChild(Activity)*

public boolean onNavigateUpFromChild(android.app.Activity child)

This is called when a child activity of this one attempts to navigate up. The 
default implementation simply calls onNavigateUp() on this activity (the 
parent). 


    child - The activity making the call. 

*android.app.Activity.onNewIntent(Intent)*

protected void onNewIntent(android.content.Intent intent)

This is called for activities that set launchMode to "singleTop" in their 
package, or if a client used the (|android.content.Intent|) flag when calling 
(|android.app.Activity|) . In either case, when the activity is re-launched 
while at the top of the activity stack instead of a new instance of the 
activity being started, onNewIntent() will be called on the existing instance 
with the Intent that was used to re-launch it. 

An activity will always be paused before receiving a new intent, so you can 
count on (|android.app.Activity|) being called after this method. 

Note that (|android.app.Activity|) still returns the original Intent. You can 
use (|android.app.Activity|) to update it to this new Intent. 


    intent - The new intent that was started for the activity. 

*android.app.Activity.onOptionsItemSelected(MenuItem)*

public boolean onOptionsItemSelected(android.view.MenuItem item)

This hook is called whenever an item in your options menu is selected. The 
default implementation simply returns false to have the normal processing 
happen (calling the item's Runnable or sending a message to its Handler as 
appropriate). You can use this method for any items for which you would like to 
do processing without those other facilities. 

Derived classes should call through to the base class for it to perform the 
default menu handling. 


    item - The menu item that was selected. 

    Returns: boolean Return false to allow normal menu processing to proceed, true to 
             consume it here. 

*android.app.Activity.onOptionsMenuClosed(Menu)*

public void onOptionsMenuClosed(android.view.Menu menu)

This hook is called whenever the options menu is being closed (either by the 
user canceling the menu with the back/menu button, or when an item is 
selected). 


    menu - The options menu as last shown or first initialized by onCreateOptionsMenu(). 

*android.app.Activity.onPanelClosed(int,Menu)*

public void onPanelClosed(
  int featureId,
  android.view.Menu menu)

Default implementation of (|android.view.Window.Callback|) for activities. This 
calls through to (|android.app.Activity|) method for the 
(|android.view.Window|) panel, so that subclasses of Activity don't need to 
deal with feature codes. For context menus ( (|android.view.Window|) ), the 
(|android.app.Activity|) will be called. 



*android.app.Activity.onPause()*

protected void onPause()

Called as part of the activity lifecycle when an activity is going into the 
background, but has not (yet) been killed. The counterpart to 
(|android.app.Activity|) . 

When activity B is launched in front of activity A, this callback will be 
invoked on A. B will not be created until A's (|android.app.Activity|) returns, 
so be sure to not do anything lengthy here. 

This callback is mostly used for saving any persistent state the activity is 
editing, to present a "edit in place" model to the user and making sure nothing 
is lost if there are not enough resources to start the new activity without 
first killing this one. This is also a good place to do things like stop 
animations and other things that consume a noticeable amount of CPU in order to 
make the switch to the next activity as fast as possible, or to close resources 
that are exclusive access such as the camera. 

In situations where the system needs more memory it may kill paused processes 
to reclaim resources. Because of this, you should be sure that all of your 
state is saved by the time you return from this function. In general 
(|android.app.Activity|) is used to save per-instance state in the activity and 
this method is used to store global persistent data (in content providers, 
files, etc.) 

After receiving this call you will usually receive a following call to 
(|android.app.Activity|) (after the next activity has been resumed and 
displayed), however in some cases there will be a direct call back to 
(|android.app.Activity|) without going through the stopped state. 

Derived classes must call through to the super class's implementation of this 
method. If they do not, an exception will be thrown. 



*android.app.Activity.onPostCreate(Bundle)*

protected void onPostCreate(android.os.Bundle savedInstanceState)

Called when activity start-up is complete (after (|android.app.Activity|) and 
(|android.app.Activity|) have been called). Applications will generally not 
implement this method; it is intended for system classes to do final 
initialization after application code has run. 

Derived classes must call through to the super class's implementation of this 
method. If they do not, an exception will be thrown. 


    savedInstanceState - If the activity is being re-initialized after previously being shut down then 
       this Bundle contains the data it most recently supplied in {@link 
       #onSaveInstanceState}. Note: Otherwise it is null. 

*android.app.Activity.onPostResume()*

protected void onPostResume()

Called when activity resume is complete (after (|android.app.Activity|) has 
been called). Applications will generally not implement this method; it is 
intended for system classes to do final setup after application resume code has 
run. 

Derived classes must call through to the super class's implementation of this 
method. If they do not, an exception will be thrown. 



*android.app.Activity.onPrepareDialog(int,Dialog)*

protected void onPrepareDialog(
  int id,
  android.app.Dialog dialog)



    Deprecated: Old no-arguments version of
 {@link #onPrepareDialog(int, Dialog, Bundle)}.


*android.app.Activity.onPrepareDialog(int,Dialog,Bundle)*

protected void onPrepareDialog(
  int id,
  android.app.Dialog dialog,
  android.os.Bundle args)

Provides an opportunity to prepare a managed dialog before it is being shown. 
The default implementation calls through to (|android.app.Activity|) for 
compatibility. 

Override this if you need to update a managed dialog based on the state of the 
application each time it is shown. For example, a time picker dialog might want 
to be updated with the current time. You should call through to the 
superclass's implementation. The default implementation will set this Activity 
as the owner activity on the Dialog. 

    Deprecated: Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.

    id - The id of the managed dialog. 
    dialog - The dialog. 
    args - The dialog arguments provided to {@link #showDialog(int, Bundle)}. 

*android.app.Activity.onPrepareNavigateUpTaskStack(TaskStackBuilder)*

public void onPrepareNavigateUpTaskStack(android.app.TaskStackBuilder builder)

Prepare the synthetic task stack that will be generated during Up navigation 
from a different task. 

This method receives the (|android.app.TaskStackBuilder|) with the constructed 
series of Intents as generated by (|android.app.Activity|) . If any extra data 
should be added to these intents before launching the new task, the application 
should override this method and add that data here. 


    builder - A TaskStackBuilder that has been populated with Intents by 
       onCreateNavigateUpTaskStack. 

*android.app.Activity.onPrepareOptionsMenu(Menu)*

public boolean onPrepareOptionsMenu(android.view.Menu menu)

Prepare the Screen's standard options menu to be displayed. This is called 
right before the menu is shown, every time it is shown. You can use this method 
to efficiently enable/disable items or otherwise dynamically modify the 
contents. 

The default implementation updates the system menu items based on the 
activity's state. Deriving classes should always call through to the base class 
implementation. 


    menu - The options menu as last shown or first initialized by onCreateOptionsMenu(). 

    Returns: You must return true for the menu to be displayed; if you return false it will 
             not be shown. 

*android.app.Activity.onPreparePanel(int,View,Menu)*

public boolean onPreparePanel(
  int featureId,
  android.view.View view,
  android.view.Menu menu)

Default implementation of (|android.view.Window.Callback|) for activities. This 
calls through to the new (|android.app.Activity|) method for the 
(|android.view.Window|) panel, so that subclasses of Activity don't need to 
deal with feature codes. 



*android.app.Activity.onProvideAssistData(Bundle)*

public void onProvideAssistData(android.os.Bundle data)

This is called when the user is requesting an assist, to build a full 
(|android.content.Intent|) Intent with all of the context of the current 
application. You can override this method to place into the bundle anything you 
would like to appear in the (|android.content.Intent|) part of the assist 
Intent. The default implementation does nothing. 

This function will be called after any global assist callbacks that had been 
registered with 
Application.registerOnProvideAssistDataListener(|android.app.Application|) . 



*android.app.Activity.onRestart()*

protected void onRestart()

Called after (|android.app.Activity|) when the current activity is being 
re-displayed to the user (the user has navigated back to it). It will be 
followed by (|android.app.Activity|) and then (|android.app.Activity|) . 

For activities that are using raw (|android.database.Cursor|) objects (instead 
of creating them through (|android.app.Activity|) , this is usually the place 
where the cursor should be requeried (because you had deactivated it in 
(|android.app.Activity|) . 

Derived classes must call through to the super class's implementation of this 
method. If they do not, an exception will be thrown. 



*android.app.Activity.onRestoreInstanceState(Bundle)*

protected void onRestoreInstanceState(android.os.Bundle savedInstanceState)

This method is called after (|android.app.Activity|) when the activity is being 
re-initialized from a previously saved state, given here in savedInstanceState. 
Most implementations will simply use (|android.app.Activity|) to restore their 
state, but it is sometimes convenient to do it here after all of the 
initialization has been done or to allow subclasses to decide whether to use 
your default implementation. The default implementation of this method performs 
a restore of any view state that had previously been frozen by 
(|android.app.Activity|) . 

This method is called between (|android.app.Activity|) and 
(|android.app.Activity|) . 


    savedInstanceState - the data most recently supplied in {@link #onSaveInstanceState}. 

*android.app.Activity.onResume()*

protected void onResume()

Called after (|android.app.Activity|) , (|android.app.Activity|) , or 
(|android.app.Activity|) , for your activity to start interacting with the 
user. This is a good place to begin animations, open exclusive-access devices 
(such as the camera), etc. 

Keep in mind that onResume is not the best indicator that your activity is 
visible to the user; a system window such as the keyguard may be in front. Use 
(|android.app.Activity|) to know for certain that your activity is visible to 
the user (for example, to resume a game). 

Derived classes must call through to the super class's implementation of this 
method. If they do not, an exception will be thrown. 



*android.app.Activity.onRetainNonConfigurationInstance()*

public |java.lang.Object| onRetainNonConfigurationInstance()

Called by the system, as part of destroying an activity due to a configuration 
change, when it is known that a new instance will immediately be created for 
the new configuration. You can return any object you like here, including the 
activity instance itself, which can later be retrieved by calling 
(|android.app.Activity|) in the new activity instance. 

If you are targeting (|android.os.Build.VERSION_CODES|) or later, consider 
instead using a (|android.app.Fragment|) with 
Fragment.setRetainInstance(boolean(|android.app.Fragment|) . 

This function is called purely as an optimization, and you must not rely on it 
being called. When it is called, a number of guarantees will be made to help 
optimize configuration switching: 

The function will be called between (|android.app.Activity|) and 
(|android.app.Activity|) . A new instance of the activity will always be 
immediately created after this one's (|android.app.Activity|) is called. In 
particular, no messages will be dispatched during this time (when the returned 
object does not have an activity to be associated with). The object you return 
here will always be available from the (|android.app.Activity|) method of the 
following activity instance as described there. 

These guarantees are designed so that an activity can use this API to propagate 
extensive state from the old to new activity instance, from loaded bitmaps, to 
network connections, to evenly actively running threads. Note that you should 
not propagate any data that may change based on the configuration, including 
any data loaded from resources such as strings, layouts, or drawables. 

The guarantee of no message handling during the switch to the next activity 
simplifies use with active objects. For example if your retained state is an 
(|android.os.AsyncTask|) you are guaranteed that its call back functions (like 
(|android.os.AsyncTask|) ) will not be called from the call here until you 
execute the next instance's (|android.app.Activity|) . (Note however that there 
is of course no such guarantee for (|android.os.AsyncTask|) since that is 
running in a separate thread.) 

    Deprecated: Use the new {@link Fragment} API
 {@link Fragment#setRetainInstance(boolean)} instead; this is also
 available on older platforms through the Android compatibility package.


    Returns: Return any Object holding the desired state to propagate to the next activity 
             instance. 

*android.app.Activity.onSaveInstanceState(Bundle)*

protected void onSaveInstanceState(android.os.Bundle outState)

Called to retrieve per-instance state from an activity before being killed so 
that the state can be restored in (|android.app.Activity|) or 
(|android.app.Activity|) (the (|android.os.Bundle|) populated by this method 
will be passed to both). 

This method is called before an activity may be killed so that when it comes 
back some time in the future it can restore its state. For example, if activity 
B is launched in front of activity A, and at some point activity A is killed to 
reclaim resources, activity A will have a chance to save the current state of 
its user interface via this method so that when the user returns to activity A, 
the state of the user interface can be restored via (|android.app.Activity|) or 
(|android.app.Activity|) . 

Do not confuse this method with activity lifecycle callbacks such as 
(|android.app.Activity|) , which is always called when an activity is being 
placed in the background or on its way to destruction, or 
(|android.app.Activity|) which is called before destruction. One example of 
when (|android.app.Activity|) and (|android.app.Activity|) is called and not 
this method is when a user navigates back from activity B to activity A: there 
is no need to call (|android.app.Activity|) on B because that particular 
instance will never be restored, so the system avoids calling it. An example 
when (|android.app.Activity|) is called and not (|android.app.Activity|) is 
when activity B is launched in front of activity A: the system may avoid 
calling (|android.app.Activity|) on activity A if it isn't killed during the 
lifetime of B since the state of the user interface of A will stay intact. 

The default implementation takes care of most of the UI per-instance state for 
you by calling (|android.view.View|) on each view in the hierarchy that has an 
id, and by saving the id of the currently focused view (all of which is 
restored by the default implementation of (|android.app.Activity|) ). If you 
override this method to save additional information not captured by each 
individual view, you will likely want to call through to the default 
implementation, otherwise be prepared to save all of the state of each view 
yourself. 

If called, this method will occur before (|android.app.Activity|) . There are 
no guarantees about whether it will occur before or after 
(|android.app.Activity|) . 


    outState - Bundle in which to place your saved state. 

*android.app.Activity.onSearchRequested()*

public boolean onSearchRequested()

This hook is called when the user signals the desire to start a search. 

You can use this function as a simple way to launch the search UI, in response 
to a menu item, search button, or other widgets within your activity. Unless 
overidden, calling this function is the same as calling startSearch(null, 
false, null, false)(|android.app.Activity|) , which launches search for the 
current activity as specified in its manifest, see 
(|android.app.SearchManager|) . 

You can override this function to force global search, e.g. in response to a 
dedicated search key, or to block search entirely (by simply returning false). 



    Returns: Returns {@code true} if search launched, and {@code false} if activity blocks 
             it. The default implementation always returns {@code true}. 

*android.app.Activity.onStart()*

protected void onStart()

Called after (|android.app.Activity|) or after (|android.app.Activity|) when 
the activity had been stopped, but is now again being displayed to the user. It 
will be followed by (|android.app.Activity|) . 

Derived classes must call through to the super class's implementation of this 
method. If they do not, an exception will be thrown. 



*android.app.Activity.onStop()*

protected void onStop()

Called when you are no longer visible to the user. You will next receive either 
(|android.app.Activity|) , (|android.app.Activity|) , or nothing, depending on 
later user activity. 

Note that this method may never be called, in low memory situations where the 
system does not have enough memory to keep your activity's process running 
after its (|android.app.Activity|) method is called. 

Derived classes must call through to the super class's implementation of this 
method. If they do not, an exception will be thrown. 



*android.app.Activity.onTitleChanged(CharSequence,int)*

protected void onTitleChanged(
  java.lang.CharSequence title,
  int color)





*android.app.Activity.onTouchEvent(MotionEvent)*

public boolean onTouchEvent(android.view.MotionEvent event)

Called when a touch screen event was not handled by any of the views under it. 
This is most useful to process touch events that happen outside of your window 
bounds, where there is no view to receive it. 


    event - The touch screen event being processed. 

    Returns: Return true if you have consumed the event, false if you haven't. The default 
             implementation always returns false. 

*android.app.Activity.onTrackballEvent(MotionEvent)*

public boolean onTrackballEvent(android.view.MotionEvent event)

Called when the trackball was moved and not handled by any of the views inside 
of the activity. So, for example, if the trackball moves while focus is on a 
button, you will receive a call here because buttons do not normally do 
anything with trackball events. The call here happens before trackball 
movements are converted to DPAD key events, which then get sent back to the 
view hierarchy, and will be processed at the point for things like focus 
navigation. 


    event - The trackball event being processed. 

    Returns: Return true if you have consumed the event, false if you haven't. The default 
             implementation always returns false. 

*android.app.Activity.onTrimMemory(int)*

public void onTrimMemory(int level)





*android.app.Activity.onUserInteraction()*

public void onUserInteraction()

Called whenever a key, touch, or trackball event is dispatched to the activity. 
Implement this method if you wish to know that the user has interacted with the 
device in some way while your activity is running. This callback and 
(|android.app.Activity|) are intended to help activities manage status bar 
notifications intelligently; specifically, for helping activities determine the 
proper time to cancel a notfication. 

All calls to your activity's (|android.app.Activity|) callback will be 
accompanied by calls to (|android.app.Activity|) . This ensures that your 
activity will be told of relevant user activity such as pulling down the 
notification pane and touching an item there. 

Note that this callback will be invoked for the touch down action that begins a 
touch gesture, but may not be invoked for the touch-moved and touch-up actions 
that follow. 



*android.app.Activity.onUserLeaveHint()*

protected void onUserLeaveHint()

Called as part of the activity lifecycle when an activity is about to go into 
the background as the result of user choice. For example, when the user presses 
the Home key, (|android.app.Activity|) will be called, but when an incoming 
phone call causes the in-call Activity to be automatically brought to the 
foreground, (|android.app.Activity|) will not be called on the activity being 
interrupted. In cases when it is invoked, this method is called right before 
the activity's (|android.app.Activity|) callback. 

This callback and (|android.app.Activity|) are intended to help activities 
manage status bar notifications intelligently; specifically, for helping 
activities determine the proper time to cancel a notfication. 



*android.app.Activity.onWindowAttributesChanged(WindowManager.LayoutParams)*

public void onWindowAttributesChanged(android.view.WindowManager.LayoutParams params)





*android.app.Activity.onWindowFocusChanged(boolean)*

public void onWindowFocusChanged(boolean hasFocus)

Called when the current (|android.view.Window|) of the activity gains or loses 
focus. This is the best indicator of whether this activity is visible to the 
user. The default implementation clears the key tracking state, so should 
always be called. 

Note that this provides information about global focus state, which is managed 
independently of activity lifecycles. As such, while focus changes will 
generally have some relation to lifecycle changes (an activity that is stopped 
will not generally get window focus), you should not rely on any particular 
order between the callbacks here and those in the other lifecycle methods such 
as (|android.app.Activity|) . 

As a general rule, however, a resumed activity will have window focus... unless 
it has displayed other dialogs or popups that take input focus, in which case 
the activity itself will not have focus when the other windows have it. 
Likewise, the system may display system-level windows (such as the status bar 
notification panel or a system alert) which will temporarily take window input 
focus without pausing the foreground activity. 


    hasFocus - Whether the window of this activity has focus. 

*android.app.Activity.onWindowStartingActionMode(ActionMode.Callback)*

public |android.view.ActionMode| onWindowStartingActionMode(android.view.ActionMode.Callback callback)

Give the Activity a chance to control the UI for an action mode requested by 
the system. 

Note: If you are looking for a notification callback that an action mode has 
been started for this activity, see (|android.app.Activity|) . 


    callback - The callback that should control the new action mode 

    Returns: The new action mode, or null if the activity does not want to provide special 
             handling for this action mode. (It will be handled by the system.) 

*android.app.Activity.openContextMenu(View)*

public void openContextMenu(android.view.View view)

Programmatically opens the context menu for a particularview. Theviewshould 
have been added via (|android.app.Activity|) . 


    view - The view to show the context menu for. 

*android.app.Activity.openOptionsMenu()*

public void openOptionsMenu()

Programmatically opens the options menu. If the options menu is already open, 
this method does nothing. 



*android.app.Activity.overridePendingTransition(int,int)*

public void overridePendingTransition(
  int enterAnim,
  int exitAnim)

Call immediately after one of the flavors of (|android.app.Activity|) or 
(|android.app.Activity|) to specify an explicit transition animation to perform 
next. 

As of (|android.os.Build.VERSION_CODES|) an alternative to using this with 
starting activities is to supply the desired animation information through a 
(|android.app.ActivityOptions|) bundle to {@link #startActivity(Intent, Bundle) 
or a related function. This allows you to specify a custom animation even when 
starting an activity from outside the context of the current top activity. 


    enterAnim - A resource ID of the animation resource to use for the incoming activity. Use 0 
       for no animation. 
    exitAnim - A resource ID of the animation resource to use for the outgoing activity. Use 0 
       for no animation. 

*android.app.Activity.recreate()*

public void recreate()

Cause this Activity to be recreated with a new instance. This results in 
essentially the same flow as when the Activity is created due to a 
configuration change -- the current instance will go through its lifecycle to 
(|android.app.Activity|) and a new instance then created after it. 



*android.app.Activity.registerForContextMenu(View)*

public void registerForContextMenu(android.view.View view)

Registers a context menu to be shown for the given view (multiple views can 
show the context menu). This method will set the 
(|android.view.View.OnCreateContextMenuListener|) on the view to this activity, 
so (|android.app.Activity|) will be called when it is time to show the context 
menu. 


    view - The view that should show a context menu. 

*android.app.Activity.removeDialog(int)*

public final void removeDialog(int id)

Removes any internal references to a dialog managed by this Activity. If the 
dialog is showing, it will dismiss it as part of the clean up. 

This can be useful if you know that you will never show a dialog again and want 
to avoid the overhead of saving and restoring it in the future. 

As of (|android.os.Build.VERSION_CODES|) , this function will not throw an 
exception if you try to remove an ID that does not currently have an associated 
dialog. 

    Deprecated: Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.

    id - The id of the managed dialog. 

*android.app.Activity.reportFullyDrawn()*

public void reportFullyDrawn()

Report to the system that your app is now fully drawn, purely for diagnostic 
purposes (calling it does not impact the visible behavior of the activity). 
This is only used to help instrument application launch times, so that the app 
can report when it is fully in a usable state; without this, the only thing the 
system itself can determine is the point at which the activity's window is 
first drawn and displayed. To participate in app launch time measurement, you 
should always call this method after first launch (when 
(|android.app.Activity|) is called), at the point where you have entirely drawn 
your UI and populated with all of the significant data. You can safely call 
this method any time after first launch as well, in which case it will simply 
be ignored. 



*android.app.Activity.requestWindowFeature(int)*

public final boolean requestWindowFeature(int featureId)

Enable extended window features. This is a convenience for calling 
getWindow().requestFeature()(|android.view.Window|) . 


    featureId - The desired feature as defined in {@link android.view.Window}. 

    Returns: Returns true if the requested feature is supported and now enabled. 

*android.app.Activity.runOnUiThread(Runnable)*

public final void runOnUiThread(java.lang.Runnable action)

Runs the specified action on the UI thread. If the current thread is the UI 
thread, then the action is executed immediately. If the current thread is not 
the UI thread, the action is posted to the event queue of the UI thread. 


    action - the action to run on the UI thread 

*android.app.Activity.setContentView(int)*

public void setContentView(int layoutResID)

Set the activity content from a layout resource. The resource will be inflated, 
adding all top-level views to the activity. 


    layoutResID - Resource ID to be inflated. 

*android.app.Activity.setContentView(View)*

public void setContentView(android.view.View view)

Set the activity content to an explicit view. This view is placed directly into 
the activity's view hierarchy. It can itself be a complex view hierarchy. When 
calling this method, the layout parameters of the specified view are ignored. 
Both the width and the height of the view are set by default to 
(|ViewGroup.LayoutParams|) . To use your own layout parameters, invoke 
(|android.app.Activity|) instead. 


    view - The desired content to display. 

*android.app.Activity.setContentView(View,ViewGroup.LayoutParams)*

public void setContentView(
  android.view.View view,
  android.view.ViewGroup.LayoutParams params)

Set the activity content to an explicit view. This view is placed directly into 
the activity's view hierarchy. It can itself be a complex view hierarchy. 


    view - The desired content to display. 
    params - Layout parameters for the view. 

*android.app.Activity.setDefaultKeyMode(int)*

public final void setDefaultKeyMode(int mode)

Select the default key handling for this activity. This controls what will 
happen to key events that are not otherwise handled. The default mode ( 
(|android.app.Activity|) ) will simply drop them on the floor. Other modes 
allow you to launch the dialer ( (|android.app.Activity|) ), execute a shortcut 
in your options menu without requiring the menu key be held down ( 
(|android.app.Activity|) ), or launch a search ( (|android.app.Activity|) and 
(|android.app.Activity|) ). 

Note that the mode selected here does not impact the default handling of system 
keys, such as the "back" and "menu" keys, and your activity and its views 
always get a first chance to receive and handle all application keys. 


    mode - The desired default key mode constant. 

*android.app.Activity.setFeatureDrawable(int,Drawable)*

public final void setFeatureDrawable(
  int featureId,
  Drawable drawable)

Convenience for calling (|android.view.Window|) . 



*android.app.Activity.setFeatureDrawableAlpha(int,int)*

public final void setFeatureDrawableAlpha(
  int featureId,
  int alpha)

Convenience for calling (|android.view.Window|) . 



*android.app.Activity.setFeatureDrawableResource(int,int)*

public final void setFeatureDrawableResource(
  int featureId,
  int resId)

Convenience for calling (|android.view.Window|) . 



*android.app.Activity.setFeatureDrawableUri(int,Uri)*

public final void setFeatureDrawableUri(
  int featureId,
  android.net.Uri uri)

Convenience for calling (|android.view.Window|) . 



*android.app.Activity.setFinishOnTouchOutside(boolean)*

public void setFinishOnTouchOutside(boolean finish)

Sets whether this activity is finished when touched outside its window's 
bounds. 



*android.app.Activity.setImmersive(boolean)*

public void setImmersive(boolean i)

Adjust the current immersive mode setting. 

Note that changing this value will have no effect on the activity's 
(|android.content.pm.ActivityInfo|) structure; that is, if android:immersive is 
set to true in the application's manifest entry for this activity, the 
ActivityInfo.flags(|android.content.pm.ActivityInfo|) member will always have 
its FLAG_IMMERSIVE(|android.content.pm.ActivityInfo|) bit set. 



*android.app.Activity.setIntent(Intent)*

public void setIntent(android.content.Intent newIntent)

Change the intent returned by (|android.app.Activity|) . This holds a reference 
to the given intent; it does not copy it. Often used in conjunction with 
(|android.app.Activity|) . 


    newIntent - The new Intent object to return from getIntent 

*android.app.Activity.setPersistent(boolean)*

public void setPersistent(boolean isPersistent)



    Deprecated: As of {@link android.os.Build.VERSION_CODES#GINGERBREAD}
 this is a no-op.


*android.app.Activity.setProgress(int)*

public final void setProgress(int progress)

Sets the progress for the progress bars in the title. 

In order for the progress bar to be shown, the feature must be requested via 
(|android.app.Activity|) . 


    progress - The progress for the progress bar. Valid ranges are from 0 to 10000 (both 
       inclusive). If 10000 is given, the progress bar will be completely 
       filled and will fade out. 

*android.app.Activity.setProgressBarIndeterminate(boolean)*

public final void setProgressBarIndeterminate(boolean indeterminate)

Sets whether the horizontal progress bar in the title should be indeterminate 
(the circular is always indeterminate). 

In order for the progress bar to be shown, the feature must be requested via 
(|android.app.Activity|) . 


    indeterminate - Whether the horizontal progress bar should be indeterminate. 

*android.app.Activity.setProgressBarIndeterminateVisibility(boolean)*

public final void setProgressBarIndeterminateVisibility(boolean visible)

Sets the visibility of the indeterminate progress bar in the title. 

In order for the progress bar to be shown, the feature must be requested via 
(|android.app.Activity|) . 


    visible - Whether to show the progress bars in the title. 

*android.app.Activity.setProgressBarVisibility(boolean)*

public final void setProgressBarVisibility(boolean visible)

Sets the visibility of the progress bar in the title. 

In order for the progress bar to be shown, the feature must be requested via 
(|android.app.Activity|) . 


    visible - Whether to show the progress bars in the title. 

*android.app.Activity.setRequestedOrientation(int)*

public void setRequestedOrientation(int requestedOrientation)

Change the desired orientation of this activity. If the activity is currently 
in the foreground or otherwise impacting the screen orientation, the screen 
will immediately be changed (possibly causing the activity to be restarted). 
Otherwise, this will be used the next time the activity is visible. 


    requestedOrientation - An orientation constant as used in {@link ActivityInfo#screenOrientation 
       ActivityInfo.screenOrientation}. 

*android.app.Activity.setResult(int)*

public final void setResult(int resultCode)

Call this to set the result that your activity will return to its caller. 


    resultCode - The result code to propagate back to the originating activity, often 
       RESULT_CANCELED or RESULT_OK 

*android.app.Activity.setResult(int,Intent)*

public final void setResult(
  int resultCode,
  android.content.Intent data)

Call this to set the result that your activity will return to its caller. 

As of (|android.os.Build.VERSION_CODES|) , the Intent you supply here can have 
Intent.FLAG_GRANT_READ_URI_PERMISSION(|android.content.Intent|) and/or 
Intent.FLAG_GRANT_WRITE_URI_PERMISSION(|android.content.Intent|) set. This will 
grant the Activity receiving the result access to the specific URIs in the 
Intent. Access will remain until the Activity has finished (it will remain 
across the hosting process being killed and other temporary destruction) and 
will be added to any existing set of URI permissions it already holds. 


    resultCode - The result code to propagate back to the originating activity, often 
       RESULT_CANCELED or RESULT_OK 
    data - The data to propagate back to the originating activity. 

*android.app.Activity.setSecondaryProgress(int)*

public final void setSecondaryProgress(int secondaryProgress)

Sets the secondary progress for the progress bar in the title. This progress is 
drawn between the primary progress (set via (|android.app.Activity|) and the 
background. It can be ideal for media scenarios such as showing the buffering 
progress while the default progress shows the play progress. 

In order for the progress bar to be shown, the feature must be requested via 
(|android.app.Activity|) . 


    secondaryProgress - The secondary progress for the progress bar. Valid ranges are from 0 to 10000 
       (both inclusive). 

*android.app.Activity.setTitle(CharSequence)*

public void setTitle(java.lang.CharSequence title)

Change the title associated with this activity. If this is a top-level 
activity, the title for its window will change. If it is an embedded activity, 
the parent can do whatever it wants with it. 



*android.app.Activity.setTitle(int)*

public void setTitle(int titleId)

Change the title associated with this activity. If this is a top-level 
activity, the title for its window will change. If it is an embedded activity, 
the parent can do whatever it wants with it. 



*android.app.Activity.setTitleColor(int)*

public void setTitleColor(int textColor)





*android.app.Activity.setVisible(boolean)*

public void setVisible(boolean visible)

Control whether this activity's main window is visible. This is intended only 
for the special case of an activity that is not going to show a UI itself, but 
can't just finish prior to onResume() because it needs to wait for a service 
binding or such. Setting this to false allows you to prevent your UI from being 
shown during that time. 

The default value for this is taken from the (|android.R.attr|) attribute of 
the activity's theme. 



*android.app.Activity.setVolumeControlStream(int)*

public final void setVolumeControlStream(int streamType)

Suggests an audio stream whose volume should be changed by the hardware volume 
controls. 

The suggested audio stream will be tied to the window of this Activity. If the 
Activity is switched, the stream set here is no longer the suggested stream. 
The client does not need to save and restore the old suggested stream value in 
onPause and onResume. 


    streamType - The type of the audio stream whose volume should be changed by the hardware 
       volume controls. It is not guaranteed that the hardware volume controls 
       will always change this stream's volume (for example, if a call is in 
       progress, its stream's volume may be changed instead). To reset back to 
       the default, use {@link AudioManager#USE_DEFAULT_STREAM_TYPE}. 

*android.app.Activity.shouldUpRecreateTask(Intent)*

public boolean shouldUpRecreateTask(android.content.Intent targetIntent)

Returns true if the app should recreate the task when navigating 'up' from this 
activity by using targetIntent. 

If this method returns false the app can trivially call 
(|android.app.Activity|) using the same parameters to correctly perform up 
navigation. If this method returns false, the app should synthesize a new task 
stack by using (|android.app.TaskStackBuilder|) or another similar mechanism to 
perform up navigation. 


    targetIntent - An intent representing the target destination for up navigation 

    Returns: true if navigating up should recreate a new task stack, false if the same task 
             should be used for the destination 

*android.app.Activity.showDialog(int)*

public final void showDialog(int id)

Simple version of (|android.app.Activity|) that does not take any arguments. 
Simply calls (|android.app.Activity|) with null arguments. 

    Deprecated: Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.


*android.app.Activity.showDialog(int,Bundle)*

public final boolean showDialog(
  int id,
  android.os.Bundle args)

Show a dialog managed by this activity. A call to (|android.app.Activity|) will 
be made with the same id the first time this is called for a given id. From 
thereafter, the dialog will be automatically saved and restored. 

If you are targeting (|android.os.Build.VERSION_CODES|) or later, consider 
instead using a (|android.app.DialogFragment|) instead. 

Each time a dialog is shown, (|android.app.Activity|) will be made to provide 
an opportunity to do any timely preparation. 

    Deprecated: Use the new {@link DialogFragment} class with
 {@link FragmentManager} instead; this is also
 available on older platforms through the Android compatibility package.

    id - The id of the managed dialog. 
    args - Arguments to pass through to the dialog. These will be saved and restored for 
       you. Note that if the dialog is already created, {@link 
       #onCreateDialog(int, Bundle)} will not be called with the new arguments 
       but {@link #onPrepareDialog(int, Dialog, Bundle)} will be. If you need 
       to rebuild the dialog, call {@link #removeDialog(int)} first. 

    Returns: Returns true if the Dialog was created; false is returned if it is not created 
             because {@link #onCreateDialog(int, Bundle)} returns false. 

*android.app.Activity.startActionMode(ActionMode.Callback)*

public |android.view.ActionMode| startActionMode(android.view.ActionMode.Callback callback)

Start an action mode. 


    callback - Callback that will manage lifecycle events for this context mode 

    Returns: The ContextMode that was started, or null if it was canceled 

*android.app.Activity.startActivities(Intent[])*

public void startActivities(android.content.Intent[] intents)

Same as (|android.app.Activity|) with no options specified. 


    intents - The intents to start. 

*android.app.Activity.startActivities(Intent[],Bundle)*

public void startActivities(
  android.content.Intent[] intents,
  android.os.Bundle options)

Launch a new activity. You will not receive any information about when the 
activity exits. This implementation overrides the base version, providing 
information about the activity performing the launch. Because of this 
additional information, the (|android.content.Intent|) launch flag is not 
required; if not specified, the new activity will be added to the task of the 
caller. 

This method throws (|android.content.ActivityNotFoundException|) if there was 
no Activity found to run the given Intent. 


    intents - The intents to start. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. 

*android.app.Activity.startActivity(Intent)*

public void startActivity(android.content.Intent intent)

Same as (|android.app.Activity|) with no options specified. 


    intent - The intent to start. 

*android.app.Activity.startActivity(Intent,Bundle)*

public void startActivity(
  android.content.Intent intent,
  android.os.Bundle options)

Launch a new activity. You will not receive any information about when the 
activity exits. This implementation overrides the base version, providing 
information about the activity performing the launch. Because of this 
additional information, the (|android.content.Intent|) launch flag is not 
required; if not specified, the new activity will be added to the task of the 
caller. 

This method throws (|android.content.ActivityNotFoundException|) if there was 
no Activity found to run the given Intent. 


    intent - The intent to start. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. 

*android.app.Activity.startActivityAsUser(Intent,Bundle,UserHandle)*

public void startActivityAsUser(
  android.content.Intent intent,
  android.os.Bundle options,
  android.os.UserHandle user)





*android.app.Activity.startActivityAsUser(Intent,UserHandle)*

public void startActivityAsUser(
  android.content.Intent intent,
  android.os.UserHandle user)





*android.app.Activity.startActivityForResult(Intent,int)*

public void startActivityForResult(
  android.content.Intent intent,
  int requestCode)

Same as calling (|android.app.Activity|) with no options. 


    intent - The intent to start. 
    requestCode - If >= 0, this code will be returned in onActivityResult() when the activity 
       exits. 

*android.app.Activity.startActivityForResult(Intent,int,Bundle)*

public void startActivityForResult(
  android.content.Intent intent,
  int requestCode,
  android.os.Bundle options)

Launch an activity for which you would like a result when it finished. When 
this activity exits, your onActivityResult() method will be called with the 
given requestCode. Using a negative requestCode is the same as calling 
(|android.app.Activity|) (the activity is not launched as a sub-activity). 

Note that this method should only be used with Intent protocols that are 
defined to return a result. In other protocols (such as 
(|android.content.Intent|) or (|android.content.Intent|) ), you may not get the 
result when you expect. For example, if the activity you are launching uses the 
singleTask launch mode, it will not run in your task and thus you will 
immediately receive a cancel result. 

As a special case, if you call startActivityForResult() with a requestCode >= 0 
during the initial onCreate(Bundle savedInstanceState)/onResume() of your 
activity, then your window will not be displayed until a result is returned 
back from the started activity. This is to avoid visible flickering when 
redirecting to another activity. 

This method throws (|android.content.ActivityNotFoundException|) if there was 
no Activity found to run the given Intent. 


    intent - The intent to start. 
    requestCode - If >= 0, this code will be returned in onActivityResult() when the activity 
       exits. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. 

*android.app.Activity.startActivityFromChild(Activity,Intent,int)*

public void startActivityFromChild(
  android.app.Activity child,
  android.content.Intent intent,
  int requestCode)

Same as calling (|android.app.Activity|) with no options. 


    child - The activity making the call. 
    intent - The intent to start. 
    requestCode - Reply request code. < 0 if reply is not requested. 

*android.app.Activity.startActivityFromChild(Activity,Intent,int,Bundle)*

public void startActivityFromChild(
  android.app.Activity child,
  android.content.Intent intent,
  int requestCode,
  android.os.Bundle options)

This is called when a child activity of this one calls its 
(|android.app.Activity|) or (|android.app.Activity|) method. 

This method throws (|android.content.ActivityNotFoundException|) if there was 
no Activity found to run the given Intent. 


    child - The activity making the call. 
    intent - The intent to start. 
    requestCode - Reply request code. < 0 if reply is not requested. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. 

*android.app.Activity.startActivityFromFragment(Fragment,Intent,int)*

public void startActivityFromFragment(
  android.app.Fragment fragment,
  android.content.Intent intent,
  int requestCode)

Same as calling (|android.app.Activity|) with no options. 


    fragment - The fragment making the call. 
    intent - The intent to start. 
    requestCode - Reply request code. < 0 if reply is not requested. 

*android.app.Activity.startActivityFromFragment(Fragment,Intent,int,Bundle)*

public void startActivityFromFragment(
  android.app.Fragment fragment,
  android.content.Intent intent,
  int requestCode,
  android.os.Bundle options)

This is called when a Fragment in this activity calls its 
(|android.app.Fragment|) or (|android.app.Fragment|) method. 

This method throws (|android.content.ActivityNotFoundException|) if there was 
no Activity found to run the given Intent. 


    fragment - The fragment making the call. 
    intent - The intent to start. 
    requestCode - Reply request code. < 0 if reply is not requested. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. 

*android.app.Activity.startActivityIfNeeded(Intent,int)*

public boolean startActivityIfNeeded(
  android.content.Intent intent,
  int requestCode)

Same as calling (|android.app.Activity|) with no options. 


    intent - The intent to start. 
    requestCode - If >= 0, this code will be returned in onActivityResult() when the activity 
       exits, as described in {@link #startActivityForResult}. 

    Returns: If a new activity was launched then true is returned; otherwise false is 
             returned and you must handle the Intent yourself. 

*android.app.Activity.startActivityIfNeeded(Intent,int,Bundle)*

public boolean startActivityIfNeeded(
  android.content.Intent intent,
  int requestCode,
  android.os.Bundle options)

A special variation to launch an activity only if a new activity instance is 
needed to handle the given Intent. In other words, this is just like 
(|android.app.Activity|) except: if you are using the 
(|android.content.Intent|) flag, or singleTask or singleTop 
launchMode(|android.R.styleable|) , and the activity that handles intent is the 
same as your currently running activity, then a new instance is not needed. In 
this case, instead of the normal behavior of calling (|android.app.Activity|) 
this function will return and you can handle the Intent yourself. 

This function can only be called from a top-level activity; if it is called 
from a child activity, a runtime exception will be thrown. 


    intent - The intent to start. 
    requestCode - If >= 0, this code will be returned in onActivityResult() when the activity 
       exits, as described in {@link #startActivityForResult}. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. 

    Returns: If a new activity was launched then true is returned; otherwise false is 
             returned and you must handle the Intent yourself. 

*android.app.Activity.startIntentSender(IntentSender,Intent,int,int,int)*

public void startIntentSender(
  android.content.IntentSender intent,
  android.content.Intent fillInIntent,
  int flagsMask,
  int flagsValues,
  int extraFlags)
  throws |android.content.IntentSender.SendIntentException|
         
Same as calling (|android.app.Activity|) with no options. 


    intent - The IntentSender to launch. 
    fillInIntent - If non-null, this will be provided as the intent parameter to {@link 
       IntentSender#sendIntent}. 
    flagsMask - Intent flags in the original IntentSender that you would like to change. 
    flagsValues - Desired values for any bits set in flagsMask 
    extraFlags - Always set to 0. 

*android.app.Activity.startIntentSender(IntentSender,Intent,int,int,int,Bundle)*

public void startIntentSender(
  android.content.IntentSender intent,
  android.content.Intent fillInIntent,
  int flagsMask,
  int flagsValues,
  int extraFlags,
  android.os.Bundle options)
  throws |android.content.IntentSender.SendIntentException|
         
Like (|android.app.Activity|) , but taking a IntentSender to start; see 
(|android.app.Activity|) for more information. 


    intent - The IntentSender to launch. 
    fillInIntent - If non-null, this will be provided as the intent parameter to {@link 
       IntentSender#sendIntent}. 
    flagsMask - Intent flags in the original IntentSender that you would like to change. 
    flagsValues - Desired values for any bits set in flagsMask 
    extraFlags - Always set to 0. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. If options have 
       also been supplied by the IntentSender, options given here will override 
       any that conflict with those given by the IntentSender. 

*android.app.Activity.startIntentSenderForResult(IntentSender,int,Intent,int,int,int)*

public void startIntentSenderForResult(
  android.content.IntentSender intent,
  int requestCode,
  android.content.Intent fillInIntent,
  int flagsMask,
  int flagsValues,
  int extraFlags)
  throws |android.content.IntentSender.SendIntentException|
         
Same as calling (|android.app.Activity|) with no options. 


    intent - The IntentSender to launch. 
    requestCode - If >= 0, this code will be returned in onActivityResult() when the activity 
       exits. 
    fillInIntent - If non-null, this will be provided as the intent parameter to {@link 
       IntentSender#sendIntent}. 
    flagsMask - Intent flags in the original IntentSender that you would like to change. 
    flagsValues - Desired values for any bits set in flagsMask 
    extraFlags - Always set to 0. 

*android.app.Activity.startIntentSenderForResult(IntentSender,int,Intent,int,int,int,Bundle)*

public void startIntentSenderForResult(
  android.content.IntentSender intent,
  int requestCode,
  android.content.Intent fillInIntent,
  int flagsMask,
  int flagsValues,
  int extraFlags,
  android.os.Bundle options)
  throws |android.content.IntentSender.SendIntentException|
         
Like (|android.app.Activity|) , but allowing you to use a IntentSender to 
describe the activity to be started. If the IntentSender is for an activity, 
that activity will be started as if you had called the regular 
(|android.app.Activity|) here; otherwise, its associated action will be 
executed (such as sending a broadcast) as if you had called 
IntentSender.sendIntent(|android.content.IntentSender|) on it. 


    intent - The IntentSender to launch. 
    requestCode - If >= 0, this code will be returned in onActivityResult() when the activity 
       exits. 
    fillInIntent - If non-null, this will be provided as the intent parameter to {@link 
       IntentSender#sendIntent}. 
    flagsMask - Intent flags in the original IntentSender that you would like to change. 
    flagsValues - Desired values for any bits set in flagsMask 
    extraFlags - Always set to 0. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. If options have 
       also been supplied by the IntentSender, options given here will override 
       any that conflict with those given by the IntentSender. 

*android.app.Activity.startIntentSenderFromChild(Activity,IntentSender,int,Intent,int,int,int)*

public void startIntentSenderFromChild(
  android.app.Activity child,
  android.content.IntentSender intent,
  int requestCode,
  android.content.Intent fillInIntent,
  int flagsMask,
  int flagsValues,
  int extraFlags)
  throws |android.content.IntentSender.SendIntentException|
         
Same as calling (|android.app.Activity|) with no options. 



*android.app.Activity.startIntentSenderFromChild(Activity,IntentSender,int,Intent,int,int,int,Bundle)*

public void startIntentSenderFromChild(
  android.app.Activity child,
  android.content.IntentSender intent,
  int requestCode,
  android.content.Intent fillInIntent,
  int flagsMask,
  int flagsValues,
  int extraFlags,
  android.os.Bundle options)
  throws |android.content.IntentSender.SendIntentException|
         
Like (|android.app.Activity|) , but taking a IntentSender; see 
(|android.app.Activity|) for more information. 



*android.app.Activity.startManagingCursor(Cursor)*

public void startManagingCursor(android.database.Cursor c)

This method allows the activity to take care of managing the given 
(|android.database.Cursor|) 's lifecycle for you based on the activity's 
lifecycle. That is, when the activity is stopped it will automatically call 
(|android.database.Cursor|) on the given Cursor, and when it is later restarted 
it will call (|android.database.Cursor|) for you. When the activity is 
destroyed, all managed Cursors will be closed automatically. 

If you are targeting (|android.os.Build.VERSION_CODES|) or later, consider 
instead using (|android.app.LoaderManager|) instead, available via 
(|android.app.Activity|) . 

Warning: Do not call (|android.database.Cursor|) on cursor obtained from 
(|android.app.Activity|) , because the activity will do that for you at the 
appropriate time. However, if you call (|android.app.Activity|) on a cursor 
from a managed query, the system will not automatically close the cursor and, 
in that case, you must call (|android.database.Cursor|) . 

    Deprecated: Use the new {@link android.content.CursorLoader} class with
 {@link LoaderManager} instead; this is also
 available on older platforms through the Android compatibility package.

    c - The Cursor to be managed. 

*android.app.Activity.startNextMatchingActivity(Intent)*

public boolean startNextMatchingActivity(android.content.Intent intent)

Same as calling (|android.app.Activity|) with no options. 


    intent - The intent to dispatch to the next activity. For correct behavior, this must be 
       the same as the Intent that started your own activity; the only changes 
       you can make are to the extras inside of it. 

    Returns: Returns a boolean indicating whether there was another Activity to start: true 
             if there was a next activity to start, false if there wasn't. In 
             general, if true is returned you will then want to call finish() 
             on yourself. 

*android.app.Activity.startNextMatchingActivity(Intent,Bundle)*

public boolean startNextMatchingActivity(
  android.content.Intent intent,
  android.os.Bundle options)

Special version of starting an activity, for use when you are replacing other 
activity components. You can use this to hand the Intent off to the next 
Activity that can handle it. You typically call this in 
(|android.app.Activity|) with the Intent returned by (|android.app.Activity|) . 


    intent - The intent to dispatch to the next activity. For correct behavior, this must be 
       the same as the Intent that started your own activity; the only changes 
       you can make are to the extras inside of it. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. 

    Returns: Returns a boolean indicating whether there was another Activity to start: true 
             if there was a next activity to start, false if there wasn't. In 
             general, if true is returned you will then want to call finish() 
             on yourself. 

*android.app.Activity.startSearch(String,boolean,Bundle,boolean)*

public void startSearch(
  java.lang.String initialQuery,
  boolean selectInitialQuery,
  android.os.Bundle appSearchData,
  boolean globalSearch)

This hook is called to launch the search UI. 

It is typically called from onSearchRequested(), either directly from 
Activity.onSearchRequested() or from an overridden version in any given 
Activity. If your goal is simply to activate search, it is preferred to call 
onSearchRequested(), which may have been overriden elsewhere in your Activity. 
If your goal is to inject specific data such as context data, it is preferred 
to override onSearchRequested(), so that any callers to it will benefit from 
the override. 


    initialQuery - Any non-null non-empty string will be inserted as pre-entered text in the 
       search query box. 
    selectInitialQuery - If true, the intial query will be preselected, which means that any further 
       typing will replace it. This is useful for cases where an entire 
       pre-formed query is being inserted. If false, the selection point will 
       be placed at the end of the inserted query. This is useful when the 
       inserted query is text that the user entered, and the user would expect 
       to be able to keep typing. This parameter is only meaningful if 
       initialQuery is a non-empty string. 
    appSearchData - An application can insert application-specific context here, in order to 
       improve quality or specificity of its own searches. This data will be 
       returned with SEARCH intent(s). Null if no extra data is required. 
    globalSearch - If false, this will only launch the search that has been specifically defined 
       by the application (which is usually defined as a local search). If no 
       default search is defined in the current application or activity, global 
       search will be launched. If true, this will always launch a 
       platform-global (e.g. web-based) search instead. 

*android.app.Activity.stopManagingCursor(Cursor)*

public void stopManagingCursor(android.database.Cursor c)

Given a Cursor that was previously given to (|android.app.Activity|) , stop the 
activity's management of that cursor. 

Warning: After calling this method on a cursor from a managed query, the system 
will not automatically close the cursor and you must call 
(|android.database.Cursor|) . 

    Deprecated: Use the new {@link android.content.CursorLoader} class with
 {@link LoaderManager} instead; this is also
 available on older platforms through the Android compatibility package.

    c - The Cursor that was being managed. 

*android.app.Activity.takeKeyEvents(boolean)*

public void takeKeyEvents(boolean get)

Request that key events come to this activity. Use this if your activity has no 
views with focus, but the activity still wants a chance to process key events. 



*android.app.Activity.triggerSearch(String,Bundle)*

public void triggerSearch(
  java.lang.String query,
  android.os.Bundle appSearchData)

Similar to (|android.app.Activity|) , but actually fires off the search query 
after invoking the search dialog. Made available for testing purposes. 


    query - The query to trigger. If empty, the request will be ignored. 
    appSearchData - An application can insert application-specific context here, in order to 
       improve quality or specificity of its own searches. This data will be 
       returned with SEARCH intent(s). Null if no extra data is required. 

*android.app.Activity.unregisterForContextMenu(View)*

public void unregisterForContextMenu(android.view.View view)

Prevents a context menu to be shown for the given view. This method will remove 
the (|android.view.View.OnCreateContextMenuListener|) on the view. 


    view - The view that should stop showing a context menu. 


