*android.content.Context* *Context* Interface to global information about an app

public abstract class Context
  extends    |java.lang.Object|

|android.content.Context_Description|
|android.content.Context_Fields|
|android.content.Context_Constructors|
|android.content.Context_Methods|

================================================================================

*android.content.Context_Fields*
|java.lang.String_android.content.Context.ACCESSIBILITY_SERVICE|
|java.lang.String_android.content.Context.ACCOUNT_SERVICE|
|java.lang.String_android.content.Context.ACTIVITY_SERVICE|
|java.lang.String_android.content.Context.ALARM_SERVICE|
|java.lang.String_android.content.Context.APP_OPS_SERVICE|
|java.lang.String_android.content.Context.APPWIDGET_SERVICE|
|java.lang.String_android.content.Context.AUDIO_SERVICE|
|java.lang.String_android.content.Context.BACKUP_SERVICE|
|int_android.content.Context.BIND_ABOVE_CLIENT|
|int_android.content.Context.BIND_ADJUST_WITH_ACTIVITY|
|int_android.content.Context.BIND_ALLOW_OOM_MANAGEMENT|
|int_android.content.Context.BIND_AUTO_CREATE|
|int_android.content.Context.BIND_DEBUG_UNBIND|
|int_android.content.Context.BIND_IMPORTANT|
|int_android.content.Context.BIND_NOT_FOREGROUND|
|int_android.content.Context.BIND_NOT_VISIBLE|
|int_android.content.Context.BIND_SHOWING_UI|
|int_android.content.Context.BIND_VISIBLE|
|int_android.content.Context.BIND_WAIVE_PRIORITY|
|java.lang.String_android.content.Context.BLUETOOTH_SERVICE|
|java.lang.String_android.content.Context.CAMERA_SERVICE|
|java.lang.String_android.content.Context.CAPTIONING_SERVICE|
|java.lang.String_android.content.Context.CLIPBOARD_SERVICE|
|java.lang.String_android.content.Context.CONNECTIVITY_SERVICE|
|java.lang.String_android.content.Context.CONSUMER_IR_SERVICE|
|int_android.content.Context.CONTEXT_IGNORE_SECURITY|
|int_android.content.Context.CONTEXT_INCLUDE_CODE|
|int_android.content.Context.CONTEXT_RESTRICTED|
|java.lang.String_android.content.Context.COUNTRY_DETECTOR|
|java.lang.String_android.content.Context.DEVICE_POLICY_SERVICE|
|java.lang.String_android.content.Context.DISPLAY_SERVICE|
|java.lang.String_android.content.Context.DOWNLOAD_SERVICE|
|java.lang.String_android.content.Context.DROPBOX_SERVICE|
|java.lang.String_android.content.Context.INPUT_METHOD_SERVICE|
|java.lang.String_android.content.Context.INPUT_SERVICE|
|java.lang.String_android.content.Context.KEYGUARD_SERVICE|
|java.lang.String_android.content.Context.LAYOUT_INFLATER_SERVICE|
|java.lang.String_android.content.Context.LOCATION_SERVICE|
|java.lang.String_android.content.Context.MEDIA_ROUTER_SERVICE|
|int_android.content.Context.MODE_APPEND|
|int_android.content.Context.MODE_ENABLE_WRITE_AHEAD_LOGGING|
|int_android.content.Context.MODE_MULTI_PROCESS|
|int_android.content.Context.MODE_PRIVATE|
|int_android.content.Context.MODE_WORLD_READABLE|
|int_android.content.Context.MODE_WORLD_WRITEABLE|
|java.lang.String_android.content.Context.NETWORK_POLICY_SERVICE|
|java.lang.String_android.content.Context.NETWORK_STATS_SERVICE|
|java.lang.String_android.content.Context.NETWORKMANAGEMENT_SERVICE|
|java.lang.String_android.content.Context.NFC_SERVICE|
|java.lang.String_android.content.Context.NOTIFICATION_SERVICE|
|java.lang.String_android.content.Context.NSD_SERVICE|
|java.lang.String_android.content.Context.POWER_SERVICE|
|java.lang.String_android.content.Context.PRINT_SERVICE|
|java.lang.String_android.content.Context.SEARCH_SERVICE|
|java.lang.String_android.content.Context.SENSOR_SERVICE|
|java.lang.String_android.content.Context.SERIAL_SERVICE|
|java.lang.String_android.content.Context.SIP_SERVICE|
|java.lang.String_android.content.Context.STATUS_BAR_SERVICE|
|java.lang.String_android.content.Context.STORAGE_SERVICE|
|java.lang.String_android.content.Context.TELEPHONY_SERVICE|
|java.lang.String_android.content.Context.TEXT_SERVICES_MANAGER_SERVICE|
|java.lang.String_android.content.Context.UI_MODE_SERVICE|
|java.lang.String_android.content.Context.UPDATE_LOCK_SERVICE|
|java.lang.String_android.content.Context.USB_SERVICE|
|java.lang.String_android.content.Context.USER_SERVICE|
|java.lang.String_android.content.Context.VIBRATOR_SERVICE|
|java.lang.String_android.content.Context.WALLPAPER_SERVICE|
|java.lang.String_android.content.Context.WIFI_P2P_SERVICE|
|java.lang.String_android.content.Context.WIFI_SERVICE|
|java.lang.String_android.content.Context.WINDOW_SERVICE|

*android.content.Context_Constructors*
|android.content.Context()|

*android.content.Context_Methods*
|android.content.Context.bindService(Intent,ServiceConnection,int)|Connect to a
|android.content.Context.bindServiceAsUser(Intent,ServiceConnection,int,UserHandle)|
|android.content.Context.checkCallingOrSelfPermission(String)|Determine whether
|android.content.Context.checkCallingOrSelfUriPermission(Uri,int)|Determine whe
|android.content.Context.checkCallingPermission(String)|Determine whether the c
|android.content.Context.checkCallingUriPermission(Uri,int)|Determine whether t
|android.content.Context.checkPermission(String,int,int)|Determine whether the 
|android.content.Context.checkUriPermission(Uri,int,int,int)|Determine whether 
|android.content.Context.checkUriPermission(Uri,String,String,int,int,int)|Chec
|android.content.Context.clearWallpaper()|
|android.content.Context.createConfigurationContext(Configuration)|Return a new
|android.content.Context.createDisplayContext(Display)|Return a new Context obj
|android.content.Context.createPackageContext(String,int)|Return a new Context 
|android.content.Context.createPackageContextAsUser(String,int,UserHandle)|Simi
|android.content.Context.databaseList()|Returns an array of strings naming the 
|android.content.Context.deleteDatabase(String)|Delete an existing private SQLi
|android.content.Context.deleteFile(String)|Delete the given private file assoc
|android.content.Context.enforceCallingOrSelfPermission(String,String)|If neith
|android.content.Context.enforceCallingOrSelfUriPermission(Uri,int,String)|If t
|android.content.Context.enforceCallingPermission(String,String)|If the calling
|android.content.Context.enforceCallingUriPermission(Uri,int,String)|If the cal
|android.content.Context.enforcePermission(String,int,int,String)|If the given 
|android.content.Context.enforceUriPermission(Uri,int,int,int,String)|If a part
|android.content.Context.enforceUriPermission(Uri,String,String,int,int,int,String)|
|android.content.Context.fileList()|Returns an array of strings naming the priv
|android.content.Context.getApplicationContext()|Return the context of the sing
|android.content.Context.getApplicationInfo()|Return the full application info 
|android.content.Context.getAssets()|Return an AssetManager instance for your a
|android.content.Context.getBasePackageName()|
|android.content.Context.getCacheDir()|Returns the absolute path to the applica
|android.content.Context.getClassLoader()|Return a class loader you can use to 
|android.content.Context.getContentResolver()|Return a ContentResolver instance
|android.content.Context.getDatabasePath(String)|Returns the absolute path on t
|android.content.Context.getDir(String,int)|Retrieve, creating if needed, a new
|android.content.Context.getDisplayAdjustments(int)|Gets the display adjustment
|android.content.Context.getExternalCacheDir()|Returns the absolute path to the
|android.content.Context.getExternalCacheDirs()|Returns absolute paths to appli
|android.content.Context.getExternalFilesDir(String)|Returns the absolute path 
|android.content.Context.getExternalFilesDirs(String)|Returns absolute paths to
|android.content.Context.getFilesDir()|Returns the absolute path to the directo
|android.content.Context.getFileStreamPath(String)|Returns the absolute path on
|android.content.Context.getMainLooper()|Return the Looper for the main thread 
|android.content.Context.getObbDir()|Return the primary external storage direct
|android.content.Context.getObbDirs()|Returns absolute paths to application-spe
|android.content.Context.getOpPackageName()|
|android.content.Context.getPackageCodePath()|Return the full path to this cont
|android.content.Context.getPackageManager()|Return PackageManager instance to 
|android.content.Context.getPackageName()|Return the name of this application's
|android.content.Context.getPackageResourcePath()|Return the full path to this 
|android.content.Context.getResources()|Return a Resources instance for your ap
|android.content.Context.getSharedPreferences(String,int)|Retrieve and hold the
|android.content.Context.getSharedPrefsFile(String)|Return the full path to the
|android.content.Context.getString(int)|Return a localized string from the appl
|android.content.Context.getString(int,Object...)|Return a localized formatted 
|android.content.Context.getSystemService(String)|Return the handle to a system
|android.content.Context.getText(int)|Return a localized, styled CharSequence f
|android.content.Context.getTheme()|Return the Theme object associated with thi
|android.content.Context.getThemeResId()|
|android.content.Context.getUserId()|Get the userId associated with this contex
|android.content.Context.getWallpaper()|
|android.content.Context.getWallpaperDesiredMinimumHeight()|
|android.content.Context.getWallpaperDesiredMinimumWidth()|
|android.content.Context.grantUriPermission(String,Uri,int)|Grant permission to
|android.content.Context.isRestricted()|Indicates whether this Context is restr
|android.content.Context.obtainStyledAttributes(AttributeSet,int[])|Retrieve st
|android.content.Context.obtainStyledAttributes(AttributeSet,int[],int,int)|Ret
|android.content.Context.obtainStyledAttributes(int[])|Retrieve styled attribut
|android.content.Context.obtainStyledAttributes(int,int[])|Retrieve styled attr
|android.content.Context.openFileInput(String)|Open a private file associated w
|android.content.Context.openFileOutput(String,int)|Open a private file associa
|android.content.Context.openOrCreateDatabase(String,int,SQLiteDatabase.CursorFactory)|
|android.content.Context.openOrCreateDatabase(String,int,SQLiteDatabase.CursorFactory,DatabaseErrorHandler)|
|android.content.Context.peekWallpaper()|
|android.content.Context.registerComponentCallbacks(ComponentCallbacks)|Add a n
|android.content.Context.registerReceiver(BroadcastReceiver,IntentFilter)|Regis
|android.content.Context.registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)|
|android.content.Context.registerReceiverAsUser(BroadcastReceiver,UserHandle,IntentFilter,String,Handler)|
|android.content.Context.removeStickyBroadcast(Intent)|Remove the data previous
|android.content.Context.removeStickyBroadcastAsUser(Intent,UserHandle)|Version
|android.content.Context.revokeUriPermission(Uri,int)|Remove all permissions to
|android.content.Context.sendBroadcast(Intent)|Broadcast the given intent to al
|android.content.Context.sendBroadcast(Intent,String)|Broadcast the given inten
|android.content.Context.sendBroadcast(Intent,String,int)|Like#sendBroadcast(In
|android.content.Context.sendBroadcastAsUser(Intent,UserHandle)|Version of#send
|android.content.Context.sendBroadcastAsUser(Intent,UserHandle,String)|Version 
|android.content.Context.sendOrderedBroadcast(Intent,String)|Broadcast the give
|android.content.Context.sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)|
|android.content.Context.sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle)|
|android.content.Context.sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)|
|android.content.Context.sendStickyBroadcast(Intent)|Perform a#sendBroadcast(In
|android.content.Context.sendStickyBroadcastAsUser(Intent,UserHandle)|Version o
|android.content.Context.sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)|
|android.content.Context.sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)|
|android.content.Context.setTheme(int)|Set the base theme for this context.
|android.content.Context.setWallpaper(Bitmap)|
|android.content.Context.startActivities(Intent[])|Same as#startActivities(Inte
|android.content.Context.startActivities(Intent[],Bundle)|Launch multiple new a
|android.content.Context.startActivitiesAsUser(Intent[],Bundle,UserHandle)|
|android.content.Context.startActivity(Intent)|Same as#startActivity(Intent, Bu
|android.content.Context.startActivity(Intent,Bundle)|Launch a new activity.
|android.content.Context.startActivityAsUser(Intent,Bundle,UserHandle)|Version 
|android.content.Context.startActivityAsUser(Intent,UserHandle)|Version of#star
|android.content.Context.startInstrumentation(ComponentName,String,Bundle)|Star
|android.content.Context.startIntentSender(IntentSender,Intent,int,int,int)|Sam
|android.content.Context.startIntentSender(IntentSender,Intent,int,int,int,Bundle)|
|android.content.Context.startService(Intent)|Request that a given application 
|android.content.Context.startServiceAsUser(Intent,UserHandle)|
|android.content.Context.stopService(Intent)|Request that a given application s
|android.content.Context.stopServiceAsUser(Intent,UserHandle)|
|android.content.Context.unbindService(ServiceConnection)|Disconnect from an ap
|android.content.Context.unregisterComponentCallbacks(ComponentCallbacks)|Remov
|android.content.Context.unregisterReceiver(BroadcastReceiver)|Unregister a pre

*android.content.Context_Description*

Interface to global information about an application environment. This is an 
abstract class whose implementation is provided by the Android system. It 
allows access to application-specific resources and classes, as well as 
up-calls for application-level operations such as launching activities, 
broadcasting and receiving intents, etc. 



*java.lang.String_android.content.Context.ACCESSIBILITY_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.view.accessibility.AccessibilityManager|) for giving the user 
feedback for UI events through the registered event listeners. 


*java.lang.String_android.content.Context.ACCOUNT_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.accounts.AccountManager|) for receiving intents at a time of your 
choosing. 


*java.lang.String_android.content.Context.ACTIVITY_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.app.ActivityManager|) for interacting with the global system state. 


*java.lang.String_android.content.Context.ALARM_SERVICE*

Use with (|android.content.Context|) to retrieve a (|android.app.AlarmManager|) 
for receiving intents at a time of your choosing. 


*java.lang.String_android.content.Context.APP_OPS_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.app.AppOpsManager|) for tracking application operations on the 
device. 


*java.lang.String_android.content.Context.APPWIDGET_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.appwidget.AppWidgetManager|) for accessing AppWidgets. 


*java.lang.String_android.content.Context.AUDIO_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.media.AudioManager|) for handling management of volume, ringer modes 
and audio routing. 


*java.lang.String_android.content.Context.BACKUP_SERVICE*

Use with (|android.content.Context|) to retrieve an 
IBackupManager(|android.app.backup.IBackupManager|) for communicating with the 
backup mechanism. 


*int_android.content.Context.BIND_ABOVE_CLIENT*

Flag for (|android.content.Context|) : indicates that the client application 
binding to this service considers the service to be more important than the app 
itself. When set, the platform will try to have the out of memory killer kill 
the app before it kills the service it is bound to, though this is not 
guaranteed to be the case. 


*int_android.content.Context.BIND_ADJUST_WITH_ACTIVITY*

Flag for (|android.content.Context|) : If binding from an activity, allow the 
target service's process importance to be raised based on whether the activity 
is visible to the user, regardless whether another flag is used to reduce the 
amount that the client process's overall importance is used to impact it. 


*int_android.content.Context.BIND_ALLOW_OOM_MANAGEMENT*

Flag for (|android.content.Context|) : allow the process hosting the bound 
service to go through its normal memory management. It will be treated more 
like a running service, allowing the system to (temporarily) expunge the 
process if low on memory or for some other whim it may have, and being more 
aggressive about making it a candidate to be killed (and restarted) if running 
for a long time. 


*int_android.content.Context.BIND_AUTO_CREATE*

Flag for (|android.content.Context|) : automatically create the service as long 
as the binding exists. Note that while this will create the service, its 
(|android.app.Service|) method will still only be called due to an explicit 
call to (|android.content.Context|) . Even without that, though, this still 
provides you with access to the service object while the service is created. 

Note that prior to (|android.os.Build.VERSION_CODES|) , not supplying this flag 
would also impact how important the system consider's the target service's 
process to be. When set, the only way for it to be raised was by binding from a 
service in which case it will only be important when that activity is in the 
foreground. Now to achieve this behavior you must explicitly supply the new 
flag (|android.content.Context|) . For compatibility, old applications that 
don't specify (|android.content.Context|) will automatically have the flags 
(|android.content.Context|) and (|android.content.Context|) set for them in 
order to achieve the same result. 


*int_android.content.Context.BIND_DEBUG_UNBIND*

Flag for (|android.content.Context|) : include debugging help for mismatched 
calls to unbind. When this flag is set, the callstack of the following 
(|android.content.Context|) call is retained, to be printed if a later 
incorrect unbind call is made. Note that doing this requires retaining 
information about the binding that was made for the lifetime of the app, 
resulting in a leak -- this should only be used for debugging. 


*int_android.content.Context.BIND_IMPORTANT*

Flag for (|android.content.Context|) : this service is very important to the 
client, so should be brought to the foreground process level when the client 
is. Normally a process can only be raised to the visibility level by a client, 
even if that client is in the foreground. 


*int_android.content.Context.BIND_NOT_FOREGROUND*

Flag for (|android.content.Context|) : don't allow this binding to raise the 
target service's process to the foreground scheduling priority. It will still 
be raised to at least the same memory priority as the client (so that its 
process will not be killable in any situation where the client is not 
killable), but for CPU scheduling purposes it may be left in the background. 
This only has an impact in the situation where the binding client is a 
foreground process and the target service is in a background process. 


*int_android.content.Context.BIND_NOT_VISIBLE*

Flag for (|android.content.Context|) : Don't consider the bound service to be 
visible, even if the caller is visible. 


*int_android.content.Context.BIND_SHOWING_UI*




*int_android.content.Context.BIND_VISIBLE*




*int_android.content.Context.BIND_WAIVE_PRIORITY*

Flag for (|android.content.Context|) : don't impact the scheduling or memory 
management priority of the target service's hosting process. Allows the 
service's process to be managed on the background LRU list just like a regular 
application process in the background. 


*java.lang.String_android.content.Context.BLUETOOTH_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.bluetooth.BluetoothAdapter|) for using Bluetooth. 


*java.lang.String_android.content.Context.CAMERA_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.hardware.camera2.CameraManager|) for interacting with camera devices. 


*java.lang.String_android.content.Context.CAPTIONING_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.view.accessibility.CaptioningManager|) for obtaining captioning 
properties and listening for changes in captioning preferences. 


*java.lang.String_android.content.Context.CLIPBOARD_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.text.ClipboardManager|) for accessing and modifying the contents of 
the global clipboard. 


*java.lang.String_android.content.Context.CONNECTIVITY_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.net.ConnectivityManager|) for handling management of network 
connections. 


*java.lang.String_android.content.Context.CONSUMER_IR_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.hardware.ConsumerIrManager|) for transmitting infrared signals from 
the device. 


*int_android.content.Context.CONTEXT_IGNORE_SECURITY*

Flag for use with (|android.content.Context|) : ignore any security 
restrictions on the Context being requested, allowing it to always be loaded. 
For use with (|android.content.Context|) to allow code to be loaded into a 
process even when it isn't safe to do so. Use with extreme care! 


*int_android.content.Context.CONTEXT_INCLUDE_CODE*

Flag for use with (|android.content.Context|) : include the application code 
with the context. This means loading code into the caller's process, so that 
(|android.content.Context|) can be used to instantiate the application's 
classes. Setting this flags imposes security restrictions on what application 
context you can access; if the requested application can not be safely loaded 
into your process, java.lang.SecurityException will be thrown. If this flag is 
not set, there will be no restrictions on the packages that can be loaded, but 
(|android.content.Context|) will always return the default system class loader. 


*int_android.content.Context.CONTEXT_RESTRICTED*

Flag for use with (|android.content.Context|) : a restricted context may 
disable specific features. For instance, a View associated with a restricted 
context would ignore particular XML attributes. 


*java.lang.String_android.content.Context.COUNTRY_DETECTOR*

Use with (|android.content.Context|) to retrieve a 
(|android.location.CountryDetector|) for detecting the country that the user is 
in. 


*java.lang.String_android.content.Context.DEVICE_POLICY_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.app.admin.DevicePolicyManager|) for working with global device policy 
management. 


*java.lang.String_android.content.Context.DISPLAY_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.hardware.display.DisplayManager|) for interacting with display 
devices. 


*java.lang.String_android.content.Context.DOWNLOAD_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.app.DownloadManager|) for requesting HTTP downloads. 


*java.lang.String_android.content.Context.DROPBOX_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.os.DropBoxManager|) instance for recording diagnostic logs. 


*java.lang.String_android.content.Context.INPUT_METHOD_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.view.inputmethod.InputMethodManager|) for accessing input methods. 


*java.lang.String_android.content.Context.INPUT_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.hardware.input.InputManager|) for interacting with input devices. 


*java.lang.String_android.content.Context.KEYGUARD_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.app.NotificationManager|) for controlling keyguard. 


*java.lang.String_android.content.Context.LAYOUT_INFLATER_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.view.LayoutInflater|) for inflating layout resources in this context. 


*java.lang.String_android.content.Context.LOCATION_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.location.LocationManager|) for controlling location updates. 


*java.lang.String_android.content.Context.MEDIA_ROUTER_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.media.MediaRouter|) for controlling and managing routing of media. 


*int_android.content.Context.MODE_APPEND*

File creation mode: for use with (|android.content.Context|) , if the file 
already exists then write data to the end of the existing file instead of 
erasing it. 


*int_android.content.Context.MODE_ENABLE_WRITE_AHEAD_LOGGING*

Database open flag: when set, the database is opened with write-ahead logging 
enabled by default. 


*int_android.content.Context.MODE_MULTI_PROCESS*

SharedPreference loading flag: when set, the file on disk will be checked for 
modification even if the shared preferences instance is already loaded in this 
process. This behavior is sometimes desired in cases where the application has 
multiple processes, all writing to the same SharedPreferences file. Generally 
there are better forms of communication between processes, though. 

This was the legacy (but undocumented) behavior in and before Gingerbread 
(Android 2.3) and this flag is implied when targetting such releases. For 
applications targetting SDK versions greater than Android 2.3, this flag must 
be explicitly set if desired. 


*int_android.content.Context.MODE_PRIVATE*

File creation mode: the default mode, where the created file can only be 
accessed by the calling application (or all applications sharing the same user 
ID). 


*int_android.content.Context.MODE_WORLD_READABLE*




*int_android.content.Context.MODE_WORLD_WRITEABLE*




*java.lang.String_android.content.Context.NETWORK_POLICY_SERVICE*




*java.lang.String_android.content.Context.NETWORK_STATS_SERVICE*




*java.lang.String_android.content.Context.NETWORKMANAGEMENT_SERVICE*

Constant for the internal network management service, not really a Context 
service. 


*java.lang.String_android.content.Context.NFC_SERVICE*

Use with (|android.content.Context|) to retrieve a (|android.nfc.NfcManager|) 
for using NFC. 


*java.lang.String_android.content.Context.NOTIFICATION_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.app.NotificationManager|) for informing the user of background 
events. 


*java.lang.String_android.content.Context.NSD_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.net.nsd.NsdManager|) for handling management of network service 
discovery 


*java.lang.String_android.content.Context.POWER_SERVICE*

Use with (|android.content.Context|) to retrieve a (|android.os.PowerManager|) 
for controlling power management, including "wake locks," which let you keep 
the device on while you're running long tasks. 


*java.lang.String_android.content.Context.PRINT_SERVICE*

(|android.print.PrintManager|) for printing and managing printers and print 
tasks. 


*java.lang.String_android.content.Context.SEARCH_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.app.SearchManager|) for handling searches. 


*java.lang.String_android.content.Context.SENSOR_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.hardware.SensorManager|) for accessing sensors. 


*java.lang.String_android.content.Context.SERIAL_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.hardware.SerialManager|) for access to serial ports. 


*java.lang.String_android.content.Context.SIP_SERVICE*




*java.lang.String_android.content.Context.STATUS_BAR_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.app.StatusBarManager|) for interacting with the status bar. 


*java.lang.String_android.content.Context.STORAGE_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.os.storage.StorageManager|) for accessing system storage functions. 


*java.lang.String_android.content.Context.TELEPHONY_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.telephony.TelephonyManager|) for handling management the telephony 
features of the device. 


*java.lang.String_android.content.Context.TEXT_SERVICES_MANAGER_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.view.textservice.TextServicesManager|) for accessing text services. 


*java.lang.String_android.content.Context.UI_MODE_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.app.UiModeManager|) for controlling UI modes. 


*java.lang.String_android.content.Context.UPDATE_LOCK_SERVICE*

Use with (|android.content.Context|) to retrieve a (|android.os.IUpdateLock|) 
for managing runtime sequences that must not be interrupted by headless OTA 
application or similar. 


*java.lang.String_android.content.Context.USB_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.hardware.usb.UsbManager|) for access to USB devices (as a USB host) 
and for controlling this device's behavior as a USB device. 


*java.lang.String_android.content.Context.USER_SERVICE*

Use with (|android.content.Context|) to retrieve a (|android.os.UserManager|) 
for managing users on devices that support multiple users. 


*java.lang.String_android.content.Context.VIBRATOR_SERVICE*

Use with (|android.content.Context|) to retrieve a (|android.os.Vibrator|) for 
interacting with the vibration hardware. 


*java.lang.String_android.content.Context.WALLPAPER_SERVICE*

Use with (|android.content.Context|) to retrieve a 
com.android.server.WallpaperService for accessing wallpapers. 


*java.lang.String_android.content.Context.WIFI_P2P_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.net.wifi.p2p.WifiP2pManager|) for handling management of Wi-Fi 
peer-to-peer connections. 


*java.lang.String_android.content.Context.WIFI_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.net.wifi.WifiManager|) for handling management of Wi-Fi access. 


*java.lang.String_android.content.Context.WINDOW_SERVICE*

Use with (|android.content.Context|) to retrieve a 
(|android.view.WindowManager|) for accessing the system's window manager. 



*android.content.Context()*

public Context()




*android.content.Context.bindService(Intent,ServiceConnection,int)*

public abstract boolean bindService(
  android.content.Intent service,
  android.content.ServiceConnection conn,
  int flags)

Connect to an application service, creating it if needed. This defines a 
dependency between your application and the service. The given conn will 
receive the service object when it is created and be told if it dies and 
restarts. The service will be considered required by the system only for as 
long as the calling context exists. For example, if this Context is an Activity 
that is stopped, the service will not be required to continue running until the 
Activity is resumed. 

This function will throw (|java.lang.SecurityException|) if you do not have 
permission to bind to the given service. 

Note: this method can not be called from a 
(|android.content.BroadcastReceiver|) component. A pattern you can use to 
communicate from a BroadcastReceiver to a Service is to call 
(|android.content.Context|) with the arguments containing the command to be 
sent, with the service calling its (|android.app.Service|) method when done 
executing that command. See the API demo App/Service/Service Start Arguments 
Controller for an illustration of this. It is okay, however, to use this method 
from a BroadcastReceiver that has been registered with 
(|android.content.Context|) , since the lifetime of this BroadcastReceiver is 
tied to another object (the one that registered it). 


    service - Identifies the service to connect to. The Intent may specify either an explicit 
       component name, or a logical description (action, category, etc) to 
       match an {@link IntentFilter} published by a service. 
    conn - Receives information as the service is started and stopped. This must be a 
       valid ServiceConnection object; it must not be null. 
    flags - Operation options for the binding. May be 0, {@link #BIND_AUTO_CREATE}, {@link 
       #BIND_DEBUG_UNBIND}, {@link #BIND_NOT_FOREGROUND}, {@link 
       #BIND_ABOVE_CLIENT}, {@link #BIND_ALLOW_OOM_MANAGEMENT}, or {@link 
       #BIND_WAIVE_PRIORITY}. 

    Returns: If you have successfully bound to the service, {@code true} is returned; {@code 
             false} is returned if the connection is not made so you will not 
             receive the service object. 

*android.content.Context.bindServiceAsUser(Intent,ServiceConnection,int,UserHandle)*

public boolean bindServiceAsUser(
  android.content.Intent service,
  android.content.ServiceConnection conn,
  int flags,
  android.os.UserHandle user)

Same as (|android.content.Context|) , but with an explicit userHandle argument 
for use by system server and other multi-user aware code. 



*android.content.Context.checkCallingOrSelfPermission(String)*

public abstract int checkCallingOrSelfPermission(java.lang.String permission)

Determine whether the calling process of an IPC or you have been granted a 
particular permission. This is the same as (|android.content.Context|) , except 
it grants your own permissions if you are not currently processing an IPC. Use 
with care! 


    permission - The name of the permission being checked. 

    Returns: {@link PackageManager#PERMISSION_GRANTED} if the calling pid/uid is allowed 
             that permission, or {@link PackageManager#PERMISSION_DENIED} if it 
             is not. 

*android.content.Context.checkCallingOrSelfUriPermission(Uri,int)*

public abstract int checkCallingOrSelfUriPermission(
  android.net.Uri uri,
  int modeFlags)

Determine whether the calling process of an IPC or you has been granted 
permission to access a specific URI. This is the same as 
(|android.content.Context|) , except it grants your own permissions if you are 
not currently processing an IPC. Use with care! 


    uri - The uri that is being checked. 
    modeFlags - The type of access to grant. May be one or both of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 

    Returns: {@link PackageManager#PERMISSION_GRANTED} if the caller is allowed to access 
             that uri, or {@link PackageManager#PERMISSION_DENIED} if it is 
             not. 

*android.content.Context.checkCallingPermission(String)*

public abstract int checkCallingPermission(java.lang.String permission)

Determine whether the calling process of an IPC you are handling has been 
granted a particular permission. This is basically the same as calling 
(|android.content.Context|) with the pid and uid returned by 
(|android.os.Binder|) and (|android.os.Binder|) . One important difference is 
that if you are not currently processing an IPC, this function will always 
fail. This is done to protect against accidentally leaking permissions; you can 
use (|android.content.Context|) to avoid this protection. 


    permission - The name of the permission being checked. 

    Returns: {@link PackageManager#PERMISSION_GRANTED} if the calling pid/uid is allowed 
             that permission, or {@link PackageManager#PERMISSION_DENIED} if it 
             is not. 

*android.content.Context.checkCallingUriPermission(Uri,int)*

public abstract int checkCallingUriPermission(
  android.net.Uri uri,
  int modeFlags)

Determine whether the calling process and user ID has been granted permission 
to access a specific URI. This is basically the same as calling 
(|android.content.Context|) with the pid and uid returned by 
(|android.os.Binder|) and (|android.os.Binder|) . One important difference is 
that if you are not currently processing an IPC, this function will always 
fail. 


    uri - The uri that is being checked. 
    modeFlags - The type of access to grant. May be one or both of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 

    Returns: {@link PackageManager#PERMISSION_GRANTED} if the caller is allowed to access 
             that uri, or {@link PackageManager#PERMISSION_DENIED} if it is 
             not. 

*android.content.Context.checkPermission(String,int,int)*

public abstract int checkPermission(
  java.lang.String permission,
  int pid,
  int uid)

Determine whether the given permission is allowed for a particular process and 
user ID running in the system. 


    permission - The name of the permission being checked. 
    pid - The process ID being checked against. Must be > 0. 
    uid - The user ID being checked against. A uid of 0 is the root user, which will pass 
       every permission check. 

    Returns: {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed that 
             permission, or {@link PackageManager#PERMISSION_DENIED} if it is 
             not. 

*android.content.Context.checkUriPermission(Uri,int,int,int)*

public abstract int checkUriPermission(
  android.net.Uri uri,
  int pid,
  int uid,
  int modeFlags)

Determine whether a particular process and user ID has been granted permission 
to access a specific URI. This only checks for permissions that have been 
explicitly granted -- if the given process/uid has more general access to the 
URI's content provider then this check will always fail. 


    uri - The uri that is being checked. 
    pid - The process ID being checked against. Must be > 0. 
    uid - The user ID being checked against. A uid of 0 is the root user, which will pass 
       every permission check. 
    modeFlags - The type of access to grant. May be one or both of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 

    Returns: {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to 
             access that uri, or {@link PackageManager#PERMISSION_DENIED} if it 
             is not. 

*android.content.Context.checkUriPermission(Uri,String,String,int,int,int)*

public abstract int checkUriPermission(
  android.net.Uri uri,
  java.lang.String readPermission,
  java.lang.String writePermission,
  int pid,
  int uid,
  int modeFlags)

Check both a Uri and normal permission. This allows you to perform both 
(|android.content.Context|) and (|android.content.Context|) in one call. 


    uri - The Uri whose permission is to be checked, or null to not do this check. 
    readPermission - The permission that provides overall read access, or null to not do this check. 
    writePermission - The permission that provides overall write acess, or null to not do this check. 
    pid - The process ID being checked against. Must be > 0. 
    uid - The user ID being checked against. A uid of 0 is the root user, which will pass 
       every permission check. 
    modeFlags - The type of access to grant. May be one or both of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 

    Returns: {@link PackageManager#PERMISSION_GRANTED} if the caller is allowed to access 
             that uri or holds one of the given permissions, or {@link 
             PackageManager#PERMISSION_DENIED} if it is not. 

*android.content.Context.clearWallpaper()*

public abstract void clearWallpaper()
  throws |java.io.IOException|
         


    Deprecated: Use {@link android.app.WallpaperManager#clear
 WallpaperManager.clear()} instead.
 <p>This method requires the caller to hold the permission
 {@link android.Manifest.permission#SET_WALLPAPER}.


*android.content.Context.createConfigurationContext(Configuration)*

public abstract |android.content.Context| createConfigurationContext(android.content.res.Configuration overrideConfiguration)

Return a new Context object for the current Context but whose resources are 
adjusted to match the given Configuration. Each call to this method returns a 
new instance of a Context object; Context objects are not shared, however 
common state (ClassLoader, other Resources for the same configuration) may be 
so the Context itself can be fairly lightweight. 


    overrideConfiguration - A {@link Configuration} specifying what values to modify in the base 
       Configuration of the original Context's resources. If the base 
       configuration changes (such as due to an orientation change), the 
       resources of this context will also change except for those that have 
       been explicitly overridden with a value here. 

    Returns: A {@link Context} with the given configuration override. 

*android.content.Context.createDisplayContext(Display)*

public abstract |android.content.Context| createDisplayContext(android.view.Display display)

Return a new Context object for the current Context but whose resources are 
adjusted to match the metrics of the given Display. Each call to this method 
returns a new instance of a Context object; Context objects are not shared, 
however common state (ClassLoader, other Resources for the same configuration) 
may be so the Context itself can be fairly lightweight. 

The returned display Context provides a (|android.view.WindowManager|) (see 
(|android.content.Context|) ) that is configured to show windows on the given 
display. The WindowManager's (|android.view.WindowManager|) method can be used 
to retrieve the Display from the returned Context. 


    display - A {@link Display} object specifying the display for whose metrics the Context's 
       resources should be tailored and upon which new windows should be shown. 

    Returns: A {@link Context} for the display. 

*android.content.Context.createPackageContext(String,int)*

public abstract |android.content.Context| createPackageContext(
  java.lang.String packageName,
  int flags)
  throws |android.content.pm.PackageManager.NameNotFoundException|
         
Return a new Context object for the given application name. This Context is the 
same as what the named application gets when it is launched, containing the 
same resources and class loader. Each call to this method returns a new 
instance of a Context object; Context objects are not shared, however they 
share common state (Resources, ClassLoader, etc) so the Context instance itself 
is fairly lightweight. 

Throws (|PackageManager.NameNotFoundException|) if there is no application with 
the given package name. 

Throws (|java.lang.SecurityException|) if the Context requested can not be 
loaded into the caller's process for security reasons (see 
(|android.content.Context|) for more information}. 


    packageName - Name of the application's package. 
    flags - Option flags, one of {@link #CONTEXT_INCLUDE_CODE} or {@link 
       #CONTEXT_IGNORE_SECURITY}. 

    Returns: A {@link Context} for the application. 

*android.content.Context.createPackageContextAsUser(String,int,UserHandle)*

public abstract |android.content.Context| createPackageContextAsUser(
  java.lang.String packageName,
  int flags,
  android.os.UserHandle user)
  throws |android.content.pm.PackageManager.NameNotFoundException|
         
Similar to (|android.content.Context|) , but with a different 
(|android.os.UserHandle|) . For example, (|android.content.Context|) will open 
any (|android.net.Uri|) as the given user. 



*android.content.Context.databaseList()*

public abstract |java.lang.String|[] databaseList()

Returns an array of strings naming the private databases associated with this 
Context's application package. 



    Returns: Array of strings naming the private databases. 

*android.content.Context.deleteDatabase(String)*

public abstract boolean deleteDatabase(java.lang.String name)

Delete an existing private SQLiteDatabase associated with this Context's 
application package. 


    name - The name (unique in the application package) of the database. 

    Returns: {@code true} if the database was successfully deleted; else {@code false}. 

*android.content.Context.deleteFile(String)*

public abstract boolean deleteFile(java.lang.String name)

Delete the given private file associated with this Context's application 
package. 


    name - The name of the file to delete; can not contain path separators. 

    Returns: {@code true} if the file was successfully deleted; else {@code false}. 

*android.content.Context.enforceCallingOrSelfPermission(String,String)*

public abstract void enforceCallingOrSelfPermission(
  java.lang.String permission,
  java.lang.String message)

If neither you nor the calling process of an IPC you are handling has been 
granted a particular permission, throw a (|java.lang.SecurityException|) . This 
is the same as (|android.content.Context|) , except it grants your own 
permissions if you are not currently processing an IPC. Use with care! 


    permission - The name of the permission being checked. 
    message - A message to include in the exception if it is thrown. 

*android.content.Context.enforceCallingOrSelfUriPermission(Uri,int,String)*

public abstract void enforceCallingOrSelfUriPermission(
  android.net.Uri uri,
  int modeFlags,
  java.lang.String message)

If the calling process of an IPC or you has not been granted permission to 
access a specific URI, throw (|java.lang.SecurityException|) . This is the same 
as (|android.content.Context|) , except it grants your own permissions if you 
are not currently processing an IPC. Use with care! 


    uri - The uri that is being checked. 
    modeFlags - The type of access to grant. May be one or both of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 
    message - A message to include in the exception if it is thrown. 

*android.content.Context.enforceCallingPermission(String,String)*

public abstract void enforceCallingPermission(
  java.lang.String permission,
  java.lang.String message)

If the calling process of an IPC you are handling has not been granted a 
particular permission, throw a (|java.lang.SecurityException|) . This is 
basically the same as calling (|android.content.Context|) with the pid and uid 
returned by (|android.os.Binder|) and (|android.os.Binder|) . One important 
difference is that if you are not currently processing an IPC, this function 
will always throw the SecurityException. This is done to protect against 
accidentally leaking permissions; you can use (|android.content.Context|) to 
avoid this protection. 


    permission - The name of the permission being checked. 
    message - A message to include in the exception if it is thrown. 

*android.content.Context.enforceCallingUriPermission(Uri,int,String)*

public abstract void enforceCallingUriPermission(
  android.net.Uri uri,
  int modeFlags,
  java.lang.String message)

If the calling process and user ID has not been granted permission to access a 
specific URI, throw (|java.lang.SecurityException|) . This is basically the 
same as calling (|android.content.Context|) with the pid and uid returned by 
(|android.os.Binder|) and (|android.os.Binder|) . One important difference is 
that if you are not currently processing an IPC, this function will always 
throw a SecurityException. 


    uri - The uri that is being checked. 
    modeFlags - The type of access to grant. May be one or both of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 
    message - A message to include in the exception if it is thrown. 

*android.content.Context.enforcePermission(String,int,int,String)*

public abstract void enforcePermission(
  java.lang.String permission,
  int pid,
  int uid,
  java.lang.String message)

If the given permission is not allowed for a particular process and user ID 
running in the system, throw a (|java.lang.SecurityException|) . 


    permission - The name of the permission being checked. 
    pid - The process ID being checked against. Must be > 0. 
    uid - The user ID being checked against. A uid of 0 is the root user, which will pass 
       every permission check. 
    message - A message to include in the exception if it is thrown. 

*android.content.Context.enforceUriPermission(Uri,int,int,int,String)*

public abstract void enforceUriPermission(
  android.net.Uri uri,
  int pid,
  int uid,
  int modeFlags,
  java.lang.String message)

If a particular process and user ID has not been granted permission to access a 
specific URI, throw (|java.lang.SecurityException|) . This only checks for 
permissions that have been explicitly granted -- if the given process/uid has 
more general access to the URI's content provider then this check will always 
fail. 


    uri - The uri that is being checked. 
    pid - The process ID being checked against. Must be > 0. 
    uid - The user ID being checked against. A uid of 0 is the root user, which will pass 
       every permission check. 
    modeFlags - The type of access to grant. May be one or both of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 
    message - A message to include in the exception if it is thrown. 

*android.content.Context.enforceUriPermission(Uri,String,String,int,int,int,String)*

public abstract void enforceUriPermission(
  android.net.Uri uri,
  java.lang.String readPermission,
  java.lang.String writePermission,
  int pid,
  int uid,
  int modeFlags,
  java.lang.String message)

Enforce both a Uri and normal permission. This allows you to perform both 
(|android.content.Context|) and (|android.content.Context|) in one call. 


    uri - The Uri whose permission is to be checked, or null to not do this check. 
    readPermission - The permission that provides overall read access, or null to not do this check. 
    writePermission - The permission that provides overall write acess, or null to not do this check. 
    pid - The process ID being checked against. Must be > 0. 
    uid - The user ID being checked against. A uid of 0 is the root user, which will pass 
       every permission check. 
    modeFlags - The type of access to grant. May be one or both of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 
    message - A message to include in the exception if it is thrown. 

*android.content.Context.fileList()*

public abstract |java.lang.String|[] fileList()

Returns an array of strings naming the private files associated with this 
Context's application package. 



    Returns: Array of strings naming the private files. 

*android.content.Context.getApplicationContext()*

public abstract |android.content.Context| getApplicationContext()

Return the context of the single, global Application object of the current 
process. This generally should only be used if you need a Context whose 
lifecycle is separate from the current context, that is tied to the lifetime of 
the process rather than the current component. 

Consider for example how this interacts with (|android.content.Context|) : 

If used from an Activity context, the receiver is being registered within that 
activity. This means that you are expected to unregister before the activity is 
done being destroyed; in fact if you do not do so, the framework will clean up 
your leaked registration as it removes the activity and log an error. Thus, if 
you use the Activity context to register a receiver that is static (global to 
the process, not associated with an Activity instance) then that registration 
will be removed on you at whatever point the activity you used is destroyed. If 
used from the Context returned here, the receiver is being registered with the 
global state associated with your application. Thus it will never be 
unregistered for you. This is necessary if the receiver is associated with 
static data, not a particular component. However using the ApplicationContext 
elsewhere can easily lead to serious leaks if you forget to unregister, unbind, 
etc. 



*android.content.Context.getApplicationInfo()*

public abstract |android.content.pm.ApplicationInfo| getApplicationInfo()

Return the full application info for this context's package. 



*android.content.Context.getAssets()*

public abstract |android.content.res.AssetManager| getAssets()

Return an AssetManager instance for your application's package. 



*android.content.Context.getBasePackageName()*

public abstract |java.lang.String| getBasePackageName()





*android.content.Context.getCacheDir()*

public abstract |java.io.File| getCacheDir()

Returns the absolute path to the application specific cache directory on the 
filesystem. These files will be ones that get deleted first when the device 
runs low on storage. There is no guarantee when these files will be deleted. 

Note: you should not rely on the system deleting these files for you; you 
should always have a reasonable maximum, such as 1 MB, for the amount of space 
you consume with cache files, and prune those files when exceeding that space. 



    Returns: The path of the directory holding application cache files. 

*android.content.Context.getClassLoader()*

public abstract |java.lang.ClassLoader| getClassLoader()

Return a class loader you can use to retrieve classes in this package. 



*android.content.Context.getContentResolver()*

public abstract |android.content.ContentResolver| getContentResolver()

Return a ContentResolver instance for your application's package. 



*android.content.Context.getDatabasePath(String)*

public abstract |java.io.File| getDatabasePath(java.lang.String name)

Returns the absolute path on the filesystem where a database created with 
(|android.content.Context|) is stored. 


    name - The name of the database for which you would like to get its path. 

    Returns: An absolute path to the given database. 

*android.content.Context.getDir(String,int)*

public abstract |java.io.File| getDir(
  java.lang.String name,
  int mode)

Retrieve, creating if needed, a new directory in which the application can 
place its own custom data files. You can use the returned File object to create 
and access files in this directory. Note that files created through a File 
object will only be accessible by your own application; you can only set the 
mode of the entire directory, not of individual files. 


    name - Name of the directory to retrieve. This is a directory that is created as part 
       of your application data. 
    mode - Operating mode. Use 0 or {@link #MODE_PRIVATE} for the default operation, 
       {@link #MODE_WORLD_READABLE} and {@link #MODE_WORLD_WRITEABLE} to 
       control permissions. 

    Returns: A {@link File} object for the requested directory. The directory will have been 
             created if it does not already exist. 

*android.content.Context.getDisplayAdjustments(int)*

public abstract |android.view.DisplayAdjustments| getDisplayAdjustments(int displayId)

Gets the display adjustments holder for this context. This information is 
provided on a per-application or activity basis and is used to simulate lower 
density display metrics for legacy applications and restricted screen sizes. 


    displayId - The display id for which to get compatibility info. 

    Returns: The compatibility info holder, or null if not required by the application. 

*android.content.Context.getExternalCacheDir()*

public abstract |java.io.File| getExternalCacheDir()

Returns the absolute path to the directory on the primary external filesystem 
(that is somewhere on 
Environment.getExternalStorageDirectory()(|android.os.Environment|) where the 
application can place cache files it owns. These files are internal to the 
application, and not typically visible to the user as media. 

This is like (|android.content.Context|) in that these files will be deleted 
when the application is uninstalled, however there are some important 
differences: 

The platform does not always monitor the space available in external storage, 
and thus may not automatically delete these files. Currently the only time 
files here will be deleted by the platform is when running on 
(|android.os.Build.VERSION_CODES|) or later and 
Environment.isExternalStorageEmulated()(|android.os.Environment|) returns true. 
Note that you should be managing the maximum space you will use for these 
anyway, just like with (|android.content.Context|) . External files are not 
always available: they will disappear if the user mounts the external storage 
on a computer or removes it. See the APIs on (|android.os.Environment|) for 
information in the storage state. There is no security enforced with these 
files. For example, any application holding (|android.Manifest.permission|) can 
write to these files. 

Starting in (|android.os.Build.VERSION_CODES|) , no permissions are required to 
read or write to the returned path; it's always accessible to the calling app. 
This only applies to paths generated for package name of the calling 
application. To access paths belonging to other packages, 
(|android.Manifest.permission|) and/or (|android.Manifest.permission|) are 
required. 

On devices with multiple users (as described by (|android.os.UserManager|) ), 
each user has their own isolated external storage. Applications only have 
access to the external storage for the user they're running as. 



    Returns: The path of the directory holding application cache files on external storage. 
             Returns null if external storage is not currently mounted so it 
             could not ensure the path exists; you will need to call this 
             method again when it is available. 

*android.content.Context.getExternalCacheDirs()*

public abstract |java.io.File|[] getExternalCacheDirs()

Returns absolute paths to application-specific directories on all external 
storage devices where the application can place cache files it owns. These 
files are internal to the application, and not typically visible to the user as 
media. 

This is like (|android.content.Context|) in that these files will be deleted 
when the application is uninstalled, however there are some important 
differences: 

External files are not always available: they will disappear if the user mounts 
the external storage on a computer or removes it. There is no security enforced 
with these files. 

External storage devices returned here are considered a permanent part of the 
device, including both emulated external storage and physical media slots, such 
as SD cards in a battery compartment. The returned paths do not include 
transient devices, such as USB flash drives. 

An application may store data on any or all of the returned devices. For 
example, an app may choose to store large files on the device with the most 
available space, as measured by (|android.os.StatFs|) . 

No permissions are required to read or write to the returned paths; they are 
always accessible to the calling app. Write access outside of these paths on 
secondary external storage devices is not available. 

The first path returned is the same as (|android.content.Context|) . Returned 
paths may benullif a storage device is unavailable. 



*android.content.Context.getExternalFilesDir(String)*

public abstract |java.io.File| getExternalFilesDir(java.lang.String type)

Returns the absolute path to the directory on the primary external filesystem 
(that is somewhere on 
Environment.getExternalStorageDirectory()(|android.os.Environment|) ) where the 
application can place persistent files it owns. These files are internal to the 
applications, and not typically visible to the user as media. 

This is like (|android.content.Context|) in that these files will be deleted 
when the application is uninstalled, however there are some important 
differences: 

External files are not always available: they will disappear if the user mounts 
the external storage on a computer or removes it. See the APIs on 
(|android.os.Environment|) for information in the storage state. There is no 
security enforced with these files. For example, any application holding 
(|android.Manifest.permission|) can write to these files. 

Starting in (|android.os.Build.VERSION_CODES|) , no permissions are required to 
read or write to the returned path; it's always accessible to the calling app. 
This only applies to paths generated for package name of the calling 
application. To access paths belonging to other packages, 
(|android.Manifest.permission|) and/or (|android.Manifest.permission|) are 
required. 

On devices with multiple users (as described by (|android.os.UserManager|) ), 
each user has their own isolated external storage. Applications only have 
access to the external storage for the user they're running as. 

Here is an example of typical code to manipulate a file in an application's 
private 
storage:development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
private_fileIf you supply a non-null type to this function, the returned file 
will be a path to a sub-directory of the given type. Though these files are not 
automatically scanned by the media scanner, you can explicitly add them to the 
media database with 
MediaScannerConnection.scanFile(|android.media.MediaScannerConnection|) . Note 
that this is not the same as 
Environment.getExternalStoragePublicDirectory()(|android.os.Environment|) , 
which provides directories of media shared by all applications. The directories 
returned here are owned by the application, and their contents will be removed 
when the application is uninstalled. Unlike 
Environment.getExternalStoragePublicDirectory()(|android.os.Environment|) , the 
directory returned here will be automatically created for you. 

Here is an example of typical code to manipulate a picture in an application's 
private storage and add it to the media 
database:development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
private_picture 


    type - The type of files directory to return. May be null for the root of the files 
       directory or one of the following Environment constants for a 
       subdirectory: {@link android.os.Environment#DIRECTORY_MUSIC}, {@link 
       android.os.Environment#DIRECTORY_PODCASTS}, {@link 
       android.os.Environment#DIRECTORY_RINGTONES}, {@link 
       android.os.Environment#DIRECTORY_ALARMS}, {@link 
       android.os.Environment#DIRECTORY_NOTIFICATIONS}, {@link 
       android.os.Environment#DIRECTORY_PICTURES}, or {@link 
       android.os.Environment#DIRECTORY_MOVIES}. 

    Returns: The path of the directory holding application files on external storage. 
             Returns null if external storage is not currently mounted so it 
             could not ensure the path exists; you will need to call this 
             method again when it is available. 

*android.content.Context.getExternalFilesDirs(String)*

public abstract |java.io.File|[] getExternalFilesDirs(java.lang.String type)

Returns absolute paths to application-specific directories on all external 
storage devices where the application can place persistent files it owns. These 
files are internal to the application, and not typically visible to the user as 
media. 

This is like (|android.content.Context|) in that these files will be deleted 
when the application is uninstalled, however there are some important 
differences: 

External files are not always available: they will disappear if the user mounts 
the external storage on a computer or removes it. There is no security enforced 
with these files. 

External storage devices returned here are considered a permanent part of the 
device, including both emulated external storage and physical media slots, such 
as SD cards in a battery compartment. The returned paths do not include 
transient devices, such as USB flash drives. 

An application may store data on any or all of the returned devices. For 
example, an app may choose to store large files on the device with the most 
available space, as measured by (|android.os.StatFs|) . 

No permissions are required to read or write to the returned paths; they are 
always accessible to the calling app. Write access outside of these paths on 
secondary external storage devices is not available. 

The first path returned is the same as (|android.content.Context|) . Returned 
paths may benullif a storage device is unavailable. 



*android.content.Context.getFilesDir()*

public abstract |java.io.File| getFilesDir()

Returns the absolute path to the directory on the filesystem where files 
created with (|android.content.Context|) are stored. 



    Returns: The path of the directory holding application files. 

*android.content.Context.getFileStreamPath(String)*

public abstract |java.io.File| getFileStreamPath(java.lang.String name)

Returns the absolute path on the filesystem where a file created with 
(|android.content.Context|) is stored. 


    name - The name of the file for which you would like to get its path. 

    Returns: An absolute path to the given file. 

*android.content.Context.getMainLooper()*

public abstract |android.os.Looper| getMainLooper()

Return the Looper for the main thread of the current process. This is the 
thread used to dispatch calls to application components (activities, services, 
etc). 

By definition, this method returns the same result as would be obtained by 
calling Looper.getMainLooper()(|android.os.Looper|) . 



    Returns: The main looper. 

*android.content.Context.getObbDir()*

public abstract |java.io.File| getObbDir()

Return the primary external storage directory where this application's OBB 
files (if there are any) can be found. Note if the application does not have 
any OBB files, this directory may not exist. 

This is like (|android.content.Context|) in that these files will be deleted 
when the application is uninstalled, however there are some important 
differences: 

External files are not always available: they will disappear if the user mounts 
the external storage on a computer or removes it. There is no security enforced 
with these files. For example, any application holding 
(|android.Manifest.permission|) can write to these files. 

Starting in (|android.os.Build.VERSION_CODES|) , no permissions are required to 
read or write to the returned path; it's always accessible to the calling app. 
This only applies to paths generated for package name of the calling 
application. To access paths belonging to other packages, 
(|android.Manifest.permission|) and/or (|android.Manifest.permission|) are 
required. 

On devices with multiple users (as described by (|android.os.UserManager|) ), 
multiple users may share the same OBB storage location. Applications should 
ensure that multiple instances running under different users don't interfere 
with each other. 



*android.content.Context.getObbDirs()*

public abstract |java.io.File|[] getObbDirs()

Returns absolute paths to application-specific directories on all external 
storage devices where the application's OBB files (if there are any) can be 
found. Note if the application does not have any OBB files, these directories 
may not exist. 

This is like (|android.content.Context|) in that these files will be deleted 
when the application is uninstalled, however there are some important 
differences: 

External files are not always available: they will disappear if the user mounts 
the external storage on a computer or removes it. There is no security enforced 
with these files. 

External storage devices returned here are considered a permanent part of the 
device, including both emulated external storage and physical media slots, such 
as SD cards in a battery compartment. The returned paths do not include 
transient devices, such as USB flash drives. 

An application may store data on any or all of the returned devices. For 
example, an app may choose to store large files on the device with the most 
available space, as measured by (|android.os.StatFs|) . 

No permissions are required to read or write to the returned paths; they are 
always accessible to the calling app. Write access outside of these paths on 
secondary external storage devices is not available. 

The first path returned is the same as (|android.content.Context|) . Returned 
paths may benullif a storage device is unavailable. 



*android.content.Context.getOpPackageName()*

public abstract |java.lang.String| getOpPackageName()





*android.content.Context.getPackageCodePath()*

public abstract |java.lang.String| getPackageCodePath()

Return the full path to this context's primary Android package. The Android 
package is a ZIP file which contains application's primary code and assets. 

Note: this is not generally useful for applications, since they should not be 
directly accessing the file system. 



    Returns: String Path to the code and assets. 

*android.content.Context.getPackageManager()*

public abstract |android.content.pm.PackageManager| getPackageManager()

Return PackageManager instance to find global package information. 



*android.content.Context.getPackageName()*

public abstract |java.lang.String| getPackageName()

Return the name of this application's package. 



*android.content.Context.getPackageResourcePath()*

public abstract |java.lang.String| getPackageResourcePath()

Return the full path to this context's primary Android package. The Android 
package is a ZIP file which contains the application's primary resources. 

Note: this is not generally useful for applications, since they should not be 
directly accessing the file system. 



    Returns: String Path to the resources. 

*android.content.Context.getResources()*

public abstract |android.content.res.Resources| getResources()

Return a Resources instance for your application's package. 



*android.content.Context.getSharedPreferences(String,int)*

public abstract |android.content.SharedPreferences| getSharedPreferences(
  java.lang.String name,
  int mode)

Retrieve and hold the contents of the preferences file 'name', returning a 
SharedPreferences through which you can retrieve and modify its values. Only 
one instance of the SharedPreferences object is returned to any callers for the 
same name, meaning they will see each other's edits as soon as they are made. 


    name - Desired preferences file. If a preferences file by this name does not exist, it 
       will be created when you retrieve an editor (SharedPreferences.edit()) 
       and then commit changes (Editor.commit()). 
    mode - Operating mode. Use 0 or {@link #MODE_PRIVATE} for the default operation, 
       {@link #MODE_WORLD_READABLE} and {@link #MODE_WORLD_WRITEABLE} to 
       control permissions. The bit {@link #MODE_MULTI_PROCESS} can also be 
       used if multiple processes are mutating the same SharedPreferences file. 
       {@link #MODE_MULTI_PROCESS} is always on in apps targetting Gingerbread 
       (Android 2.3) and below, and off by default in later versions. 

    Returns: The single {@link SharedPreferences} instance that can be used to retrieve and 
             modify the preference values. 

*android.content.Context.getSharedPrefsFile(String)*

public abstract |java.io.File| getSharedPrefsFile(java.lang.String name)

Return the full path to the shared prefs file for the given prefs group name. 

Note: this is not generally useful for applications, since they should not be 
directly accessing the file system. 



*android.content.Context.getString(int)*

public final |java.lang.String| getString(int resId)

Return a localized string from the application's package's default string 
table. 


    resId - Resource id for the string 

*android.content.Context.getString(int,Object...)*

public final |java.lang.String| getString(
  int resId,
  java.lang.Object[] formatArgs)

Return a localized formatted string from the application's package's default 
string table, substituting the format arguments as defined in 
(|java.util.Formatter|) and (|java.lang.String|) . 


    resId - Resource id for the format string 
    formatArgs - The format arguments that will be used for substitution. 

*android.content.Context.getSystemService(String)*

public abstract |java.lang.Object| getSystemService(java.lang.String name)

Return the handle to a system-level service by name. The class of the returned 
object varies by the requested name. Currently available names are: 

(|android.content.Context|) ("window") The top-level window manager in which 
you can place custom windows. The returned object is a 
(|android.view.WindowManager|) . (|android.content.Context|) 
("layout_inflater") A (|android.view.LayoutInflater|) for inflating layout 
resources in this context. (|android.content.Context|) ("activity") A 
(|android.app.ActivityManager|) for interacting with the global activity state 
of the system. (|android.content.Context|) ("power") A 
(|android.os.PowerManager|) for controlling power management. 
(|android.content.Context|) ("alarm") A (|android.app.AlarmManager|) for 
receiving intents at the time of your choosing. (|android.content.Context|) 
("notification") A (|android.app.NotificationManager|) for informing the user 
of background events. (|android.content.Context|) ("keyguard") A 
(|android.app.KeyguardManager|) for controlling keyguard. 
(|android.content.Context|) ("location") A (|android.location.LocationManager|) 
for controlling location (e.g., GPS) updates. (|android.content.Context|) 
("search") A (|android.app.SearchManager|) for handling search. 
(|android.content.Context|) ("vibrator") A (|android.os.Vibrator|) for 
interacting with the vibrator hardware. (|android.content.Context|) 
("connection") A ConnectivityManager(|android.net.ConnectivityManager|) for 
handling management of network connections. (|android.content.Context|) 
("wifi") A WifiManager(|android.net.wifi.WifiManager|) for management of Wi-Fi 
connectivity. (|android.content.Context|) ("input_method") An 
InputMethodManager(|android.view.inputmethod.InputMethodManager|) for 
management of input methods. (|android.content.Context|) ("uimode") An 
(|android.app.UiModeManager|) for controlling UI modes. 
(|android.content.Context|) ("download") A (|android.app.DownloadManager|) for 
requesting HTTP downloads 

Note: System services obtained via this API may be closely associated with the 
Context in which they are obtained from. In general, do not share the service 
objects between various different contexts (Activities, Applications, Services, 
Providers, etc.) 


    name - The name of the desired service. 

    Returns: The service or null if the name does not exist. 

*android.content.Context.getText(int)*

public final |java.lang.CharSequence| getText(int resId)

Return a localized, styled CharSequence from the application's package's 
default string table. 


    resId - Resource id for the CharSequence text 

*android.content.Context.getTheme()*

public abstract |android.content.res.Resources.Theme| getTheme()

Return the Theme object associated with this Context. 



*android.content.Context.getThemeResId()*

public int getThemeResId()





*android.content.Context.getUserId()*

public abstract int getUserId()

Get the userId associated with this context 



    Returns: 

*android.content.Context.getWallpaper()*

public abstract Drawable getWallpaper()



    Deprecated: Use {@link android.app.WallpaperManager#getDrawable
 WallpaperManager.get()} instead.


*android.content.Context.getWallpaperDesiredMinimumHeight()*

public abstract int getWallpaperDesiredMinimumHeight()



    Deprecated: Use {@link android.app.WallpaperManager#getDesiredMinimumHeight()
 WallpaperManager.getDesiredMinimumHeight()} instead.


*android.content.Context.getWallpaperDesiredMinimumWidth()*

public abstract int getWallpaperDesiredMinimumWidth()



    Deprecated: Use {@link android.app.WallpaperManager#getDesiredMinimumWidth()
 WallpaperManager.getDesiredMinimumWidth()} instead.


*android.content.Context.grantUriPermission(String,Uri,int)*

public abstract void grantUriPermission(
  java.lang.String toPackage,
  android.net.Uri uri,
  int modeFlags)

Grant permission to access a specific Uri to another package, regardless of 
whether that package has general permission to access the Uri's content 
provider. This can be used to grant specific, temporary permissions, typically 
in response to user interaction (such as the user opening an attachment that 
you would like someone else to display). 

Normally you should use 
Intent.FLAG_GRANT_READ_URI_PERMISSION(|android.content.Intent|) or 
Intent.FLAG_GRANT_WRITE_URI_PERMISSION(|android.content.Intent|) with the 
Intent being used to start an activity instead of this function directly. If 
you use this function directly, you should be sure to call 
(|android.content.Context|) when the target should no longer be allowed to 
access it. 

To succeed, the content provider owning the Uri must have set the 
grantUriPermissions(|android.R.styleable|) attribute in its manifest or 
included the &lt;grant-uri-permissions&gt;(|android.R.styleable|) tag. 


    toPackage - The package you would like to allow to access the Uri. 
    uri - The Uri you would like to grant access to. 
    modeFlags - The desired access modes. Any combination of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 

*android.content.Context.isRestricted()*

public boolean isRestricted()

Indicates whether this Context is restricted. 



    Returns: {@code true} if this Context is restricted, {@code false} otherwise. 

*android.content.Context.obtainStyledAttributes(AttributeSet,int[])*

public final |android.content.res.TypedArray| obtainStyledAttributes(
  android.util.AttributeSet set,
  int[] attrs)

Retrieve styled attribute information in this Context's theme. See 
(|Resources.Theme|) for more information. 



*android.content.Context.obtainStyledAttributes(AttributeSet,int[],int,int)*

public final |android.content.res.TypedArray| obtainStyledAttributes(
  android.util.AttributeSet set,
  int[] attrs,
  int defStyleAttr,
  int defStyleRes)

Retrieve styled attribute information in this Context's theme. See 
(|Resources.Theme|) for more information. 



*android.content.Context.obtainStyledAttributes(int[])*

public final |android.content.res.TypedArray| obtainStyledAttributes(int[] attrs)

Retrieve styled attribute information in this Context's theme. See 
(|Resources.Theme|) for more information. 



*android.content.Context.obtainStyledAttributes(int,int[])*

public final |android.content.res.TypedArray| obtainStyledAttributes(
  int resid,
  int[] attrs)
  throws |android.content.res.Resources.NotFoundException|
         
Retrieve styled attribute information in this Context's theme. See 
(|Resources.Theme|) for more information. 



*android.content.Context.openFileInput(String)*

public abstract |java.io.FileInputStream| openFileInput(java.lang.String name)
  throws |java.io.FileNotFoundException|
         
Open a private file associated with this Context's application package for 
reading. 


    name - The name of the file to open; can not contain path separators. 

    Returns: The resulting {@link FileInputStream}. 

*android.content.Context.openFileOutput(String,int)*

public abstract |java.io.FileOutputStream| openFileOutput(
  java.lang.String name,
  int mode)
  throws |java.io.FileNotFoundException|
         
Open a private file associated with this Context's application package for 
writing. Creates the file if it doesn't already exist. 


    name - The name of the file to open; can not contain path separators. 
    mode - Operating mode. Use 0 or {@link #MODE_PRIVATE} for the default operation, 
       {@link #MODE_APPEND} to append to an existing file, {@link 
       #MODE_WORLD_READABLE} and {@link #MODE_WORLD_WRITEABLE} to control 
       permissions. 

    Returns: The resulting {@link FileOutputStream}. 

*android.content.Context.openOrCreateDatabase(String,int,SQLiteDatabase.CursorFactory)*

public abstract |android.database.sqlite.SQLiteDatabase| openOrCreateDatabase(
  java.lang.String name,
  int mode,
  android.database.sqlite.SQLiteDatabase.CursorFactory factory)

Open a new private SQLiteDatabase associated with this Context's application 
package. Create the database file if it doesn't exist. 


    name - The name (unique in the application package) of the database. 
    mode - Operating mode. Use 0 or {@link #MODE_PRIVATE} for the default operation, 
       {@link #MODE_WORLD_READABLE} and {@link #MODE_WORLD_WRITEABLE} to 
       control permissions. Use {@link #MODE_ENABLE_WRITE_AHEAD_LOGGING} to 
       enable write-ahead logging by default. 
    factory - An optional factory class that is called to instantiate a cursor when query is 
       called. 

    Returns: The contents of a newly created database with the given name. 

*android.content.Context.openOrCreateDatabase(String,int,SQLiteDatabase.CursorFactory,DatabaseErrorHandler)*

public abstract |android.database.sqlite.SQLiteDatabase| openOrCreateDatabase(
  java.lang.String name,
  int mode,
  android.database.sqlite.SQLiteDatabase.CursorFactory factory,
  android.database.DatabaseErrorHandler errorHandler)

Open a new private SQLiteDatabase associated with this Context's application 
package. Creates the database file if it doesn't exist. 

Accepts input param: a concrete instance of 
(|android.database.DatabaseErrorHandler|) to be used to handle corruption when 
sqlite reports database corruption. 


    name - The name (unique in the application package) of the database. 
    mode - Operating mode. Use 0 or {@link #MODE_PRIVATE} for the default operation, 
       {@link #MODE_WORLD_READABLE} and {@link #MODE_WORLD_WRITEABLE} to 
       control permissions. Use {@link #MODE_ENABLE_WRITE_AHEAD_LOGGING} to 
       enable write-ahead logging by default. 
    factory - An optional factory class that is called to instantiate a cursor when query is 
       called. 
    errorHandler - the {@link DatabaseErrorHandler} to be used when sqlite reports database 
       corruption. if null, {@link 
       android.database.DefaultDatabaseErrorHandler} is assumed. 

    Returns: The contents of a newly created database with the given name. 

*android.content.Context.peekWallpaper()*

public abstract Drawable peekWallpaper()



    Deprecated: Use {@link android.app.WallpaperManager#peekDrawable
 WallpaperManager.peek()} instead.


*android.content.Context.registerComponentCallbacks(ComponentCallbacks)*

public void registerComponentCallbacks(android.content.ComponentCallbacks callback)

Add a new (|android.content.ComponentCallbacks|) to the base application of the 
Context, which will be called at the same times as the ComponentCallbacks 
methods of activities and other components are called. Note that you must be 
sure to use (|android.content.Context|) when appropriate in the future; this 
will not be removed for you. 


    callback - The interface to call. This can be either a {@link ComponentCallbacks} or 
       {@link ComponentCallbacks2} interface. 

*android.content.Context.registerReceiver(BroadcastReceiver,IntentFilter)*

public abstract |android.content.Intent| registerReceiver(
  android.content.BroadcastReceiver receiver,
  android.content.IntentFilter filter)

Register a BroadcastReceiver to be run in the main activity thread. The 
receiver will be called with any broadcast Intent that matches filter, in the 
main application thread. 

The system may broadcast Intents that are "sticky" -- these stay around after 
the broadcast as finished, to be sent to any later registrations. If your 
IntentFilter matches one of these sticky Intents, that Intent will be returned 
by this function and sent to your receiver as if it had just been broadcast. 

There may be multiple sticky Intents that match filter, in which case each of 
these will be sent to receiver. In this case, only one of these can be returned 
directly by the function; which of these that is returned is arbitrarily 
decided by the system. 

If you know the Intent your are registering for is sticky, you can supply null 
for your receiver. In this case, no receiver is registered -- the function 
simply returns the sticky Intent that matches filter. In the case of multiple 
matches, the same rules as described above apply. 

See (|android.content.BroadcastReceiver|) for more information on Intent 
broadcasts. 

As of (|android.os.Build.VERSION_CODES|) , receivers registered with this 
method will correctly respect the (|android.content.Intent|) specified for an 
Intent being broadcast. Prior to that, it would be ignored and delivered to all 
matching registered receivers. Be careful if using this for security. 

Note: this method cannot be called from a (|android.content.BroadcastReceiver|) 
component; that is, from a BroadcastReceiver that is declared in an 
application's manifest. It is okay, however, to call this method from another 
BroadcastReceiver that has itself been registered at run time with 
(|android.content.Context|) , since the lifetime of such a registered 
BroadcastReceiver is tied to the object that registered it. 


    receiver - The BroadcastReceiver to handle the broadcast. 
    filter - Selects the Intent broadcasts to be received. 

    Returns: The first sticky intent found that matches filter, or null if there are none. 

*android.content.Context.registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)*

public abstract |android.content.Intent| registerReceiver(
  android.content.BroadcastReceiver receiver,
  android.content.IntentFilter filter,
  java.lang.String broadcastPermission,
  android.os.Handler scheduler)

Register to receive intent broadcasts, to run in the context of scheduler. See 
(|android.content.Context|) for more information. This allows you to enforce 
permissions on who can broadcast intents to your receiver, or have the receiver 
run in a different thread than the main application thread. 

See (|android.content.BroadcastReceiver|) for more information on Intent 
broadcasts. 

As of (|android.os.Build.VERSION_CODES|) , receivers registered with this 
method will correctly respect the (|android.content.Intent|) specified for an 
Intent being broadcast. Prior to that, it would be ignored and delivered to all 
matching registered receivers. Be careful if using this for security. 


    receiver - The BroadcastReceiver to handle the broadcast. 
    filter - Selects the Intent broadcasts to be received. 
    broadcastPermission - String naming a permissions that a broadcaster must hold in order to send an 
       Intent to you. If null, no permission is required. 
    scheduler - Handler identifying the thread that will receive the Intent. If null, the main 
       thread of the process will be used. 

    Returns: The first sticky intent found that matches filter, or null if there are none. 

*android.content.Context.registerReceiverAsUser(BroadcastReceiver,UserHandle,IntentFilter,String,Handler)*

public abstract |android.content.Intent| registerReceiverAsUser(
  android.content.BroadcastReceiver receiver,
  android.os.UserHandle user,
  android.content.IntentFilter filter,
  java.lang.String broadcastPermission,
  android.os.Handler scheduler)




    receiver - The BroadcastReceiver to handle the broadcast. 
    user - UserHandle to send the intent to. 
    filter - Selects the Intent broadcasts to be received. 
    broadcastPermission - String naming a permissions that a broadcaster must hold in order to send an 
       Intent to you. If null, no permission is required. 
    scheduler - Handler identifying the thread that will receive the Intent. If null, the main 
       thread of the process will be used. 

    Returns: The first sticky intent found that matches filter, or null if there are none. 

*android.content.Context.removeStickyBroadcast(Intent)*

public abstract void removeStickyBroadcast(android.content.Intent intent)

Remove the data previously sent with (|android.content.Context|) , so that it 
is as if the sticky broadcast had never happened. 

You must hold the (|android.Manifest.permission|) permission in order to use 
this API. If you do not hold that permission, (|java.lang.SecurityException|) 
will be thrown. 


    intent - The Intent that was previously broadcast. 

*android.content.Context.removeStickyBroadcastAsUser(Intent,UserHandle)*

public abstract void removeStickyBroadcastAsUser(
  android.content.Intent intent,
  android.os.UserHandle user)

Version of (|android.content.Context|) that allows you to specify the user the 
broadcast will be sent to. This is not available to applications that are not 
pre-installed on the system image. Using it requires holding the 
INTERACT_ACROSS_USERS permission. 

You must hold the (|android.Manifest.permission|) permission in order to use 
this API. If you do not hold that permission, (|java.lang.SecurityException|) 
will be thrown. 


    intent - The Intent that was previously broadcast. 
    user - UserHandle to remove the sticky broadcast from. 

*android.content.Context.revokeUriPermission(Uri,int)*

public abstract void revokeUriPermission(
  android.net.Uri uri,
  int modeFlags)

Remove all permissions to access a particular content provider Uri that were 
previously added with (|android.content.Context|) . The given Uri will match 
all previously granted Uris that are the same or a sub-path of the given Uri. 
That is, revoking "content://foo/target" will revoke both 
"content://foo/target" and "content://foo/target/sub", but not "content://foo". 


    uri - The Uri you would like to revoke access to. 
    modeFlags - The desired access modes. Any combination of {@link 
       Intent#FLAG_GRANT_READ_URI_PERMISSION 
       Intent.FLAG_GRANT_READ_URI_PERMISSION} or {@link 
       Intent#FLAG_GRANT_WRITE_URI_PERMISSION 
       Intent.FLAG_GRANT_WRITE_URI_PERMISSION}. 

*android.content.Context.sendBroadcast(Intent)*

public abstract void sendBroadcast(android.content.Intent intent)

Broadcast the given intent to all interested BroadcastReceivers. This call is 
asynchronous; it returns immediately, and you will continue executing while the 
receivers are run. No results are propagated from receivers and receivers can 
not abort the broadcast. If you want to allow receivers to propagate results or 
abort the broadcast, you must send an ordered broadcast using 
(|android.content.Context|) . 

See (|android.content.BroadcastReceiver|) for more information on Intent 
broadcasts. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast. 

*android.content.Context.sendBroadcast(Intent,String)*

public abstract void sendBroadcast(
  android.content.Intent intent,
  java.lang.String receiverPermission)

Broadcast the given intent to all interested BroadcastReceivers, allowing an 
optional required permission to be enforced. This call is asynchronous; it 
returns immediately, and you will continue executing while the receivers are 
run. No results are propagated from receivers and receivers can not abort the 
broadcast. If you want to allow receivers to propagate results or abort the 
broadcast, you must send an ordered broadcast using (|android.content.Context|) 
. 

See (|android.content.BroadcastReceiver|) for more information on Intent 
broadcasts. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast. 
    receiverPermission - (optional) String naming a permission that a receiver must hold in order to 
       receive your broadcast. If null, no permission is required. 

*android.content.Context.sendBroadcast(Intent,String,int)*

public abstract void sendBroadcast(
  android.content.Intent intent,
  java.lang.String receiverPermission,
  int appOp)

Like (|android.content.Context|) , but also allows specification of an 
assocated app op as per (|android.app.AppOpsManager|) . 



*android.content.Context.sendBroadcastAsUser(Intent,UserHandle)*

public abstract void sendBroadcastAsUser(
  android.content.Intent intent,
  android.os.UserHandle user)

Version of (|android.content.Context|) that allows you to specify the user the 
broadcast will be sent to. This is not available to applications that are not 
pre-installed on the system image. Using it requires holding the 
INTERACT_ACROSS_USERS permission. 


    intent - The intent to broadcast 
    user - UserHandle to send the intent to. 

*android.content.Context.sendBroadcastAsUser(Intent,UserHandle,String)*

public abstract void sendBroadcastAsUser(
  android.content.Intent intent,
  android.os.UserHandle user,
  java.lang.String receiverPermission)

Version of (|android.content.Context|) that allows you to specify the user the 
broadcast will be sent to. This is not available to applications that are not 
pre-installed on the system image. Using it requires holding the 
INTERACT_ACROSS_USERS permission. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast. 
    user - UserHandle to send the intent to. 
    receiverPermission - (optional) String naming a permission that a receiver must hold in order to 
       receive your broadcast. If null, no permission is required. 

*android.content.Context.sendOrderedBroadcast(Intent,String)*

public abstract void sendOrderedBroadcast(
  android.content.Intent intent,
  java.lang.String receiverPermission)

Broadcast the given intent to all interested BroadcastReceivers, delivering 
them one at a time to allow more preferred receivers to consume the broadcast 
before it is delivered to less preferred receivers. This call is asynchronous; 
it returns immediately, and you will continue executing while the receivers are 
run. 

See (|android.content.BroadcastReceiver|) for more information on Intent 
broadcasts. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast. 
    receiverPermission - (optional) String naming a permissions that a receiver must hold in order to 
       receive your broadcast. If null, no permission is required. 

*android.content.Context.sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)*

public abstract void sendOrderedBroadcast(
  android.content.Intent intent,
  java.lang.String receiverPermission,
  android.content.BroadcastReceiver resultReceiver,
  android.os.Handler scheduler,
  int initialCode,
  java.lang.String initialData,
  android.os.Bundle initialExtras)

Version of (|android.content.Context|) that allows you to receive data back 
from the broadcast. This is accomplished by supplying your own 
BroadcastReceiver when calling, which will be treated as a final receiver at 
the end of the broadcast -- its (|android.content.BroadcastReceiver|) method 
will be called with the result values collected from the other receivers. The 
broadcast will be serialized in the same way as calling 
(|android.content.Context|) . 

Like (|android.content.Context|) , this method is asynchronous; it will return 
before resultReceiver.onReceive() is called. 

See (|android.content.BroadcastReceiver|) for more information on Intent 
broadcasts. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast. 
    receiverPermission - String naming a permissions that a receiver must hold in order to receive your 
       broadcast. If null, no permission is required. 
    resultReceiver - Your own BroadcastReceiver to treat as the final receiver of the broadcast. 
    scheduler - A custom Handler with which to schedule the resultReceiver callback; if null it 
       will be scheduled in the Context's main thread. 
    initialCode - An initial value for the result code. Often Activity.RESULT_OK. 
    initialData - An initial value for the result data. Often null. 
    initialExtras - An initial value for the result extras. Often null. 

*android.content.Context.sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle)*

public abstract void sendOrderedBroadcast(
  android.content.Intent intent,
  java.lang.String receiverPermission,
  int appOp,
  android.content.BroadcastReceiver resultReceiver,
  android.os.Handler scheduler,
  int initialCode,
  java.lang.String initialData,
  android.os.Bundle initialExtras)

Like (|android.content.Context|) , but also allows specification of an 
assocated app op as per (|android.app.AppOpsManager|) . 



*android.content.Context.sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)*

public abstract void sendOrderedBroadcastAsUser(
  android.content.Intent intent,
  android.os.UserHandle user,
  java.lang.String receiverPermission,
  android.content.BroadcastReceiver resultReceiver,
  android.os.Handler scheduler,
  int initialCode,
  java.lang.String initialData,
  android.os.Bundle initialExtras)

Version of (|android.content.Context|) that allows you to specify the user the 
broadcast will be sent to. This is not available to applications that are not 
pre-installed on the system image. Using it requires holding the 
INTERACT_ACROSS_USERS permission. 

See (|android.content.BroadcastReceiver|) for more information on Intent 
broadcasts. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast. 
    user - UserHandle to send the intent to. 
    receiverPermission - String naming a permissions that a receiver must hold in order to receive your 
       broadcast. If null, no permission is required. 
    resultReceiver - Your own BroadcastReceiver to treat as the final receiver of the broadcast. 
    scheduler - A custom Handler with which to schedule the resultReceiver callback; if null it 
       will be scheduled in the Context's main thread. 
    initialCode - An initial value for the result code. Often Activity.RESULT_OK. 
    initialData - An initial value for the result data. Often null. 
    initialExtras - An initial value for the result extras. Often null. 

*android.content.Context.sendStickyBroadcast(Intent)*

public abstract void sendStickyBroadcast(android.content.Intent intent)

Perform a (|android.content.Context|) that is "sticky," meaning the Intent you 
are sending stays around after the broadcast is complete, so that others can 
quickly retrieve that data through the return value of 
(|android.content.Context|) . In all other ways, this behaves the same as 
(|android.content.Context|) . 

You must hold the (|android.Manifest.permission|) permission in order to use 
this API. If you do not hold that permission, (|java.lang.SecurityException|) 
will be thrown. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast, and the Intent will be held to be re-broadcast to future 
       receivers. 

*android.content.Context.sendStickyBroadcastAsUser(Intent,UserHandle)*

public abstract void sendStickyBroadcastAsUser(
  android.content.Intent intent,
  android.os.UserHandle user)

Version of (|android.content.Context|) that allows you to specify the user the 
broadcast will be sent to. This is not available to applications that are not 
pre-installed on the system image. Using it requires holding the 
INTERACT_ACROSS_USERS permission. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast, and the Intent will be held to be re-broadcast to future 
       receivers. 
    user - UserHandle to send the intent to. 

*android.content.Context.sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)*

public abstract void sendStickyOrderedBroadcast(
  android.content.Intent intent,
  android.content.BroadcastReceiver resultReceiver,
  android.os.Handler scheduler,
  int initialCode,
  java.lang.String initialData,
  android.os.Bundle initialExtras)

Version of (|android.content.Context|) that allows you to receive data back 
from the broadcast. This is accomplished by supplying your own 
BroadcastReceiver when calling, which will be treated as a final receiver at 
the end of the broadcast -- its (|android.content.BroadcastReceiver|) method 
will be called with the result values collected from the other receivers. The 
broadcast will be serialized in the same way as calling 
(|android.content.Context|) . 

Like (|android.content.Context|) , this method is asynchronous; it will return 
before resultReceiver.onReceive() is called. Note that the sticky data stored 
is only the data you initially supply to the broadcast, not the result of any 
changes made by the receivers. 

See (|android.content.BroadcastReceiver|) for more information on Intent 
broadcasts. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast. 
    resultReceiver - Your own BroadcastReceiver to treat as the final receiver of the broadcast. 
    scheduler - A custom Handler with which to schedule the resultReceiver callback; if null it 
       will be scheduled in the Context's main thread. 
    initialCode - An initial value for the result code. Often Activity.RESULT_OK. 
    initialData - An initial value for the result data. Often null. 
    initialExtras - An initial value for the result extras. Often null. 

*android.content.Context.sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)*

public abstract void sendStickyOrderedBroadcastAsUser(
  android.content.Intent intent,
  android.os.UserHandle user,
  android.content.BroadcastReceiver resultReceiver,
  android.os.Handler scheduler,
  int initialCode,
  java.lang.String initialData,
  android.os.Bundle initialExtras)

Version of (|android.content.Context|) that allows you to specify the user the 
broadcast will be sent to. This is not available to applications that are not 
pre-installed on the system image. Using it requires holding the 
INTERACT_ACROSS_USERS permission. 

See (|android.content.BroadcastReceiver|) for more information on Intent 
broadcasts. 


    intent - The Intent to broadcast; all receivers matching this Intent will receive the 
       broadcast. 
    user - UserHandle to send the intent to. 
    resultReceiver - Your own BroadcastReceiver to treat as the final receiver of the broadcast. 
    scheduler - A custom Handler with which to schedule the resultReceiver callback; if null it 
       will be scheduled in the Context's main thread. 
    initialCode - An initial value for the result code. Often Activity.RESULT_OK. 
    initialData - An initial value for the result data. Often null. 
    initialExtras - An initial value for the result extras. Often null. 

*android.content.Context.setTheme(int)*

public abstract void setTheme(int resid)

Set the base theme for this context. Note that this should be called before any 
views are instantiated in the Context (for example before calling 
(|android.app.Activity|) or (|android.view.LayoutInflater|) ). 


    resid - The style resource describing the theme. 

*android.content.Context.setWallpaper(Bitmap)*

public abstract void setWallpaper(Bitmap bitmap)
  throws |java.io.IOException|
         


    Deprecated: Use {@link android.app.WallpaperManager#setBitmap(Bitmap)
 WallpaperManager.set()} instead.
 <p>This method requires the caller to hold the permission
 {@link android.Manifest.permission#SET_WALLPAPER}.


*android.content.Context.startActivities(Intent[])*

public abstract void startActivities(android.content.Intent[] intents)

Same as (|android.content.Context|) with no options specified. 


    intents - An array of Intents to be started. 

*android.content.Context.startActivities(Intent[],Bundle)*

public abstract void startActivities(
  android.content.Intent[] intents,
  android.os.Bundle options)

Launch multiple new activities. This is generally the same as calling 
(|android.content.Context|) for the first Intent in the array, that activity 
during its creation calling (|android.content.Context|) for the second entry, 
etc. Note that unlike that approach, generally none of the activities except 
the last in the array will be created at this point, but rather will be created 
when the user first visits them (due to pressing back from the activity on 
top). 

This method throws (|android.content.ActivityNotFoundException|) if there was 
no Activity found for any given Intent. In this case the state of the activity 
stack is undefined (some Intents in the list may be on it, some not), so you 
probably want to avoid such situations. 


    intents - An array of Intents to be started. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. 

*android.content.Context.startActivitiesAsUser(Intent[],Bundle,UserHandle)*

public void startActivitiesAsUser(
  android.content.Intent[] intents,
  android.os.Bundle options,
  android.os.UserHandle userHandle)




    intents - An array of Intents to be started. 
    options - Additional options for how the Activity should be started. 
    userHandle - The user for whom to launch the activities See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. 

*android.content.Context.startActivity(Intent)*

public abstract void startActivity(android.content.Intent intent)

Same as (|android.content.Context|) with no options specified. 


    intent - The description of the activity to start. 

*android.content.Context.startActivity(Intent,Bundle)*

public abstract void startActivity(
  android.content.Intent intent,
  android.os.Bundle options)

Launch a new activity. You will not receive any information about when the 
activity exits. 

Note that if this method is being called from outside of an 
(|android.app.Activity|) Context, then the Intent must include the 
(|android.content.Intent|) launch flag. This is because, without being started 
from an existing Activity, there is no existing task in which to place the new 
activity and thus it needs to be placed in its own separate task. 

This method throws (|android.content.ActivityNotFoundException|) if there was 
no Activity found to run the given Intent. 


    intent - The description of the activity to start. 
    options - Additional options for how the Activity should be started. May be null if there 
       are no options. See {@link android.app.ActivityOptions} for how to build 
       the Bundle supplied here; there are no supported definitions for 
       building it manually. 

*android.content.Context.startActivityAsUser(Intent,Bundle,UserHandle)*

public void startActivityAsUser(
  android.content.Intent intent,
  android.os.Bundle options,
  android.os.UserHandle userId)

Version of (|android.content.Context|) that allows you to specify the user the 
activity will be started for. This is not available to applications that are 
not pre-installed on the system image. Using it requires holding the 
INTERACT_ACROSS_USERS_FULL permission. 


    intent - The description of the activity to start. 
    options - Additional options for how the Activity should be started. May be null if there 
       are no options. See {@link android.app.ActivityOptions} for how to build 
       the Bundle supplied here; there are no supported definitions for 
       building it manually. 
    userId - The UserHandle of the user to start this activity for. 

*android.content.Context.startActivityAsUser(Intent,UserHandle)*

public void startActivityAsUser(
  android.content.Intent intent,
  android.os.UserHandle user)

Version of (|android.content.Context|) that allows you to specify the user the 
activity will be started for. This is not available to applications that are 
not pre-installed on the system image. Using it requires holding the 
INTERACT_ACROSS_USERS_FULL permission. 


    intent - The description of the activity to start. 
    user - The UserHandle of the user to start this activity for. 

*android.content.Context.startInstrumentation(ComponentName,String,Bundle)*

public abstract boolean startInstrumentation(
  android.content.ComponentName className,
  java.lang.String profileFile,
  android.os.Bundle arguments)

Start executing an (|android.app.Instrumentation|) class. The given 
Instrumentation component will be run by killing its target application (if 
currently running), starting the target process, instantiating the 
instrumentation component, and then letting it drive the application. 

This function is not synchronous -- it returns as soon as the instrumentation 
has started and while it is running. 

Instrumentation is normally only allowed to run against a package that is 
either unsigned or signed with a signature that the the instrumentation package 
is also signed with (ensuring the target trusts the instrumentation). 


    className - Name of the Instrumentation component to be run. 
    profileFile - Optional path to write profiling data as the instrumentation runs, or null for 
       no profiling. 
    arguments - Additional optional arguments to pass to the instrumentation, or null. 

    Returns: {@code true} if the instrumentation was successfully started, else {@code 
             false} if it could not be found. 

*android.content.Context.startIntentSender(IntentSender,Intent,int,int,int)*

public abstract void startIntentSender(
  android.content.IntentSender intent,
  android.content.Intent fillInIntent,
  int flagsMask,
  int flagsValues,
  int extraFlags)
  throws |android.content.IntentSender.SendIntentException|
         
Same as (|android.content.Context|) with no options specified. 


    intent - The IntentSender to launch. 
    fillInIntent - If non-null, this will be provided as the intent parameter to {@link 
       IntentSender#sendIntent}. 
    flagsMask - Intent flags in the original IntentSender that you would like to change. 
    flagsValues - Desired values for any bits set in flagsMask 
    extraFlags - Always set to 0. 

*android.content.Context.startIntentSender(IntentSender,Intent,int,int,int,Bundle)*

public abstract void startIntentSender(
  android.content.IntentSender intent,
  android.content.Intent fillInIntent,
  int flagsMask,
  int flagsValues,
  int extraFlags,
  android.os.Bundle options)
  throws |android.content.IntentSender.SendIntentException|
         
Like (|android.content.Context|) , but taking a IntentSender to start. If the 
IntentSender is for an activity, that activity will be started as if you had 
called the regular (|android.content.Context|) here; otherwise, its associated 
action will be executed (such as sending a broadcast) as if you had called 
IntentSender.sendIntent(|android.content.IntentSender|) on it. 


    intent - The IntentSender to launch. 
    fillInIntent - If non-null, this will be provided as the intent parameter to {@link 
       IntentSender#sendIntent}. 
    flagsMask - Intent flags in the original IntentSender that you would like to change. 
    flagsValues - Desired values for any bits set in flagsMask 
    extraFlags - Always set to 0. 
    options - Additional options for how the Activity should be started. See {@link 
       android.content.Context#startActivity(Intent, Bundle) 
       Context.startActivity(Intent, Bundle)} for more details. If options have 
       also been supplied by the IntentSender, options given here will override 
       any that conflict with those given by the IntentSender. 

*android.content.Context.startService(Intent)*

public abstract |android.content.ComponentName| startService(android.content.Intent service)

Request that a given application service be started. The Intent should contain 
either contain the complete class name of a specific service implementation to 
start or a specific package name to target. If the Intent is less specified, it 
log a warning about this and which of the multiple matching services it finds 
and uses will be undefined. If this service is not already running, it will be 
instantiated and started (creating a process for it if needed); if it is 
running then it remains running. 

Every call to this method will result in a corresponding call to the target 
service's (|android.app.Service|) method, with the intent given here. This 
provides a convenient way to submit jobs to a service without having to bind 
and call on to its interface. 

Using startService() overrides the default service lifetime that is managed by 
(|android.content.Context|) : it requires the service to remain running until 
(|android.content.Context|) is called, regardless of whether any clients are 
connected to it. Note that calls to startService() are not nesting: no matter 
how many times you call startService(), a single call to 
(|android.content.Context|) will stop it. 

The system attempts to keep running services around as much as possible. The 
only time they should be stopped is if the current foreground application is 
using so many resources that the service needs to be killed. If any errors 
happen in the service's process, it will automatically be restarted. 

This function will throw (|java.lang.SecurityException|) if you do not have 
permission to start the given service. 


    service - Identifies the service to be started. The Intent must be either fully explicit 
       (supplying a component name) or specify a specific package name it is 
       targetted to. Additional values may be included in the Intent extras to 
       supply arguments along with this specific start call. 

    Returns: If the service is being started or is already running, the {@link 
             ComponentName} of the actual service that was started is returned; 
             else if the service does not exist null is returned. 

*android.content.Context.startServiceAsUser(Intent,UserHandle)*

public abstract |android.content.ComponentName| startServiceAsUser(
  android.content.Intent service,
  android.os.UserHandle user)





*android.content.Context.stopService(Intent)*

public abstract boolean stopService(android.content.Intent service)

Request that a given application service be stopped. If the service is not 
running, nothing happens. Otherwise it is stopped. Note that calls to 
startService() are not counted -- this stops the service no matter how many 
times it was started. 

Note that if a stopped service still has (|android.content.ServiceConnection|) 
objects bound to it with the (|android.content.Context|) set, it will not be 
destroyed until all of these bindings are removed. See the 
(|android.app.Service|) documentation for more details on a service's 
lifecycle. 

This function will throw (|java.lang.SecurityException|) if you do not have 
permission to stop the given service. 


    service - Description of the service to be stopped. The Intent must be either fully 
       explicit (supplying a component name) or specify a specific package name 
       it is targetted to. 

    Returns: If there is a service matching the given Intent that is already running, then 
             it is stopped and {@code true} is returned; else {@code false} is 
             returned. 

*android.content.Context.stopServiceAsUser(Intent,UserHandle)*

public abstract boolean stopServiceAsUser(
  android.content.Intent service,
  android.os.UserHandle user)





*android.content.Context.unbindService(ServiceConnection)*

public abstract void unbindService(android.content.ServiceConnection conn)

Disconnect from an application service. You will no longer receive calls as the 
service is restarted, and the service is now allowed to stop at any time. 


    conn - The connection interface previously supplied to bindService(). This parameter 
       must not be null. 

*android.content.Context.unregisterComponentCallbacks(ComponentCallbacks)*

public void unregisterComponentCallbacks(android.content.ComponentCallbacks callback)

Remove a (|android.content.ComponentCallbacks|) object that was previously 
registered with (|android.content.Context|) . 



*android.content.Context.unregisterReceiver(BroadcastReceiver)*

public abstract void unregisterReceiver(android.content.BroadcastReceiver receiver)

Unregister a previously registered BroadcastReceiver. All filters that have 
been registered for this BroadcastReceiver will be removed. 


    receiver - The BroadcastReceiver to unregister. 


