*android.content.ContentProvider* *ContentProvider* Content providers are one of

public abstract class ContentProvider
  extends    |java.lang.Object|
  implements |android.content.ComponentCallbacks2|

|android.content.ContentProvider_Description|
|android.content.ContentProvider_Fields|
|android.content.ContentProvider_Constructors|
|android.content.ContentProvider_Methods|

================================================================================

*android.content.ContentProvider_Constructors*
|android.content.ContentProvider()|Construct a ContentProvider instance.
|android.content.ContentProvider(Context,String,String,PathPermission[])|Constr

*android.content.ContentProvider_Methods*
|android.content.ContentProvider.applyBatch(ArrayList<ContentProviderOperation>)|
|android.content.ContentProvider.attachInfo(Context,ProviderInfo)|After being i
|android.content.ContentProvider.attachInfoForTesting(Context,ProviderInfo)|Lik
|android.content.ContentProvider.bulkInsert(Uri,ContentValues[])|Override this 
|android.content.ContentProvider.call(String,String,Bundle)|Call a provider-def
|android.content.ContentProvider.canonicalize(Uri)|Implement this to support ca
|android.content.ContentProvider.coerceToLocalContentProvider(IContentProvider)|
|android.content.ContentProvider.delete(Uri,String,String[])|Implement this to 
|android.content.ContentProvider.dump(FileDescriptor,PrintWriter,String[])|Prin
|android.content.ContentProvider.enforceReadPermissionInner(Uri)|
|android.content.ContentProvider.enforceWritePermissionInner(Uri)|
|android.content.ContentProvider.getAppOpsManager()|
|android.content.ContentProvider.getCallingPackage()|Return the package name of
|android.content.ContentProvider.getContext()|Retrieves the Context this provid
|android.content.ContentProvider.getIContentProvider()|Returns the Binder objec
|android.content.ContentProvider.getPathPermissions()|Return the path-based per
|android.content.ContentProvider.getReadPermission()|Return the name of the per
|android.content.ContentProvider.getStreamTypes(Uri,String)|Called by a client 
|android.content.ContentProvider.getType(Uri)|Implement this to handle requests
|android.content.ContentProvider.getWritePermission()|Return the name of the pe
|android.content.ContentProvider.insert(Uri,ContentValues)|Implement this to ha
|android.content.ContentProvider.isTemporary()|Returns true if this instance is
|android.content.ContentProvider.onConfigurationChanged(Configuration)|This met
|android.content.ContentProvider.onCreate()|Implement this to initialize your c
|android.content.ContentProvider.onLowMemory()|This method is always called on 
|android.content.ContentProvider.onTrimMemory(int)|
|android.content.ContentProvider.openAssetFile(Uri,String)|This is like#openFil
|android.content.ContentProvider.openAssetFile(Uri,String,CancellationSignal)|T
|android.content.ContentProvider.openFile(Uri,String)|Override this to handle r
|android.content.ContentProvider.openFile(Uri,String,CancellationSignal)|Overri
|android.content.ContentProvider.openFileHelper(Uri,String)|Convenience for sub
|android.content.ContentProvider.openPipeHelper(Uri,String,Bundle,T,ContentProvider.PipeDataWriter<T>)|
|android.content.ContentProvider.openTypedAssetFile(Uri,String,Bundle)|Called b
|android.content.ContentProvider.openTypedAssetFile(Uri,String,Bundle,CancellationSignal)|
|android.content.ContentProvider.query(Uri,String[],String,String[],String)|Imp
|android.content.ContentProvider.query(Uri,String[],String,String[],String,CancellationSignal)|
|android.content.ContentProvider.rejectInsert(Uri,ContentValues)|
|android.content.ContentProvider.rejectQuery(Uri,String[],String,String[],String,CancellationSignal)|
|android.content.ContentProvider.setAppOps(int,int)|
|android.content.ContentProvider.setPathPermissions(PathPermission[])|Change th
|android.content.ContentProvider.setReadPermission(String)|Change the permissio
|android.content.ContentProvider.setWritePermission(String)|Change the permissi
|android.content.ContentProvider.shutdown()|Implement this to shut down the Con
|android.content.ContentProvider.uncanonicalize(Uri)|Remove canonicalization fr
|android.content.ContentProvider.update(Uri,ContentValues,String,String[])|Impl

*android.content.ContentProvider_Description*

Content providers are one of the primary building blocks of Android 
applications, providing content to applications. They encapsulate data and 
provide it to applications through the single 
(|android.content.ContentResolver|) interface. A content provider is only 
required if you need to share data between multiple applications. For example, 
the contacts data is used by multiple applications and must be stored in a 
content provider. If you don't need to share data amongst multiple applications 
you can use a database directly via (|android.database.sqlite.SQLiteDatabase|) 
. 

When a request is made via a (|android.content.ContentResolver|) the system 
inspects the authority of the given URI and passes the request to the content 
provider registered with the authority. The content provider can interpret the 
rest of the URI however it wants. The (|android.content.UriMatcher|) class is 
helpful for parsing URIs. 

The primary methods that need to be implemented are: 

(|android.content.ContentProvider|) which is called to initialize the provider 
(|android.content.ContentProvider|) which returns data to the caller 
(|android.content.ContentProvider|) which inserts new data into the content 
provider (|android.content.ContentProvider|) which updates existing data in the 
content provider (|android.content.ContentProvider|) which deletes data from 
the content provider (|android.content.ContentProvider|) which returns the MIME 
type of data in the content provider 

Data access methods (such as (|android.content.ContentProvider|) and 
(|android.content.ContentProvider|) ) may be called from many threads at once, 
and must be thread-safe. Other methods (such as 
(|android.content.ContentProvider|) ) are only called from the application main 
thread, and must avoid performing lengthy operations. See the method 
descriptions for their expected thread behavior. 

Requests to (|android.content.ContentResolver|) are automatically forwarded to 
the appropriate ContentProvider instance, so subclasses don't have to worry 
about the details of cross-process calls. 

Developer Guides For more information about using content providers, read the 
<a href="guide/topics/providers/content-providers.html">Content Providers 
developer guide. 



*android.content.ContentProvider()*

public ContentProvider()

Construct a ContentProvider instance. Content providers must be <a 
href="guide/topics/manifest/provider-element.html">declared in the manifest, 
accessed with (|android.content.ContentResolver|) , and created automatically 
by the system, so applications usually do not create ContentProvider instances 
directly. 

At construction time, the object is uninitialized, and most fields and methods 
are unavailable. Subclasses should initialize themselves in 
(|android.content.ContentProvider|) , not the constructor. 

Content providers are created on the application main thread at application 
launch time. The constructor must not perform lengthy operations, or 
application startup will be delayed. 


*android.content.ContentProvider(Context,String,String,PathPermission[])*

public ContentProvider(
  android.content.Context context,
  java.lang.String readPermission,
  java.lang.String writePermission,
  android.content.pm.PathPermission[] pathPermissions)

Constructor just for mocking. 

    context - A Context object which should be some mock instance (like the instance of 
       {@link android.test.mock.MockContext}). 
    readPermission - The read permision you want this instance should have in the test, which is 
       available via {@link #getReadPermission()}. 
    writePermission - The write permission you want this instance should have in the test, which is 
       available via {@link #getWritePermission()}. 
    pathPermissions - The PathPermissions you want this instance should have in the test, which is 
       available via {@link #getPathPermissions()}. 

*android.content.ContentProvider.applyBatch(ArrayList<ContentProviderOperation>)*

public |android.content.ContentProviderResult|[] applyBatch(java.util.ArrayList<android.content.ContentProviderOperation> operations)
  throws |android.content.OperationApplicationException|
         
Override this to handle requests to perform a batch of operations, or the 
default implementation will iterate over the operations and call 
(|android.content.ContentProviderOperation|) on each of them. If all calls to 
(|android.content.ContentProviderOperation|) succeed then a 
(|android.content.ContentProviderResult|) array with as many elements as there 
were operations will be returned. If any of the calls fail, it is up to the 
implementation how many of the others take effect. This method can be called 
from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 


    operations - the operations to apply 

    Returns: the results of the applications 

*android.content.ContentProvider.attachInfo(Context,ProviderInfo)*

public void attachInfo(
  android.content.Context context,
  android.content.pm.ProviderInfo info)

After being instantiated, this is called to tell the content provider about 
itself. 


    context - The context this provider is running in 
    info - Registered information about this content provider 

*android.content.ContentProvider.attachInfoForTesting(Context,ProviderInfo)*

public void attachInfoForTesting(
  android.content.Context context,
  android.content.pm.ProviderInfo info)

Like (|android.content.ContentProvider|) , but for use when directly 
instantiating the provider for testing. 



*android.content.ContentProvider.bulkInsert(Uri,ContentValues[])*

public int bulkInsert(
  android.net.Uri uri,
  android.content.ContentValues[] values)

Override this to handle requests to insert a set of new rows, or the default 
implementation will iterate over the values and call 
(|android.content.ContentProvider|) on each of them. As a courtesy, call 
notifyChange()(|android.content.ContentResolver|) after inserting. This method 
can be called from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 


    uri - The content:// URI of the insertion request. 
    values - An array of sets of column_name/value pairs to add to the database. This must 
       not be {@code null}. 

    Returns: The number of values that were inserted. 

*android.content.ContentProvider.call(String,String,Bundle)*

public |android.os.Bundle| call(
  java.lang.String method,
  java.lang.String arg,
  android.os.Bundle extras)

Call a provider-defined method. This can be used to implement interfaces that 
are cheaper and/or unnatural for a table-like model. 

WARNING: The framework does no permission checking on this entry into the 
content provider besides the basic ability for the application to get access to 
the provider at all. For example, it has no idea whether the call being 
executed may read or write data in the provider, so can't enforce those 
individual permissions. Any implementation of this method must do its own 
permission checks on incoming calls to make sure they are allowed. 


    method - method name to call. Opaque to framework, but should not be {@code null}. 
    arg - provider-defined String argument. May be {@code null}. 
    extras - provider-defined Bundle argument. May be {@code null}. 

    Returns: provider-defined return value. May be {@code null}, which is also the default 
             for providers which don't implement any call methods. 

*android.content.ContentProvider.canonicalize(Uri)*

public |android.net.Uri| canonicalize(android.net.Uri url)

Implement this to support canonicalization of URIs that refer to your content 
provider. A canonical URI is one that can be transported across devices, 
backup/restore, and other contexts, and still be able to refer to the same data 
item. Typically this is implemented by adding query params to the URI allowing 
the content provider to verify that an incoming canonical URI references the 
same data as it was originally intended for and, if it doesn't, to find that 
data (if it exists) in the current environment. 

For example, if the content provider holds people and a normal URI in it is 
created with a row index into that people database, the cananical 
representation may have an additional query param at the end which specifies 
the name of the person it is intended for. Later calls into the provider with 
that URI will look up the row of that URI's base index and, if it doesn't match 
or its entry's name doesn't match the name in the query param, perform a query 
on its database to find the correct row to operate on. 

If you implement support for canonical URIs, all incoming calls with URIs 
(including this one) must perform this verification and recovery of any 
canonical URIs they receive. In addition, you must also implement 
(|android.content.ContentProvider|) to strip the canonicalization of any of 
these URIs. 

The default implementation of this method returns null, indicating that 
canonical URIs are not supported. 


    url - The Uri to canonicalize. 

    Returns: Return the canonical representation of url, or null if canonicalization of that 
             Uri is not supported. 

*android.content.ContentProvider.coerceToLocalContentProvider(IContentProvider)*

public static |android.content.ContentProvider| coerceToLocalContentProvider(android.content.IContentProvider abstractInterface)

Given an IContentProvider, try to coerce it back to the real ContentProvider 
object if it is running in the local process. This can be used if you know you 
are running in the same process as a provider, and want to get direct access to 
its implementation details. Most clients should not nor have a reason to use 
it. 


    abstractInterface - The ContentProvider interface that is to be coerced. 

    Returns: If the IContentProvider is non-{@code null} and local, returns its actual 
             ContentProvider instance. Otherwise returns {@code null}. 

*android.content.ContentProvider.delete(Uri,String,String[])*

public abstract int delete(
  android.net.Uri uri,
  java.lang.String selection,
  java.lang.String[] selectionArgs)

Implement this to handle requests to delete one or more rows. The 
implementation should apply the selection clause when performing deletion, 
allowing the operation to affect multiple rows in a directory. As a courtesy, 
call notifyDelete()(|android.content.ContentResolver|) after deleting. This 
method can be called from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 

The implementation is responsible for parsing out a row ID at the end of the 
URI, if a specific row is being deleted. That is, the client would pass in 
content://contacts/people/22 and the implementation is responsible for parsing 
the record number (22) when creating a SQL statement. 


    uri - The full URI to query, including a row ID (if a specific record is requested). 
    selection - An optional restriction to apply to rows when deleting. 

    Returns: The number of rows affected. 

*android.content.ContentProvider.dump(FileDescriptor,PrintWriter,String[])*

public void dump(
  java.io.FileDescriptor fd,
  java.io.PrintWriter writer,
  java.lang.String[] args)

Print the Provider's state into the given stream. This gets invoked if you run 
"adb shell dumpsys activity provider <provider_component_name>". 


    fd - The raw file descriptor that the dump is being sent to. 
    writer - The PrintWriter to which you should dump your state. This will be closed for 
       you after you return. 
    args - additional arguments to the dump request. 

*android.content.ContentProvider.enforceReadPermissionInner(Uri)*

protected void enforceReadPermissionInner(android.net.Uri uri)
  throws |java.lang.SecurityException|
         




*android.content.ContentProvider.enforceWritePermissionInner(Uri)*

protected void enforceWritePermissionInner(android.net.Uri uri)
  throws |java.lang.SecurityException|
         




*android.content.ContentProvider.getAppOpsManager()*

public |android.app.AppOpsManager| getAppOpsManager()





*android.content.ContentProvider.getCallingPackage()*

public final |java.lang.String| getCallingPackage()

Return the package name of the caller that initiated the request being 
processed on the current thread. The returned package will have been verified 
to belong to the calling UID. Returnsnullif not currently processing a request. 

This will always returnnullwhen processing (|android.content.ContentProvider|) 
or (|android.content.ContentProvider|) requests. 



*android.content.ContentProvider.getContext()*

public final |android.content.Context| getContext()

Retrieves the Context this provider is running in. Only available once 
(|android.content.ContentProvider|) has been called -- this will returnnullin 
the constructor. 



*android.content.ContentProvider.getIContentProvider()*

public |android.content.IContentProvider| getIContentProvider()

Returns the Binder object for this provider. 



    Returns: the Binder object for this provider 

*android.content.ContentProvider.getPathPermissions()*

public final |android.content.pm.PathPermission|[] getPathPermissions()

Return the path-based permissions required for read and/or write access to this 
content provider. This method can be called from multiple threads, as described 
in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 



*android.content.ContentProvider.getReadPermission()*

public final |java.lang.String| getReadPermission()

Return the name of the permission required for read-only access to this content 
provider. This method can be called from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 



*android.content.ContentProvider.getStreamTypes(Uri,String)*

public |java.lang.String|[] getStreamTypes(
  android.net.Uri uri,
  java.lang.String mimeTypeFilter)

Called by a client to determine the types of data streams that this content 
provider supports for the given URI. The default implementation returnsnull, 
meaning no types. If your content provider stores data of a particular type, 
return that MIME type if it matches the given mimeTypeFilter. If it can perform 
type conversions, return an array of all supported MIME types that match 
mimeTypeFilter. 


    uri - The data in the content provider being queried. 
    mimeTypeFilter - The type of data the client desires. May be a pattern, such as *\/* to retrieve 
       all possible data types. 

    Returns: Returns {@code null} if there are no possible data streams for the given 
             mimeTypeFilter. Otherwise returns an array of all available 
             concrete MIME types. 

*android.content.ContentProvider.getType(Uri)*

public abstract |java.lang.String| getType(android.net.Uri uri)

Implement this to handle requests for the MIME type of the data at the given 
URI. The returned MIME type should start with vnd.android.cursor.item for a 
single record, or vnd.android.cursor.dir/ for multiple items. This method can 
be called from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 

Note that there are no permissions needed for an application to access this 
information; if your content provider requires read and/or write permissions, 
or is not exported, all applications can still call this method regardless of 
their access permissions. This allows them to retrieve the MIME type for a URI 
when dispatching intents. 


    uri - the URI to query. 

    Returns: a MIME type string, or {@code null} if there is no type. 

*android.content.ContentProvider.getWritePermission()*

public final |java.lang.String| getWritePermission()

Return the name of the permission required for read/write access to this 
content provider. This method can be called from multiple threads, as described 
in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 



*android.content.ContentProvider.insert(Uri,ContentValues)*

public abstract |android.net.Uri| insert(
  android.net.Uri uri,
  android.content.ContentValues values)

Implement this to handle requests to insert a new row. As a courtesy, call 
notifyChange()(|android.content.ContentResolver|) after inserting. This method 
can be called from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 


    uri - The content:// URI of the insertion request. This must not be {@code null}. 
    values - A set of column_name/value pairs to add to the database. This must not be 
       {@code null}. 

    Returns: The URI for the newly inserted item. 

*android.content.ContentProvider.isTemporary()*

protected boolean isTemporary()

Returns true if this instance is a temporary content provider. 



    Returns: true if this instance is a temporary content provider 

*android.content.ContentProvider.onConfigurationChanged(Configuration)*

public void onConfigurationChanged(android.content.res.Configuration newConfig)

This method is always called on the application main thread, and must not 
perform lengthy operations. 

The default content provider implementation does nothing. Override this method 
to take appropriate action. (Content providers do not usually care about things 
like screen orientation, but may want to know about locale changes.) 



*android.content.ContentProvider.onCreate()*

public abstract boolean onCreate()

Implement this to initialize your content provider on startup. This method is 
called for all registered content providers on the application main thread at 
application launch time. It must not perform lengthy operations, or application 
startup will be delayed. 

You should defer nontrivial initialization (such as opening, upgrading, and 
scanning databases) until the content provider is used (via 
(|android.content.ContentProvider|) , (|android.content.ContentProvider|) , 
etc). Deferred initialization keeps application startup fast, avoids 
unnecessary work if the provider turns out not to be needed, and stops database 
errors (such as a full disk) from halting application launch. 

If you use SQLite, (|android.database.sqlite.SQLiteOpenHelper|) is a helpful 
utility class that makes it easy to manage databases, and will automatically 
defer opening until first use. If you do use SQLiteOpenHelper, make sure to 
avoid calling (|android.database.sqlite.SQLiteOpenHelper|) or 
(|android.database.sqlite.SQLiteOpenHelper|) from this method. (Instead, 
override (|android.database.sqlite.SQLiteOpenHelper|) to initialize the 
database when it is first opened.) 



    Returns: true if the provider was successfully loaded, false otherwise 

*android.content.ContentProvider.onLowMemory()*

public void onLowMemory()

This method is always called on the application main thread, and must not 
perform lengthy operations. 

The default content provider implementation does nothing. Subclasses may 
override this method to take appropriate action. 



*android.content.ContentProvider.onTrimMemory(int)*

public void onTrimMemory(int level)





*android.content.ContentProvider.openAssetFile(Uri,String)*

public |android.content.res.AssetFileDescriptor| openAssetFile(
  android.net.Uri uri,
  java.lang.String mode)
  throws |java.io.FileNotFoundException|
         
This is like (|android.content.ContentProvider|) , but can be implemented by 
providers that need to be able to return sub-sections of files, often assets 
inside of their .apk. This method can be called from multiple threads, as 
described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 

If you implement this, your clients must be able to deal with such file slices, 
either directly with (|android.content.ContentResolver|) , or by using the 
higher-level ContentResolver.openInputStream(|android.content.ContentResolver|) 
or ContentResolver.openOutputStream(|android.content.ContentResolver|) methods. 

The returned AssetFileDescriptor can be a pipe or socket pair to enable 
streaming of data. 

If you are implementing this to return a full file, you should create the 
AssetFileDescriptor with (|android.content.res.AssetFileDescriptor|) to be 
compatible with applications that cannot handle sub-sections of files. 

For use in Intents, you will want to implement 
(|android.content.ContentProvider|) to return the appropriate MIME type for the 
data returned here with the same URI. This will allow intent resolution to 
automatically determine the data MIME type and select the appropriate matching 
targets as part of its operation. 

For better interoperability with other applications, it is recommended that for 
any URIs that can be opened, you also support queries on them containing at 
least the columns specified by (|android.provider.OpenableColumns|) . 


    uri - The URI whose file is to be opened. 
    mode - Access mode for the file. May be "r" for read-only access, "w" for write-only 
       access (erasing whatever data is currently in the file), "wa" for 
       write-only access to append to any existing data, "rw" for read and 
       write access on any existing data, and "rwt" for read and write access 
       that truncates any existing file. 

    Returns: Returns a new AssetFileDescriptor which you can use to access the file. 

*android.content.ContentProvider.openAssetFile(Uri,String,CancellationSignal)*

public |android.content.res.AssetFileDescriptor| openAssetFile(
  android.net.Uri uri,
  java.lang.String mode,
  android.os.CancellationSignal signal)
  throws |java.io.FileNotFoundException|
         
This is like (|android.content.ContentProvider|) , but can be implemented by 
providers that need to be able to return sub-sections of files, often assets 
inside of their .apk. This method can be called from multiple threads, as 
described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 

If you implement this, your clients must be able to deal with such file slices, 
either directly with (|android.content.ContentResolver|) , or by using the 
higher-level ContentResolver.openInputStream(|android.content.ContentResolver|) 
or ContentResolver.openOutputStream(|android.content.ContentResolver|) methods. 

The returned AssetFileDescriptor can be a pipe or socket pair to enable 
streaming of data. 

If you are implementing this to return a full file, you should create the 
AssetFileDescriptor with (|android.content.res.AssetFileDescriptor|) to be 
compatible with applications that cannot handle sub-sections of files. 

For use in Intents, you will want to implement 
(|android.content.ContentProvider|) to return the appropriate MIME type for the 
data returned here with the same URI. This will allow intent resolution to 
automatically determine the data MIME type and select the appropriate matching 
targets as part of its operation. 

For better interoperability with other applications, it is recommended that for 
any URIs that can be opened, you also support queries on them containing at 
least the columns specified by (|android.provider.OpenableColumns|) . 


    uri - The URI whose file is to be opened. 
    mode - Access mode for the file. May be "r" for read-only access, "w" for write-only 
       access (erasing whatever data is currently in the file), "wa" for 
       write-only access to append to any existing data, "rw" for read and 
       write access on any existing data, and "rwt" for read and write access 
       that truncates any existing file. 
    signal - A signal to cancel the operation in progress, or {@code null} if none. For 
       example, if you are downloading a file from the network to service a 
       "rw" mode request, you should periodically call {@link 
       CancellationSignal#throwIfCanceled()} to check whether the client has 
       canceled the request and abort the download. 

    Returns: Returns a new AssetFileDescriptor which you can use to access the file. 

*android.content.ContentProvider.openFile(Uri,String)*

public |android.os.ParcelFileDescriptor| openFile(
  android.net.Uri uri,
  java.lang.String mode)
  throws |java.io.FileNotFoundException|
         
Override this to handle requests to open a file blob. The default 
implementation always throws (|java.io.FileNotFoundException|) . This method 
can be called from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 

This method returns a ParcelFileDescriptor, which is returned directly to the 
caller. This way large data (such as images and documents) can be returned 
without copying the content. 

The returned ParcelFileDescriptor is owned by the caller, so it is their 
responsibility to close it when done. That is, the implementation of this 
method should create a new ParcelFileDescriptor for each call. 

If opened with the exclusive "r" or "w" modes, the returned 
ParcelFileDescriptor can be a pipe or socket pair to enable streaming of data. 
Opening with the "rw" or "rwt" modes implies a file on disk that supports 
seeking. 

If you need to detect when the returned ParcelFileDescriptor has been closed, 
or if the remote process has crashed or encountered some other error, you can 
use (|android.os.ParcelFileDescriptor|) , (|android.os.ParcelFileDescriptor|) , 
or (|android.os.ParcelFileDescriptor|) . 

For use in Intents, you will want to implement 
(|android.content.ContentProvider|) to return the appropriate MIME type for the 
data returned here with the same URI. This will allow intent resolution to 
automatically determine the data MIME type and select the appropriate matching 
targets as part of its operation. 

For better interoperability with other applications, it is recommended that for 
any URIs that can be opened, you also support queries on them containing at 
least the columns specified by (|android.provider.OpenableColumns|) . You may 
also want to support other common columns if you have additional meta-data to 
supply, such as (|android.provider.MediaStore.MediaColumns|) in 
(|android.provider.MediaStore.MediaColumns|) . 


    uri - The URI whose file is to be opened. 
    mode - Access mode for the file. May be "r" for read-only access, "rw" for read and 
       write access, or "rwt" for read and write access that truncates any 
       existing file. 

    Returns: Returns a new ParcelFileDescriptor which you can use to access the file. 

*android.content.ContentProvider.openFile(Uri,String,CancellationSignal)*

public |android.os.ParcelFileDescriptor| openFile(
  android.net.Uri uri,
  java.lang.String mode,
  android.os.CancellationSignal signal)
  throws |java.io.FileNotFoundException|
         
Override this to handle requests to open a file blob. The default 
implementation always throws (|java.io.FileNotFoundException|) . This method 
can be called from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 

This method returns a ParcelFileDescriptor, which is returned directly to the 
caller. This way large data (such as images and documents) can be returned 
without copying the content. 

The returned ParcelFileDescriptor is owned by the caller, so it is their 
responsibility to close it when done. That is, the implementation of this 
method should create a new ParcelFileDescriptor for each call. 

If opened with the exclusive "r" or "w" modes, the returned 
ParcelFileDescriptor can be a pipe or socket pair to enable streaming of data. 
Opening with the "rw" or "rwt" modes implies a file on disk that supports 
seeking. 

If you need to detect when the returned ParcelFileDescriptor has been closed, 
or if the remote process has crashed or encountered some other error, you can 
use (|android.os.ParcelFileDescriptor|) , (|android.os.ParcelFileDescriptor|) , 
or (|android.os.ParcelFileDescriptor|) . 

For use in Intents, you will want to implement 
(|android.content.ContentProvider|) to return the appropriate MIME type for the 
data returned here with the same URI. This will allow intent resolution to 
automatically determine the data MIME type and select the appropriate matching 
targets as part of its operation. 

For better interoperability with other applications, it is recommended that for 
any URIs that can be opened, you also support queries on them containing at 
least the columns specified by (|android.provider.OpenableColumns|) . You may 
also want to support other common columns if you have additional meta-data to 
supply, such as (|android.provider.MediaStore.MediaColumns|) in 
(|android.provider.MediaStore.MediaColumns|) . 


    uri - The URI whose file is to be opened. 
    mode - Access mode for the file. May be "r" for read-only access, "w" for write-only 
       access, "rw" for read and write access, or "rwt" for read and write 
       access that truncates any existing file. 
    signal - A signal to cancel the operation in progress, or {@code null} if none. For 
       example, if you are downloading a file from the network to service a 
       "rw" mode request, you should periodically call {@link 
       CancellationSignal#throwIfCanceled()} to check whether the client has 
       canceled the request and abort the download. 

    Returns: Returns a new ParcelFileDescriptor which you can use to access the file. 

*android.content.ContentProvider.openFileHelper(Uri,String)*

protected final |android.os.ParcelFileDescriptor| openFileHelper(
  android.net.Uri uri,
  java.lang.String mode)
  throws |java.io.FileNotFoundException|
         
Convenience for subclasses that wish to implement 
(|android.content.ContentProvider|) by looking up a column named "_data" at the 
given URI. 


    uri - The URI to be opened. 
    mode - The file mode. May be "r" for read-only access, "w" for write-only access 
       (erasing whatever data is currently in the file), "wa" for write-only 
       access to append to any existing data, "rw" for read and write access on 
       any existing data, and "rwt" for read and write access that truncates 
       any existing file. 

    Returns: Returns a new ParcelFileDescriptor that can be used by the client to access the 
             file. 

*android.content.ContentProvider.openPipeHelper(Uri,String,Bundle,T,ContentProvider.PipeDataWriter<T>)*

public |android.os.ParcelFileDescriptor| openPipeHelper(
  android.net.Uri uri,
  java.lang.String mimeType,
  android.os.Bundle opts,
  T args,
  android.content.ContentProvider.PipeDataWriter<T> func)
  throws |java.io.FileNotFoundException|
         
A helper function for implementing (|android.content.ContentProvider|) , for 
creating a data pipe and background thread allowing you to stream generated 
data back to the client. This function returns a new ParcelFileDescriptor that 
should be returned to the caller (the caller is responsible for closing it). 


    uri - The URI whose data is to be written. 
    mimeType - The desired type of data to be written. 
    opts - Options supplied by caller. 
    args - Your own custom arguments. 
    func - Interface implementing the function that will actually stream the data. 

    Returns: Returns a new ParcelFileDescriptor holding the read side of the pipe. This 
             should be returned to the caller for reading; the caller is 
             responsible for closing it when done. 

*android.content.ContentProvider.openTypedAssetFile(Uri,String,Bundle)*

public |android.content.res.AssetFileDescriptor| openTypedAssetFile(
  android.net.Uri uri,
  java.lang.String mimeTypeFilter,
  android.os.Bundle opts)
  throws |java.io.FileNotFoundException|
         
Called by a client to open a read-only stream containing data of a particular 
MIME type. This is like (|android.content.ContentProvider|) , except the file 
can only be read-only and the content provider may perform data conversions to 
generate data of the desired type. 

The default implementation compares the given mimeType against the result of 
(|android.content.ContentProvider|) and, if they match, simply calls 
(|android.content.ContentProvider|) . 

See (|android.content.ClipData|) for examples of the use and implementation of 
this method. 

The returned AssetFileDescriptor can be a pipe or socket pair to enable 
streaming of data. 

For better interoperability with other applications, it is recommended that for 
any URIs that can be opened, you also support queries on them containing at 
least the columns specified by (|android.provider.OpenableColumns|) . You may 
also want to support other common columns if you have additional meta-data to 
supply, such as (|android.provider.MediaStore.MediaColumns|) in 
(|android.provider.MediaStore.MediaColumns|) . 


    uri - The data in the content provider being queried. 
    mimeTypeFilter - The type of data the client desires. May be a pattern, such as *\/*, if the 
       caller does not have specific type requirements; in this case the 
       content provider will pick its best type matching the pattern. 
    opts - Additional options from the client. The definitions of these are specific to 
       the content provider being called. 

    Returns: Returns a new AssetFileDescriptor from which the client can read data of the 
             desired type. 

*android.content.ContentProvider.openTypedAssetFile(Uri,String,Bundle,CancellationSignal)*

public |android.content.res.AssetFileDescriptor| openTypedAssetFile(
  android.net.Uri uri,
  java.lang.String mimeTypeFilter,
  android.os.Bundle opts,
  android.os.CancellationSignal signal)
  throws |java.io.FileNotFoundException|
         
Called by a client to open a read-only stream containing data of a particular 
MIME type. This is like (|android.content.ContentProvider|) , except the file 
can only be read-only and the content provider may perform data conversions to 
generate data of the desired type. 

The default implementation compares the given mimeType against the result of 
(|android.content.ContentProvider|) and, if they match, simply calls 
(|android.content.ContentProvider|) . 

See (|android.content.ClipData|) for examples of the use and implementation of 
this method. 

The returned AssetFileDescriptor can be a pipe or socket pair to enable 
streaming of data. 

For better interoperability with other applications, it is recommended that for 
any URIs that can be opened, you also support queries on them containing at 
least the columns specified by (|android.provider.OpenableColumns|) . You may 
also want to support other common columns if you have additional meta-data to 
supply, such as (|android.provider.MediaStore.MediaColumns|) in 
(|android.provider.MediaStore.MediaColumns|) . 


    uri - The data in the content provider being queried. 
    mimeTypeFilter - The type of data the client desires. May be a pattern, such as *\/*, if the 
       caller does not have specific type requirements; in this case the 
       content provider will pick its best type matching the pattern. 
    opts - Additional options from the client. The definitions of these are specific to 
       the content provider being called. 
    signal - A signal to cancel the operation in progress, or {@code null} if none. For 
       example, if you are downloading a file from the network to service a 
       "rw" mode request, you should periodically call {@link 
       CancellationSignal#throwIfCanceled()} to check whether the client has 
       canceled the request and abort the download. 

    Returns: Returns a new AssetFileDescriptor from which the client can read data of the 
             desired type. 

*android.content.ContentProvider.query(Uri,String[],String,String[],String)*

public abstract |android.database.Cursor| query(
  android.net.Uri uri,
  java.lang.String[] projection,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String sortOrder)

Implement this to handle query requests from clients. This method can be called 
from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 

Example client call: 

// Request a specific record. Cursor managedCursor = managedQuery( 
ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2), projection, // 
Which columns to return. null, // WHERE clause. null, // WHERE clause value 
substitution People.NAME + " ASC"); // Sort order. 

Example implementation: 

// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax 
for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); 

// Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); 

// If the query ends in a specific record number, we're // being asked for a 
specific record, so set the // WHERE clause in our query. 
if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere("_id=" + 
uri.getPathLeafId()); } 

// Make the query. Cursor c = qBuilder.query(mDb, projection, selection, 
selectionArgs, groupBy, having, sortOrder); 
c.setNotificationUri(getContext().getContentResolver(), uri); return c; 


    uri - The URI to query. This will be the full URI sent by the client; if the client 
       is requesting a specific record, the URI will end in a record number 
       that the implementation should parse and add to a WHERE or HAVING 
       clause, specifying that _id value. 
    projection - The list of columns to put into the cursor. If {@code null} all columns are 
       included. 
    selection - A selection criteria to apply when filtering rows. If {@code null} then all 
       rows are included. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in order that they appear in the selection. The values 
       will be bound as Strings. 
    sortOrder - How the rows in the cursor should be sorted. If {@code null} then the provider 
       is free to define the sort order. 

    Returns: a Cursor or {@code null}. 

*android.content.ContentProvider.query(Uri,String[],String,String[],String,CancellationSignal)*

public |android.database.Cursor| query(
  android.net.Uri uri,
  java.lang.String[] projection,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String sortOrder,
  android.os.CancellationSignal cancellationSignal)

Implement this to handle query requests from clients with support for 
cancellation. This method can be called from multiple threads, as described in 
<a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 

Example client call: 

// Request a specific record. Cursor managedCursor = managedQuery( 
ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2), projection, // 
Which columns to return. null, // WHERE clause. null, // WHERE clause value 
substitution People.NAME + " ASC"); // Sort order. 

Example implementation: 

// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax 
for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); 

// Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); 

// If the query ends in a specific record number, we're // being asked for a 
specific record, so set the // WHERE clause in our query. 
if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere("_id=" + 
uri.getPathLeafId()); } 

// Make the query. Cursor c = qBuilder.query(mDb, projection, selection, 
selectionArgs, groupBy, having, sortOrder); 
c.setNotificationUri(getContext().getContentResolver(), uri); return c; 

If you implement this method then you must also implement the version of 
(|android.content.ContentProvider|) that does not take a cancellation signal to 
ensure correct operation on older versions of the Android Framework in which 
the cancellation signal overload was not available. 


    uri - The URI to query. This will be the full URI sent by the client; if the client 
       is requesting a specific record, the URI will end in a record number 
       that the implementation should parse and add to a WHERE or HAVING 
       clause, specifying that _id value. 
    projection - The list of columns to put into the cursor. If {@code null} all columns are 
       included. 
    selection - A selection criteria to apply when filtering rows. If {@code null} then all 
       rows are included. 
    selectionArgs - You may include ?s in selection, which will be replaced by the values from 
       selectionArgs, in order that they appear in the selection. The values 
       will be bound as Strings. 
    sortOrder - How the rows in the cursor should be sorted. If {@code null} then the provider 
       is free to define the sort order. 
    cancellationSignal - A signal to cancel the operation in progress, or {@code null} if none. If the 
       operation is canceled, then {@link OperationCanceledException} will be 
       thrown when the query is executed. 

    Returns: a Cursor or {@code null}. 

*android.content.ContentProvider.rejectInsert(Uri,ContentValues)*

public |android.net.Uri| rejectInsert(
  android.net.Uri uri,
  android.content.ContentValues values)





*android.content.ContentProvider.rejectQuery(Uri,String[],String,String[],String,CancellationSignal)*

public |android.database.Cursor| rejectQuery(
  android.net.Uri uri,
  java.lang.String[] projection,
  java.lang.String selection,
  java.lang.String[] selectionArgs,
  java.lang.String sortOrder,
  android.os.CancellationSignal cancellationSignal)





*android.content.ContentProvider.setAppOps(int,int)*

public final void setAppOps(
  int readOp,
  int writeOp)





*android.content.ContentProvider.setPathPermissions(PathPermission[])*

protected final void setPathPermissions(android.content.pm.PathPermission[] permissions)

Change the path-based permission required to read and/or write data in the 
content provider. This is normally set for you from its manifest information 
when the provider is first created. 


    permissions - Array of path permission descriptions. 

*android.content.ContentProvider.setReadPermission(String)*

protected final void setReadPermission(java.lang.String permission)

Change the permission required to read data from the content provider. This is 
normally set for you from its manifest information when the provider is first 
created. 


    permission - Name of the permission required for read-only access. 

*android.content.ContentProvider.setWritePermission(String)*

protected final void setWritePermission(java.lang.String permission)

Change the permission required to read and write data in the content provider. 
This is normally set for you from its manifest information when the provider is 
first created. 


    permission - Name of the permission required for read/write access. 

*android.content.ContentProvider.shutdown()*

public void shutdown()

Implement this to shut down the ContentProvider instance. You can then invoke 
this method in unit tests. 

Android normally handles ContentProvider startup and shutdown automatically. 
You do not need to start up or shut down a ContentProvider. When you invoke a 
test method on a ContentProvider, however, a ContentProvider instance is 
started and keeps running after the test finishes, even if a succeeding test 
instantiates another ContentProvider. A conflict develops because the two 
instances are usually running against the same underlying data source (for 
example, an sqlite database). 

Implementing shutDown() avoids this conflict by providing a way to terminate 
the ContentProvider. This method can also prevent memory leaks from multiple 
instantiations of the ContentProvider, and it can ensure unit test isolation by 
allowing you to completely clean up the test fixture before moving on to the 
next test. 



*android.content.ContentProvider.uncanonicalize(Uri)*

public |android.net.Uri| uncanonicalize(android.net.Uri url)

Remove canonicalization from canonical URIs previously returned by 
(|android.content.ContentProvider|) . For example, if your implementation is to 
add a query param to canonicalize a URI, this method can simply trip any query 
params on the URI. The default implementation always returns the same url that 
was passed in. 


    url - The Uri to remove any canonicalization from. 

    Returns: Return the non-canonical representation of url, return the url as-is if there 
             is nothing to do, or return null if the data identified by the 
             canonical representation can not be found in the current 
             environment. 

*android.content.ContentProvider.update(Uri,ContentValues,String,String[])*

public abstract int update(
  android.net.Uri uri,
  android.content.ContentValues values,
  java.lang.String selection,
  java.lang.String[] selectionArgs)

Implement this to handle requests to update one or more rows. The 
implementation should update all rows matching the selection to set the columns 
according to the provided values map. As a courtesy, call 
notifyChange()(|android.content.ContentResolver|) after updating. This method 
can be called from multiple threads, as described in <a 
href="guide/topics/fundamentals/processes-and-threads.html#Threads">Processes 
and Threads. 


    uri - The URI to query. This can potentially have a record ID if this is an update 
       request for a specific record. 
    values - A set of column_name/value pairs to update in the database. This must not be 
       {@code null}. 
    selection - An optional filter to match rows to update. 

    Returns: the number of rows affected. 


