*android.view.View* *View* 
 This class represents the basic building block for 

public class View
  extends    |java.lang.Object|
  implements |android.view.KeyEvent.Callback|
             |android.view.accessibility.AccessibilityEventSource|

|android.view.View_Description|
|android.view.View_Fields|
|android.view.View_Constructors|
|android.view.View_Methods|

================================================================================

*android.view.View_Fields*
|int_android.view.View.ACCESSIBILITY_CURSOR_POSITION_UNDEFINED|
|int_android.view.View.ACCESSIBILITY_LIVE_REGION_ASSERTIVE|
|int_android.view.View.ACCESSIBILITY_LIVE_REGION_NONE|
|int_android.view.View.ACCESSIBILITY_LIVE_REGION_POLITE|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.ALPHA|
|java.lang.String_android.view.View.DEBUG_LAYOUT_PROPERTY|
|int_android.view.View.DRAG_FLAG_GLOBAL|
|int_android.view.View.DRAWING_CACHE_QUALITY_AUTO|
|int_android.view.View.DRAWING_CACHE_QUALITY_HIGH|
|int_android.view.View.DRAWING_CACHE_QUALITY_LOW|
|int[]_android.view.View.EMPTY_STATE_SET|
|int[]_android.view.View.ENABLED_FOCUSED_SELECTED_STATE_SET|
|int[]_android.view.View.ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.ENABLED_FOCUSED_STATE_SET|
|int[]_android.view.View.ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.ENABLED_SELECTED_STATE_SET|
|int[]_android.view.View.ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.ENABLED_STATE_SET|
|int[]_android.view.View.ENABLED_WINDOW_FOCUSED_STATE_SET|
|int_android.view.View.FIND_VIEWS_WITH_ACCESSIBILITY_NODE_PROVIDERS|
|int_android.view.View.FIND_VIEWS_WITH_CONTENT_DESCRIPTION|
|int_android.view.View.FIND_VIEWS_WITH_TEXT|
|int_android.view.View.FOCUS_BACKWARD|
|int_android.view.View.FOCUS_DOWN|
|int_android.view.View.FOCUS_FORWARD|
|int_android.view.View.FOCUS_LEFT|
|int_android.view.View.FOCUS_RIGHT|
|int_android.view.View.FOCUS_UP|
|int_android.view.View.FOCUSABLES_ALL|
|int_android.view.View.FOCUSABLES_TOUCH_MODE|
|int[]_android.view.View.FOCUSED_SELECTED_STATE_SET|
|int[]_android.view.View.FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.FOCUSED_STATE_SET|
|int[]_android.view.View.FOCUSED_WINDOW_FOCUSED_STATE_SET|
|int_android.view.View.GONE|
|int_android.view.View.HAPTIC_FEEDBACK_ENABLED|
|int_android.view.View.IMPORTANT_FOR_ACCESSIBILITY_AUTO|
|int_android.view.View.IMPORTANT_FOR_ACCESSIBILITY_NO|
|int_android.view.View.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS|
|int_android.view.View.IMPORTANT_FOR_ACCESSIBILITY_YES|
|int_android.view.View.INVISIBLE|
|int_android.view.View.KEEP_SCREEN_ON|
|int_android.view.View.LAYER_TYPE_HARDWARE|
|int_android.view.View.LAYER_TYPE_NONE|
|int_android.view.View.LAYER_TYPE_SOFTWARE|
|int_android.view.View.LAYOUT_DIRECTION_INHERIT|
|int_android.view.View.LAYOUT_DIRECTION_LOCALE|
|int_android.view.View.LAYOUT_DIRECTION_LTR|
|int_android.view.View.LAYOUT_DIRECTION_RTL|
|int_android.view.View.mBottom|
|boolean_android.view.View.mCachingFailed|
|android.content.Context_android.view.View.mContext|
|android.view.animation.Animation_android.view.View.mCurrentAnimation|
|int_android.view.View.MEASURED_HEIGHT_STATE_SHIFT|
|int_android.view.View.MEASURED_SIZE_MASK|
|int_android.view.View.MEASURED_STATE_MASK|
|int_android.view.View.MEASURED_STATE_TOO_SMALL|
|android.view.InputEventConsistencyVerifier_android.view.View.mInputEventConsistencyVerifier|
|android.view.ViewGroup.LayoutParams_android.view.View.mLayoutParams|
|int_android.view.View.mLeft|
|int_android.view.View.mPaddingBottom|
|int_android.view.View.mPaddingLeft|
|int_android.view.View.mPaddingRight|
|int_android.view.View.mPaddingTop|
|android.view.ViewParent_android.view.View.mParent|
|int_android.view.View.mRight|
|int_android.view.View.mScrollX|
|int_android.view.View.mScrollY|
|java.lang.Object_android.view.View.mTag|
|int_android.view.View.mTop|
|int_android.view.View.mUserPaddingBottom|
|int_android.view.View.mUserPaddingLeft|
|int_android.view.View.mUserPaddingRight|
|int_android.view.View.NAVIGATION_BAR_TRANSIENT|
|int_android.view.View.NAVIGATION_BAR_TRANSLUCENT|
|int_android.view.View.NAVIGATION_BAR_UNHIDE|
|int_android.view.View.NO_ID|
|int_android.view.View.OVER_SCROLL_ALWAYS|
|int_android.view.View.OVER_SCROLL_IF_CONTENT_SCROLLS|
|int_android.view.View.OVER_SCROLL_NEVER|
|int[]_android.view.View.PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET|
|int[]_android.view.View.PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.PRESSED_ENABLED_FOCUSED_STATE_SET|
|int[]_android.view.View.PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.PRESSED_ENABLED_SELECTED_STATE_SET|
|int[]_android.view.View.PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.PRESSED_ENABLED_STATE_SET|
|int[]_android.view.View.PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.PRESSED_FOCUSED_SELECTED_STATE_SET|
|int[]_android.view.View.PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.PRESSED_FOCUSED_STATE_SET|
|int[]_android.view.View.PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.PRESSED_SELECTED_STATE_SET|
|int[]_android.view.View.PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET|
|int[]_android.view.View.PRESSED_STATE_SET|
|int[]_android.view.View.PRESSED_WINDOW_FOCUSED_STATE_SET|
|int_android.view.View.PUBLIC_STATUS_BAR_VISIBILITY_MASK|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.ROTATION|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.ROTATION_X|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.ROTATION_Y|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.SCALE_X|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.SCALE_Y|
|int_android.view.View.SCREEN_STATE_OFF|
|int_android.view.View.SCREEN_STATE_ON|
|int_android.view.View.SCROLLBAR_POSITION_DEFAULT|
|int_android.view.View.SCROLLBAR_POSITION_LEFT|
|int_android.view.View.SCROLLBAR_POSITION_RIGHT|
|int_android.view.View.SCROLLBARS_INSIDE_INSET|
|int_android.view.View.SCROLLBARS_INSIDE_OVERLAY|
|int_android.view.View.SCROLLBARS_OUTSIDE_INSET|
|int_android.view.View.SCROLLBARS_OUTSIDE_OVERLAY|
|int[]_android.view.View.SELECTED_STATE_SET|
|int[]_android.view.View.SELECTED_WINDOW_FOCUSED_STATE_SET|
|int_android.view.View.SOUND_EFFECTS_ENABLED|
|int_android.view.View.STATUS_BAR_DISABLE_BACK|
|int_android.view.View.STATUS_BAR_DISABLE_CLOCK|
|int_android.view.View.STATUS_BAR_DISABLE_EXPAND|
|int_android.view.View.STATUS_BAR_DISABLE_HOME|
|int_android.view.View.STATUS_BAR_DISABLE_NOTIFICATION_ALERTS|
|int_android.view.View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS|
|int_android.view.View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER|
|int_android.view.View.STATUS_BAR_DISABLE_RECENT|
|int_android.view.View.STATUS_BAR_DISABLE_SEARCH|
|int_android.view.View.STATUS_BAR_DISABLE_SYSTEM_INFO|
|int_android.view.View.STATUS_BAR_HIDDEN|
|int_android.view.View.STATUS_BAR_TRANSIENT|
|int_android.view.View.STATUS_BAR_TRANSLUCENT|
|int_android.view.View.STATUS_BAR_UNHIDE|
|int_android.view.View.STATUS_BAR_VISIBLE|
|int_android.view.View.SYSTEM_UI_CLEARABLE_FLAGS|
|int_android.view.View.SYSTEM_UI_FLAG_FULLSCREEN|
|int_android.view.View.SYSTEM_UI_FLAG_HIDE_NAVIGATION|
|int_android.view.View.SYSTEM_UI_FLAG_IMMERSIVE|
|int_android.view.View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY|
|int_android.view.View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|
|int_android.view.View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION|
|int_android.view.View.SYSTEM_UI_FLAG_LAYOUT_STABLE|
|int_android.view.View.SYSTEM_UI_FLAG_LOW_PROFILE|
|int_android.view.View.SYSTEM_UI_FLAG_VISIBLE|
|int_android.view.View.SYSTEM_UI_LAYOUT_FLAGS|
|int_android.view.View.TEXT_ALIGNMENT_CENTER|
|int_android.view.View.TEXT_ALIGNMENT_GRAVITY|
|int_android.view.View.TEXT_ALIGNMENT_INHERIT|
|int_android.view.View.TEXT_ALIGNMENT_TEXT_END|
|int_android.view.View.TEXT_ALIGNMENT_TEXT_START|
|int_android.view.View.TEXT_ALIGNMENT_VIEW_END|
|int_android.view.View.TEXT_ALIGNMENT_VIEW_START|
|int_android.view.View.TEXT_DIRECTION_ANY_RTL|
|int_android.view.View.TEXT_DIRECTION_FIRST_STRONG|
|int_android.view.View.TEXT_DIRECTION_INHERIT|
|int_android.view.View.TEXT_DIRECTION_LOCALE|
|int_android.view.View.TEXT_DIRECTION_LTR|
|int_android.view.View.TEXT_DIRECTION_RTL|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.TRANSLATION_X|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.TRANSLATION_Y|
|java.lang.String_android.view.View.VIEW_LOG_TAG|
|int_android.view.View.VISIBLE|
|int[]_android.view.View.WINDOW_FOCUSED_STATE_SET|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.X|
|android.util.Property<android.view.View, java.lang.Float>_android.view.View.Y|

*android.view.View_Constructors*
|android.view.View(Context)|Simple constructor to use when creating a view from
|android.view.View(Context,AttributeSet)|Constructor that is called when inflat
|android.view.View(Context,AttributeSet,int)|Perform inflation from XML and app

*android.view.View_Methods*
|android.view.View.addChildrenForAccessibility(ArrayList<View>)|Adds the childr
|android.view.View.addFocusables(ArrayList<View>,int)|Add any focusable views t
|android.view.View.addFocusables(ArrayList<View>,int,int)|Adds any focusable vi
|android.view.View.addOnAttachStateChangeListener(View.OnAttachStateChangeListener)|
|android.view.View.addOnLayoutChangeListener(View.OnLayoutChangeListener)|Add a
|android.view.View.addTouchables(ArrayList<View>)|Add any touchable views that 
|android.view.View.animate()|This method returns a ViewPropertyAnimator object,
|android.view.View.announceForAccessibility(CharSequence)|Convenience method fo
|android.view.View.applyDrawableToTransparentRegion(Drawable,Region)|Given a Dr
|android.view.View.awakenScrollBars()|Trigger the scrollbars to draw.
|android.view.View.awakenScrollBars(int)|Trigger the scrollbars to draw.
|android.view.View.awakenScrollBars(int,boolean)|Trigger the scrollbars to draw
|android.view.View.bringToFront()|Change the view's z order in the tree, so it'
|android.view.View.buildDrawingCache()|Calling this method is equivalent to cal
|android.view.View.buildDrawingCache(boolean)|Forces the drawing cache to be bu
|android.view.View.buildLayer()|Forces this view's layer to be created and this
|android.view.View.callOnClick()|Directly call any attached OnClickListener.
|android.view.View.cancelLongPress()|Cancels a pending long press.
|android.view.View.cancelPendingInputEvents()|Cancel any deferred high-level in
|android.view.View.canHaveDisplayList()|A view that is not attached or hardware
|android.view.View.canResolveLayoutDirection()|Check if layout direction resolu
|android.view.View.canResolveTextAlignment()|Check if text alignment resolution
|android.view.View.canResolveTextDirection()|Check if text direction resolution
|android.view.View.canScrollHorizontally(int)|Check if this view can be scrolle
|android.view.View.canScrollVertically(int)|Check if this view can be scrolled 
|android.view.View.checkInputConnectionProxy(View)|Called by theandroid.view.in
|android.view.View.clearAccessibilityFocus()|Call this to try to clear accessib
|android.view.View.clearAnimation()|Cancels any animations for this view.
|android.view.View.clearFocus()|Called when this view wants to give up focus.
|android.view.View.combineMeasuredStates(int,int)|Merge two states as returned 
|android.view.View.computeFitSystemWindows(Rect,Rect)|
|android.view.View.computeHorizontalScrollExtent()|Compute the horizontal exten
|android.view.View.computeHorizontalScrollOffset()|Compute the horizontal offse
|android.view.View.computeHorizontalScrollRange()|Compute the horizontal range 
|android.view.View.computeOpaqueFlags()|
|android.view.View.computeScroll()|Called by a parent to request that a child u
|android.view.View.computeVerticalScrollExtent()|Compute the vertical extent of
|android.view.View.computeVerticalScrollOffset()|Compute the vertical offset of
|android.view.View.computeVerticalScrollRange()|Compute the vertical range that
|android.view.View.createAccessibilityNodeInfo()|Returns anAccessibilityNodeInf
|android.view.View.createContextMenu(ContextMenu)|Show the context menu for thi
|android.view.View.debug()|Prints information about this view in the log output
|android.view.View.debug(int)|Prints information about this view in the log out
|android.view.View.debugIndent(int)|Creates a string of whitespaces used for in
|android.view.View.destroyDrawingCache()|Frees the resources used by the drawin
|android.view.View.destroyHardwareResources()|Destroys all hardware rendering r
|android.view.View.dispatchConfigurationChanged(Configuration)|Dispatch a notif
|android.view.View.dispatchDisplayHint(int)|Dispatch a hint about whether this 
|android.view.View.dispatchDragEvent(DragEvent)|Detects if this View is enabled
|android.view.View.dispatchDraw(Canvas)|Called by draw to draw the child views.
|android.view.View.dispatchFinishTemporaryDetach()|
|android.view.View.dispatchGenericFocusedEvent(MotionEvent)|Dispatch a generic 
|android.view.View.dispatchGenericMotionEvent(MotionEvent)|Dispatch a generic m
|android.view.View.dispatchGenericPointerEvent(MotionEvent)|Dispatch a generic 
|android.view.View.dispatchGetDisplayList()|This method is used by ViewGroup to
|android.view.View.dispatchHoverEvent(MotionEvent)|Dispatch a hover event.
|android.view.View.dispatchKeyEvent(KeyEvent)|Dispatch a key event to the next 
|android.view.View.dispatchKeyEventPreIme(KeyEvent)|Dispatch a key event before
|android.view.View.dispatchKeyShortcutEvent(KeyEvent)|Dispatches a key shortcut
|android.view.View.dispatchPointerEvent(MotionEvent)|Dispatch a pointer event.
|android.view.View.dispatchPopulateAccessibilityEvent(AccessibilityEvent)|Dispa
|android.view.View.dispatchRestoreInstanceState(SparseArray<Parcelable>)|Called
|android.view.View.dispatchSaveInstanceState(SparseArray<Parcelable>)|Called by
|android.view.View.dispatchSetActivated(boolean)|Dispatch setActivated to all o
|android.view.View.dispatchSetPressed(boolean)|Dispatch setPressed to all of th
|android.view.View.dispatchSetSelected(boolean)|Dispatch setSelected to all of 
|android.view.View.dispatchStartTemporaryDetach()|
|android.view.View.dispatchSystemUiVisibilityChanged(int)|Dispatch callbacks to
|android.view.View.dispatchTouchEvent(MotionEvent)|Pass the touch screen motion
|android.view.View.dispatchTrackballEvent(MotionEvent)|Pass a trackball motion 
|android.view.View.dispatchUnhandledMove(View,int)|This method is the last chan
|android.view.View.dispatchVisibilityChanged(View,int)|Dispatch a view visibili
|android.view.View.dispatchWindowFocusChanged(boolean)|Called when the window c
|android.view.View.dispatchWindowSystemUiVisiblityChanged(int)|Dispatch callbac
|android.view.View.dispatchWindowVisibilityChanged(int)|Dispatch a window visib
|android.view.View.draw(Canvas)|Manually render this view (and all of its child
|android.view.View.drawableStateChanged()|This function is called whenever the 
|android.view.View.executeHardwareAction(Runnable)|This method ensures the hard
|android.view.View.findFocus()|Find the view in the hierarchy rooted at this vi
|android.view.View.findViewByAccessibilityIdTraversal(int)|Performs the travers
|android.view.View.findViewById(int)|Look for a child view with the given id.
|android.view.View.findViewByPredicate(Predicate<View>)|Look for a child view t
|android.view.View.findViewByPredicateInsideOut(View,Predicate<View>)|Look for 
|android.view.View.findViewByPredicateTraversal(Predicate<View>,View)|
|android.view.View.findViewsWithText(ArrayList<View>,CharSequence,int)|Finds th
|android.view.View.findViewTraversal(int)|
|android.view.View.findViewWithTag(Object)|Look for a child view with the given
|android.view.View.findViewWithTagTraversal(Object)|
|android.view.View.fitsSystemWindows()|
|android.view.View.fitSystemWindows(Rect)|Called by the view hierarchy when the
|android.view.View.focusSearch(int)|Find the nearest view in the specified dire
|android.view.View.forceLayout()|Forces this view to be laid out during the nex
|android.view.View.gatherTransparentRegion(Region)|This is used by the RootView
|android.view.View.generateViewId()|Generate a value suitable for use in#setId(
|android.view.View.getAccessibilityDelegate()|Returns the delegate for implemen
|android.view.View.getAccessibilityLiveRegion()|Gets the live region mode for t
|android.view.View.getAccessibilityNodeProvider()|Gets the provider for managin
|android.view.View.getAccessibilitySelectionEnd()|
|android.view.View.getAccessibilitySelectionStart()|
|android.view.View.getAccessibilityViewId()|Gets the unique identifier of this 
|android.view.View.getAccessibilityWindowId()|Gets the unique identifier of the
|android.view.View.getAlpha()|The opacity of the view.
|android.view.View.getAnimation()|Get the animation currently associated with t
|android.view.View.getApplicationWindowToken()|Retrieve a unique token identify
|android.view.View.getBackground()|Gets the background drawable
|android.view.View.getBaseline()|Return the offset of the widget's text baselin
|android.view.View.getBottom()|Bottom position of this view relative to its par
|android.view.View.getBottomFadingEdgeStrength()|Returns the strength, or inten
|android.view.View.getBottomPaddingOffset()|Amount by which to extend the botto
|android.view.View.getCameraDistance()|Gets the distance along the Z axis from 
|android.view.View.getClipBounds()|Returns a copy of the current#setClipBounds(
|android.view.View.getContentDescription()|Gets theViewdescription.
|android.view.View.getContext()|Returns the context the view is running in, thr
|android.view.View.getContextMenuInfo()|Views should implement this if they hav
|android.view.View.getDefaultSize(int,int)|Utility to return a default size.
|android.view.View.getDisplay()|Gets the logical display to which the view's wi
|android.view.View.getDisplayList()|Returns a display list that can be used to 
|android.view.View.getDrawableState()|Return an array of resource IDs of the dr
|android.view.View.getDrawingCache()|Calling this method is equivalent to calli
|android.view.View.getDrawingCache(boolean)|Returns the bitmap in which this vi
|android.view.View.getDrawingCacheBackgroundColor()|
|android.view.View.getDrawingCacheQuality()|Returns the quality of the drawing 
|android.view.View.getDrawingRect(Rect)|Return the visible drawing bounds of yo
|android.view.View.getDrawingTime()|Return the time at which the drawing of the
|android.view.View.getFadeHeight(boolean)|
|android.view.View.getFadeTop(boolean)|
|android.view.View.getFilterTouchesWhenObscured()|Gets whether the framework sh
|android.view.View.getFitsSystemWindows()|Check for state of#setFitsSystemWindo
|android.view.View.getFocusables(int)|Find and return all focusable views that 
|android.view.View.getFocusedRect(Rect)|When a view has focus and the user navi
|android.view.View.getGlobalVisibleRect(Rect)|
|android.view.View.getGlobalVisibleRect(Rect,Point)|If some part of this view i
|android.view.View.getHandler()|
|android.view.View.getHardwareRenderer()|
|android.view.View.getHeight()|Return the height of your view.
|android.view.View.getHitRect(Rect)|Hit rectangle in parent's coordinates
|android.view.View.getHorizontalFadingEdgeLength()|Returns the size of the hori
|android.view.View.getHorizontalScrollbarHeight()|Returns the height of the hor
|android.view.View.getHorizontalScrollFactor()|Gets a scale factor that determi
|android.view.View.getId()|Returns this view's identifier.
|android.view.View.getImportantForAccessibility()|Gets the mode for determining
|android.view.View.getIterableTextForAccessibility()|Gets the text reported for
|android.view.View.getIteratorForGranularity(int)|
|android.view.View.getKeepScreenOn()|Returns whether the screen should remain o
|android.view.View.getKeyDispatcherState()|Return the globalKeyEvent.Dispatcher
|android.view.View.getLabelFor()|Gets the id of a view for which this view serv
|android.view.View.getLayerType()|Indicates what type of layer is currently ass
|android.view.View.getLayoutDirection()|Returns the resolved layout direction f
|android.view.View.getLayoutParams()|Get the LayoutParams associated with this 
|android.view.View.getLeft()|Left position of this view relative to its parent.
|android.view.View.getLeftFadingEdgeStrength()|Returns the strength, or intensi
|android.view.View.getLeftPaddingOffset()|Amount by which to extend the left fa
|android.view.View.getLocalVisibleRect(Rect)|
|android.view.View.getLocationInWindow(int[])|Computes the coordinates of this 
|android.view.View.getLocationOnScreen(int[])|Computes the coordinates of this 
|android.view.View.getMatrix()|The transform matrix of this view, which is calc
|android.view.View.getMeasuredHeight()|Like#getMeasuredHeightAndState(), but on
|android.view.View.getMeasuredHeightAndState()|Return the full height measureme
|android.view.View.getMeasuredState()|Return only the state bits of#getMeasured
|android.view.View.getMeasuredWidth()|Like#getMeasuredWidthAndState(), but only
|android.view.View.getMeasuredWidthAndState()|Return the full width measurement
|android.view.View.getMinimumHeight()|Returns the minimum height of the view.
|android.view.View.getMinimumWidth()|Returns the minimum width of the view.
|android.view.View.getNextFocusDownId()|Gets the id of the view to use when the
|android.view.View.getNextFocusForwardId()|Gets the id of the view to use when 
|android.view.View.getNextFocusLeftId()|Gets the id of the view to use when the
|android.view.View.getNextFocusRightId()|Gets the id of the view to use when th
|android.view.View.getNextFocusUpId()|Gets the id of the view to use when the n
|android.view.View.getOnFocusChangeListener()|Returns the focus-change callback
|android.view.View.getOpticalInsets()|
|android.view.View.getOverlay()|Returns the overlay for this view, creating it 
|android.view.View.getOverScrollMode()|Returns the over-scroll mode for this vi
|android.view.View.getPaddingBottom()|Returns the bottom padding of this view.
|android.view.View.getPaddingEnd()|Returns the end padding of this view dependi
|android.view.View.getPaddingLeft()|Returns the left padding of this view.
|android.view.View.getPaddingRight()|Returns the right padding of this view.
|android.view.View.getPaddingStart()|Returns the start padding of this view dep
|android.view.View.getPaddingTop()|Returns the top padding of this view.
|android.view.View.getParent()|Gets the parent of this view.
|android.view.View.getParentForAccessibility()|Gets the parent for accessibilit
|android.view.View.getPivotX()|The x location of the point around which the vie
|android.view.View.getPivotY()|The y location of the point around which the vie
|android.view.View.getRawLayoutDirection()|Returns the layout direction for thi
|android.view.View.getRawTextAlignment()|Return the value specifying the text a
|android.view.View.getRawTextDirection()|Return the value specifying the text d
|android.view.View.getResources()|Returns the resources associated with this vi
|android.view.View.getRight()|Right position of this view relative to its paren
|android.view.View.getRightFadingEdgeStrength()|Returns the strength, or intens
|android.view.View.getRightPaddingOffset()|Amount by which to extend the right 
|android.view.View.getRootView()|Finds the topmost view in the current view hie
|android.view.View.getRotation()|The degrees that the view is rotated around th
|android.view.View.getRotationX()|The degrees that the view is rotated around t
|android.view.View.getRotationY()|The degrees that the view is rotated around t
|android.view.View.getScaleX()|The amount that the view is scaled in x around t
|android.view.View.getScaleY()|The amount that the view is scaled in y around t
|android.view.View.getScrollBarDefaultDelayBeforeFade()|Returns the delay befor
|android.view.View.getScrollBarFadeDuration()|Returns the scrollbar fade durati
|android.view.View.getScrollBarSize()|Returns the scrollbar size.
|android.view.View.getScrollBarStyle()|Returns the current scrollbar style.
|android.view.View.getScrollX()|Return the scrolled left position of this view.
|android.view.View.getScrollY()|Return the scrolled top position of this view.
|android.view.View.getSolidColor()|Override this if your view is known to alway
|android.view.View.getSuggestedMinimumHeight()|Returns the suggested minimum he
|android.view.View.getSuggestedMinimumWidth()|Returns the suggested minimum wid
|android.view.View.getSystemUiVisibility()|Returns the last#setSystemUiVisibili
|android.view.View.getTag()|Returns this view's tag.
|android.view.View.getTag(int)|Returns the tag associated with this view and th
|android.view.View.getTextAlignment()|Return the resolved text alignment.
|android.view.View.getTextDirection()|Return the resolved text direction.
|android.view.View.getTop()|Top position of this view relative to its parent.
|android.view.View.getTopFadingEdgeStrength()|Returns the strength, or intensit
|android.view.View.getTopPaddingOffset()|Amount by which to extend the top fadi
|android.view.View.getTouchables()|Find and return all touchable views that are
|android.view.View.getTouchDelegate()|Gets the TouchDelegate for this View.
|android.view.View.getTransitionAlpha()|This property is hidden and intended on
|android.view.View.getTranslationX()|The horizontal location of this view relat
|android.view.View.getTranslationY()|The horizontal location of this view relat
|android.view.View.getVerticalFadingEdgeLength()|Returns the size of the vertic
|android.view.View.getVerticalScrollbarPosition()|
|android.view.View.getVerticalScrollbarWidth()|Returns the width of the vertica
|android.view.View.getVerticalScrollFactor()|Gets a scale factor that determine
|android.view.View.getViewRootImpl()|Gets the view root associated with the Vie
|android.view.View.getViewTreeObserver()|Returns the ViewTreeObserver for this 
|android.view.View.getVisibility()|Returns the visibility status for this view.
|android.view.View.getWidth()|Return the width of the your view.
|android.view.View.getWindowAttachCount()|
|android.view.View.getWindowId()|Retrieve theWindowIdfor the window this view i
|android.view.View.getWindowSystemUiVisibility()|Returns the current system UI 
|android.view.View.getWindowToken()|Retrieve a unique token identifying the win
|android.view.View.getWindowVisibility()|Returns the current visibility of the 
|android.view.View.getWindowVisibleDisplayFrame(Rect)|Retrieve the overall visi
|android.view.View.getX()|The visual x position of this view, in pixels.
|android.view.View.getY()|The visual y position of this view, in pixels.
|android.view.View.hackTurnOffWindowResizeAnim(boolean)|
|android.view.View.hasFocus()|Returns true if this view has focus iteself, or i
|android.view.View.hasFocusable()|Returns true if this view is focusable or if 
|android.view.View.hasHoveredChild()|Returns true if the view has a child to wh
|android.view.View.hasOnClickListeners()|Return whether this view has an attach
|android.view.View.hasOpaqueScrollbars()|
|android.view.View.hasOverlappingRendering()|Returns whether this View has cont
|android.view.View.hasTransientState()|Indicates whether the view is currently 
|android.view.View.hasWindowFocus()|Returns true if this view is in a window th
|android.view.View.includeForAccessibility()|Whether to regard this view for ac
|android.view.View.inflate(Context,int,ViewGroup)|Inflate a view from an XML re
|android.view.View.initializeFadingEdge(TypedArray)|Initializes the fading edge
|android.view.View.initializeScrollbars(TypedArray)|Initializes the scrollbars 
|android.view.View.internalSetPadding(int,int,int,int)|
|android.view.View.invalidate()|Invalidate the whole view.
|android.view.View.invalidate(int,int,int,int)|Mark the area defined by the rec
|android.view.View.invalidate(Rect)|Mark the area defined by dirty as needing t
|android.view.View.invalidateDrawable(Drawable)|Invalidates the specified Drawa
|android.view.View.invalidateParentCaches()|Used to indicate that the parent of
|android.view.View.invalidateParentIfNeeded()|Used to indicate that the parent 
|android.view.View.isAccessibilityFocused()|Returns whether this View is access
|android.view.View.isAccessibilitySelectionExtendable()|Gets whether accessibil
|android.view.View.isActionableForAccessibility()|Returns whether the View is c
|android.view.View.isActivated()|Indicates the activation state of this view.
|android.view.View.isAttachedToWindow()|Returns true if this view is currently 
|android.view.View.isClickable()|Indicates whether this view reacts to click ev
|android.view.View.isDirty()|True if this view has changed since the last time 
|android.view.View.isDrawingCacheEnabled()|Indicates whether the drawing cache 
|android.view.View.isDuplicateParentStateEnabled()|Indicates whether this dupli
|android.view.View.isEnabled()|Returns the enabled status for this view.
|android.view.View.isFocusable()|Returns whether this View is able to take focu
|android.view.View.isFocusableInTouchMode()|When a view is focusable, it may no
|android.view.View.isFocused()|Returns true if this view has focus
|android.view.View.isHapticFeedbackEnabled()|
|android.view.View.isHardwareAccelerated()|Indicates whether this view is attac
|android.view.View.isHorizontalFadingEdgeEnabled()|Indicate whether the horizon
|android.view.View.isHorizontalScrollBarEnabled()|Indicate whether the horizont
|android.view.View.isHovered()|Returns true if the view is currently hovered.
|android.view.View.isImportantForAccessibility()|Gets whether this view should 
|android.view.View.isInEditMode()|Indicates whether this View is currently in e
|android.view.View.isInLayout()|Returns whether the view hierarchy is currently
|android.view.View.isInScrollingContainer()|
|android.view.View.isInTouchMode()|Returns whether the device is currently in t
|android.view.View.isLaidOut()|Returns true if this view has been through at le
|android.view.View.isLayoutDirectionInherited()|
|android.view.View.isLayoutDirectionResolved()|
|android.view.View.isLayoutModeOptical(Object)|Return true if o is a ViewGroup 
|android.view.View.isLayoutRequested()|Indicates whether or not this view's lay
|android.view.View.isLayoutRtl()|Indicates whether or not this view's layout is
|android.view.View.isLongClickable()|Indicates whether this view reacts to long
|android.view.View.isOpaque()|Indicates whether this View is opaque.
|android.view.View.isPaddingOffsetRequired()|If the View draws content inside i
|android.view.View.isPaddingRelative()|Return if the padding as been set thru r
|android.view.View.isPressed()|Indicates whether the view is currently in press
|android.view.View.isRootNamespace()|
|android.view.View.isSaveEnabled()|Indicates whether this view will save its st
|android.view.View.isSaveFromParentEnabled()|Indicates whether the entire hiera
|android.view.View.isScrollbarFadingEnabled()|Returns true if scrollbars will f
|android.view.View.isScrollContainer()|Indicates whether this view is one of th
|android.view.View.isSelected()|Indicates the selection state of this view.
|android.view.View.isShown()|Returns the visibility of this view and all of its
|android.view.View.isSoundEffectsEnabled()|
|android.view.View.isTextAlignmentInherited()|
|android.view.View.isTextAlignmentResolved()|
|android.view.View.isTextDirectionInherited()|
|android.view.View.isTextDirectionResolved()|
|android.view.View.isVerticalFadingEdgeEnabled()|Indicate whether the vertical 
|android.view.View.isVerticalScrollBarEnabled()|Indicate whether the vertical s
|android.view.View.isVerticalScrollBarHidden()|Override this if the vertical sc
|android.view.View.isVisibleToUser()|Computes whether this view is visible to t
|android.view.View.isVisibleToUser(Rect)|Computes whether the given portion of 
|android.view.View.jumpDrawablesToCurrentState()|CallDrawable#jumpToCurrentStat
|android.view.View.layout(int,int,int,int)|Assign a size and position to a view
|android.view.View.makeOptionalFitsSystemWindows()|For use by PhoneWindow to ma
|android.view.View.measure(int,int)|This is called to find out how big a view s
|android.view.View.mergeDrawableStates(int[],int[])|Merge your own state values
|android.view.View.notifySubtreeAccessibilityStateChangedIfNeeded()|Notifies th
|android.view.View.notifyViewAccessibilityStateChangedIfNeeded(int)|Notifies th
|android.view.View.offsetLeftAndRight(int)|Offset this view's horizontal locati
|android.view.View.offsetTopAndBottom(int)|Offset this view's vertical location
|android.view.View.onAnimationEnd()|Invoked by a parent ViewGroup to notify the
|android.view.View.onAnimationStart()|Invoked by a parent ViewGroup to notify t
|android.view.View.onAttachedToWindow()|This is called when the view is attache
|android.view.View.onCancelPendingInputEvents()|Called as the result of a call 
|android.view.View.onCheckIsTextEditor()|Check whether the called view is a tex
|android.view.View.onCloseSystemDialogs(String)|This needs to be a better API (
|android.view.View.onConfigurationChanged(Configuration)|Called when the curren
|android.view.View.onCreateContextMenu(ContextMenu)|Views should implement this
|android.view.View.onCreateDrawableState(int)|Generate the newandroid.graphics.
|android.view.View.onCreateInputConnection(EditorInfo)|Create a new InputConnec
|android.view.View.onDetachedFromWindow()|This is called when the view is detac
|android.view.View.onDisplayHint(int)|Gives this view a hint about whether is d
|android.view.View.onDragEvent(DragEvent)|Handles drag events sent by the syste
|android.view.View.onDraw(Canvas)|Implement this to do your drawing.
|android.view.View.onDrawHorizontalScrollBar(Canvas,Drawable,int,int,int,int)|D
|android.view.View.onDrawScrollBars(Canvas)|Request the drawing of the horizont
|android.view.View.onDrawVerticalScrollBar(Canvas,Drawable,int,int,int,int)|Dra
|android.view.View.onFilterTouchEventForSecurity(MotionEvent)|Filter the touch 
|android.view.View.onFinishInflate()|Finalize inflating a view from XML.
|android.view.View.onFinishTemporaryDetach()|Called after#onStartTemporaryDetac
|android.view.View.onFocusChanged(boolean,int,Rect)|Called by the view system w
|android.view.View.onFocusLost()|Invoked whenever this view loses focus, either
|android.view.View.onGenericMotionEvent(MotionEvent)|Implement this method to h
|android.view.View.onHoverChanged(boolean)|Implement this method to handle hove
|android.view.View.onHoverEvent(MotionEvent)|Implement this method to handle ho
|android.view.View.onInitializeAccessibilityEvent(AccessibilityEvent)|Initializ
|android.view.View.onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)|Ini
|android.view.View.onKeyDown(int,KeyEvent)|Default implementation ofKeyEvent.Ca
|android.view.View.onKeyLongPress(int,KeyEvent)|Default implementation ofKeyEve
|android.view.View.onKeyMultiple(int,int,KeyEvent)|Default implementation ofKey
|android.view.View.onKeyPreIme(int,KeyEvent)|Handle a key event before it is pr
|android.view.View.onKeyShortcut(int,KeyEvent)|Called on the focused view when 
|android.view.View.onKeyUp(int,KeyEvent)|Default implementation ofKeyEvent.Call
|android.view.View.onLayout(boolean,int,int,int,int)|Called from layout when th
|android.view.View.onMeasure(int,int)|Measure the view and its content to deter
|android.view.View.onOverScrolled(int,int,boolean,boolean)|Called by#overScroll
|android.view.View.onPopulateAccessibilityEvent(AccessibilityEvent)|Called from
|android.view.View.onResolveDrawables(int)|Called when layout direction has bee
|android.view.View.onRestoreInstanceState(Parcelable)|Hook allowing a view to r
|android.view.View.onRtlPropertiesChanged(int)|Called when any RTL property (la
|android.view.View.onSaveInstanceState()|Hook allowing a view to generate a rep
|android.view.View.onScreenStateChanged(int)|This method is called whenever the
|android.view.View.onScrollChanged(int,int,int,int)|This is called in response 
|android.view.View.onSetAlpha(int)|Invoked if there is a Transform that involve
|android.view.View.onSizeChanged(int,int,int,int)|This is called during layout 
|android.view.View.onStartTemporaryDetach()|This is called when a container is 
|android.view.View.onTouchEvent(MotionEvent)|Implement this method to handle to
|android.view.View.onTrackballEvent(MotionEvent)|Implement this method to handl
|android.view.View.onVisibilityChanged(View,int)|Called when the visibility of 
|android.view.View.onWindowFocusChanged(boolean)|Called when the window contain
|android.view.View.onWindowSystemUiVisibilityChanged(int)|Override to find out 
|android.view.View.onWindowVisibilityChanged(int)|Called when the window contai
|android.view.View.outputDirtyFlags(String,boolean,int)|Debugging utility which
|android.view.View.overScrollBy(int,int,int,int,int,int,int,int,boolean)|Scroll
|android.view.View.performAccessibilityAction(int,Bundle)|Performs the specifie
|android.view.View.performButtonActionOnTouchDown(MotionEvent)|Performs button-
|android.view.View.performClick()|Call this view's OnClickListener, if it is de
|android.view.View.performHapticFeedback(int)|BZZZTT!!1!
|android.view.View.performHapticFeedback(int,int)|BZZZTT!!1!
|android.view.View.performLongClick()|Call this view's OnLongClickListener, if 
|android.view.View.playSoundEffect(int)|Play a sound effect for this view.
|android.view.View.pointInView(float,float,float)|Utility method to determine w
|android.view.View.post(Runnable)|Causes the Runnable to be added to the messag
|android.view.View.postDelayed(Runnable,long)|Causes the Runnable to be added t
|android.view.View.postInvalidate()|Cause an invalidate to happen on a subseque
|android.view.View.postInvalidate(int,int,int,int)|Cause an invalidate of the s
|android.view.View.postInvalidateDelayed(long)|Cause an invalidate to happen on
|android.view.View.postInvalidateDelayed(long,int,int,int,int)|Cause an invalid
|android.view.View.postInvalidateOnAnimation()|Cause an invalidate to happen on
|android.view.View.postInvalidateOnAnimation(int,int,int,int)|Cause an invalida
|android.view.View.postOnAnimation(Runnable)|Causes the Runnable to execute on 
|android.view.View.postOnAnimationDelayed(Runnable,long)|Causes the Runnable to
|android.view.View.recomputePadding()|
|android.view.View.refreshDrawableState()|Call this to force a view to update i
|android.view.View.removeCallbacks(Runnable)|Removes the specified Runnable fro
|android.view.View.removeOnAttachStateChangeListener(View.OnAttachStateChangeListener)|
|android.view.View.removeOnLayoutChangeListener(View.OnLayoutChangeListener)|Re
|android.view.View.requestAccessibilityFocus()|Call this to try to give accessi
|android.view.View.requestFitSystemWindows()|Ask that a new dispatch of#fitSyst
|android.view.View.requestFocus()|Call this to try to give focus to a specific 
|android.view.View.requestFocus(int)|Call this to try to give focus to a specif
|android.view.View.requestFocus(int,Rect)|Call this to try to give focus to a s
|android.view.View.requestFocusFromTouch()|Call this to try to give focus to a 
|android.view.View.requestLayout()|Call this when something has changed which h
|android.view.View.requestRectangleOnScreen(Rect)|Request that a rectangle of t
|android.view.View.requestRectangleOnScreen(Rect,boolean)|Request that a rectan
|android.view.View.resetPaddingToInitialValues()|
|android.view.View.resetResolvedDrawables()|
|android.view.View.resetResolvedLayoutDirection()|Reset the resolved layout dir
|android.view.View.resetResolvedPadding()|Reset the resolved layout direction.
|android.view.View.resetResolvedTextAlignment()|Reset resolved text alignment.
|android.view.View.resetResolvedTextDirection()|Reset resolved text direction.
|android.view.View.resetRtlProperties()|Reset resolution of all RTL related pro
|android.view.View.resolveDrawables()|Resolve the Drawables depending on the la
|android.view.View.resolveLayoutDirection()|Resolve and cache the layout direct
|android.view.View.resolveLayoutParams()|Resolve the layout parameters dependin
|android.view.View.resolvePadding()|Resolves padding depending on layout direct
|android.view.View.resolveRtlPropertiesIfNeeded()|Resolve all RTL related prope
|android.view.View.resolveSize(int,int)|Version of#resolveSizeAndState(int, int
|android.view.View.resolveSizeAndState(int,int,int)|Utility to reconcile a desi
|android.view.View.resolveTextAlignment()|Resolve the text alignment.
|android.view.View.resolveTextDirection()|Resolve the text direction.
|android.view.View.restoreHierarchyState(SparseArray<Parcelable>)|Restore this 
|android.view.View.saveHierarchyState(SparseArray<Parcelable>)|Store this view 
|android.view.View.scheduleDrawable(Drawable,Runnable,long)|Schedules an action
|android.view.View.scrollBy(int,int)|Move the scrolled position of your view.
|android.view.View.scrollTo(int,int)|Set the scrolled position of your view.
|android.view.View.sendAccessibilityEvent(int)|Sends an accessibility event of 
|android.view.View.sendAccessibilityEventUnchecked(AccessibilityEvent)|This met
|android.view.View.setAccessibilityDelegate(View.AccessibilityDelegate)|Sets a 
|android.view.View.setAccessibilityLiveRegion(int)|Sets the live region mode fo
|android.view.View.setAccessibilitySelection(int,int)|
|android.view.View.setActivated(boolean)|Changes the activated state of this vi
|android.view.View.setAlpha(float)|Sets the opacity of the view.
|android.view.View.setAnimation(Animation)|Sets the next animation to play for 
|android.view.View.setBackground(Drawable)|Set the background to a given Drawab
|android.view.View.setBackgroundColor(int)|Sets the background color for this v
|android.view.View.setBackgroundDrawable(Drawable)|
|android.view.View.setBackgroundResource(int)|Set the background to a given res
|android.view.View.setBottom(int)|Sets the bottom position of this view relativ
|android.view.View.setCameraDistance(float)|Sets the distance along the Z axis 
|android.view.View.setClickable(boolean)|Enables or disables click events for t
|android.view.View.setClipBounds(Rect)|Sets a rectangular area on this view to 
|android.view.View.setContentDescription(CharSequence)|Sets theViewdescription.
|android.view.View.setDisabledSystemUiVisibility(int)|
|android.view.View.setDrawingCacheBackgroundColor(int)|Setting a solid backgrou
|android.view.View.setDrawingCacheEnabled(boolean)|Enables or disables the draw
|android.view.View.setDrawingCacheQuality(int)|Set the drawing cache quality of
|android.view.View.setDuplicateParentStateEnabled(boolean)|Enables or disables 
|android.view.View.setEnabled(boolean)|Set the enabled state of this view.
|android.view.View.setFadingEdgeLength(int)|Set the size of the faded edge used
|android.view.View.setFilterTouchesWhenObscured(boolean)|Sets whether the frame
|android.view.View.setFitsSystemWindows(boolean)|Sets whether or not this view 
|android.view.View.setFocusable(boolean)|Set whether this view can receive the 
|android.view.View.setFocusableInTouchMode(boolean)|Set whether this view can r
|android.view.View.setFrame(int,int,int,int)|Assign a size and position to this
|android.view.View.setHapticFeedbackEnabled(boolean)|Set whether this view shou
|android.view.View.setHasTransientState(boolean)|Set whether this view is curre
|android.view.View.setHorizontalFadingEdgeEnabled(boolean)|Define whether the h
|android.view.View.setHorizontalScrollBarEnabled(boolean)|Define whether the ho
|android.view.View.setHovered(boolean)|Sets whether the view is currently hover
|android.view.View.setId(int)|Sets the identifier for this view.
|android.view.View.setImportantForAccessibility(int)|Sets how to determine whet
|android.view.View.setIsRootNamespace(boolean)|
|android.view.View.setKeepScreenOn(boolean)|Controls whether the screen should 
|android.view.View.setLabelFor(int)|Sets the id of a view for which this view s
|android.view.View.setLayerPaint(Paint)|Updates thePaintobject used with the cu
|android.view.View.setLayerType(int,Paint)|Specifies the type of layer backing 
|android.view.View.setLayoutDirection(int)|Set the layout direction for this vi
|android.view.View.setLayoutParams(ViewGroup.LayoutParams)|Set the layout param
|android.view.View.setLeft(int)|Sets the left position of this view relative to
|android.view.View.setLongClickable(boolean)|Enables or disables long click eve
|android.view.View.setMeasuredDimension(int,int)|This method must be called by#
|android.view.View.setMinimumHeight(int)|Sets the minimum height of the view.
|android.view.View.setMinimumWidth(int)|Sets the minimum width of the view.
|android.view.View.setNextFocusDownId(int)|Sets the id of the view to use when 
|android.view.View.setNextFocusForwardId(int)|Sets the id of the view to use wh
|android.view.View.setNextFocusLeftId(int)|Sets the id of the view to use when 
|android.view.View.setNextFocusRightId(int)|Sets the id of the view to use when
|android.view.View.setNextFocusUpId(int)|Sets the id of the view to use when th
|android.view.View.setOnClickListener(View.OnClickListener)|Register a callback
|android.view.View.setOnCreateContextMenuListener(View.OnCreateContextMenuListener)|
|android.view.View.setOnDragListener(View.OnDragListener)|Register a drag event
|android.view.View.setOnFocusChangeListener(View.OnFocusChangeListener)|Registe
|android.view.View.setOnGenericMotionListener(View.OnGenericMotionListener)|Reg
|android.view.View.setOnHoverListener(View.OnHoverListener)|Register a callback
|android.view.View.setOnKeyListener(View.OnKeyListener)|Register a callback to 
|android.view.View.setOnLongClickListener(View.OnLongClickListener)|Register a 
|android.view.View.setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener)|
|android.view.View.setOnTouchListener(View.OnTouchListener)|Register a callback
|android.view.View.setOverScrollMode(int)|Set the over-scroll mode for this vie
|android.view.View.setPadding(int,int,int,int)|Sets the padding.
|android.view.View.setPaddingRelative(int,int,int,int)|Sets the relative paddin
|android.view.View.setPivotX(float)|Sets the x location of the point around whi
|android.view.View.setPivotY(float)|Sets the y location of the point around whi
|android.view.View.setPressed(boolean)|Sets the pressed state for this view.
|android.view.View.setRight(int)|Sets the right position of this view relative 
|android.view.View.setRotation(float)|Sets the degrees that the view is rotated
|android.view.View.setRotationX(float)|Sets the degrees that the view is rotate
|android.view.View.setRotationY(float)|Sets the degrees that the view is rotate
|android.view.View.setSaveEnabled(boolean)|Controls whether the saving of this 
|android.view.View.setSaveFromParentEnabled(boolean)|Controls whether the entir
|android.view.View.setScaleX(float)|Sets the amount that the view is scaled in 
|android.view.View.setScaleY(float)|Sets the amount that the view is scaled in 
|android.view.View.setScrollBarDefaultDelayBeforeFade(int)|Define the delay bef
|android.view.View.setScrollBarFadeDuration(int)|Define the scrollbar fade dura
|android.view.View.setScrollbarFadingEnabled(boolean)|Define whether scrollbars
|android.view.View.setScrollBarSize(int)|Define the scrollbar size.
|android.view.View.setScrollBarStyle(int)|Specify the style of the scrollbars.
|android.view.View.setScrollContainer(boolean)|Change whether this view is one 
|android.view.View.setScrollX(int)|Set the horizontal scrolled position of your
|android.view.View.setScrollY(int)|Set the vertical scrolled position of your v
|android.view.View.setSelected(boolean)|Changes the selection state of this vie
|android.view.View.setSoundEffectsEnabled(boolean)|Set whether this view should
|android.view.View.setSystemUiVisibility(int)|Request that the visibility of th
|android.view.View.setTag(int,Object)|Sets a tag associated with this view and 
|android.view.View.setTag(Object)|Sets the tag associated with this view.
|android.view.View.setTagInternal(int,Object)|Variation of#setTag(int, Object)t
|android.view.View.setTextAlignment(int)|Set the text alignment.
|android.view.View.setTextDirection(int)|Set the text direction.
|android.view.View.setTop(int)|Sets the top position of this view relative to i
|android.view.View.setTouchDelegate(TouchDelegate)|Sets the TouchDelegate for t
|android.view.View.setTransitionAlpha(float)|This property is hidden and intend
|android.view.View.setTranslationX(float)|Sets the horizontal location of this 
|android.view.View.setTranslationY(float)|Sets the vertical location of this vi
|android.view.View.setVerticalFadingEdgeEnabled(boolean)|Define whether the ver
|android.view.View.setVerticalScrollBarEnabled(boolean)|Define whether the vert
|android.view.View.setVerticalScrollbarPosition(int)|Set the position of the ve
|android.view.View.setVisibility(int)|Set the enabled state of this view.
|android.view.View.setWillNotCacheDrawing(boolean)|When a View's drawing cache 
|android.view.View.setWillNotDraw(boolean)|If this view doesn't do any drawing 
|android.view.View.setX(float)|Sets the visual x position of this view, in pixe
|android.view.View.setY(float)|Sets the visual y position of this view, in pixe
|android.view.View.showContextMenu()|Bring up the context menu for this view.
|android.view.View.showContextMenu(float,float,int)|Bring up the context menu f
|android.view.View.startActionMode(ActionMode.Callback)|Start an action mode.
|android.view.View.startAnimation(Animation)|Start the specified animation now.
|android.view.View.startDrag(ClipData,View.DragShadowBuilder,Object,int)|Starts
|android.view.View.toGlobalMotionEvent(MotionEvent)|Transforms a motion event f
|android.view.View.toLocalMotionEvent(MotionEvent)|Transforms a motion event fr
|android.view.View.toString()|
|android.view.View.unscheduleDrawable(Drawable)|Unschedule any events associate
|android.view.View.unscheduleDrawable(Drawable,Runnable)|Cancels a scheduled ac
|android.view.View.verifyDrawable(Drawable)|If your view subclass is displaying
|android.view.View.willNotCacheDrawing()|Returns whether or not this View can c
|android.view.View.willNotDraw()|Returns whether or not this View draws on its 

*android.view.View_Description*

This class represents the basic building block for user interface components. A 
View occupies a rectangular area on the screen and is responsible for drawing 
and event handling. View is the base class for widgets, which are used to 
create interactive UI components (buttons, text fields, etc.). The 
(|android.view.ViewGroup|) subclass is the base class for layouts, which are 
invisible containers that hold other Views (or other ViewGroups) and define 
their layout properties. 

Developer Guides For information about using this class to develop your 
application's user interface, read the <a 
href="guide/topics/ui/index.html">User Interface developer guide. 

Using Views 

All of the views in a window are arranged in a single tree. You can add views 
either from code or by specifying a tree of views in one or more XML layout 
files. There are many specialized subclasses of views that act as controls or 
are capable of displaying text, images, or other content. 

Once you have created a tree of views, there are typically a few types of 
common operations you may wish to perform: 

Set properties: for example setting the text of a (|android.widget.TextView|) . 
The available properties and the methods that set them will vary among the 
different subclasses of views. Note that properties that are known at build 
time can be set in the XML layout files. Set focus: The framework will handled 
moving focus in response to user input. To force focus to a specific view, call 
(|android.view.View|) . Set up listeners: Views allow clients to set listeners 
that will be notified when something interesting happens to the view. For 
example, all views will let you set a listener to be notified when the view 
gains or loses focus. You can register such a listener using 
(|android.view.View|) . Other view subclasses offer more specialized listeners. 
For example, a Button exposes a listener to notify clients when the button is 
clicked. Set visibility: You can hide or show views using (|android.view.View|) 
. 



Note: The Android framework is responsible for measuring, laying out and 
drawing views. You should not call methods that perform these actions on views 
yourself unless you are actually implementing a (|android.view.ViewGroup|) . 

Implementing a Custom View 

To implement a custom view, you will usually begin by providing overrides for 
some of the standard methods that the framework calls on all views. You do not 
need to override all of these methods. In fact, you can start by just 
overriding (|android.view.View|) . 

Category Methods Description 



Creation Constructors There is a form of the constructor that are called when 
the view is created from code and a form that is called when the view is 
inflated from a layout file. The second form should parse and apply any 
attributes defined in the layout file. 



(|android.view.View|) Called after a view and all of its children has been 
inflated from XML. 

Layout (|android.view.View|) Called to determine the size requirements for this 
view and all of its children. 



(|android.view.View|) Called when this view should assign a size and position 
to all of its children. 



(|android.view.View|) Called when the size of this view has changed. 



Drawing (|android.view.View|) Called when the view should render its content. 



Event processing (|android.view.View|) Called when a new hardware key event 
occurs. 



(|android.view.View|) Called when a hardware key up event occurs. 



(|android.view.View|) Called when a trackball motion event occurs. 



(|android.view.View|) Called when a touch screen motion event occurs. 



Focus (|android.view.View|) Called when the view gains or loses focus. 



(|android.view.View|) Called when the window containing the view gains or loses 
focus. 



Attaching (|android.view.View|) Called when the view is attached to a window. 



(|android.view.View|) Called when the view is detached from its window. 



(|android.view.View|) Called when the visibility of the window containing the 
view has changed. 





IDs Views may have an integer id associated with them. These ids are typically 
assigned in the layout XML files, and are used to find specific views within 
the view tree. A common pattern is to: 

Define a Button in the layout file and assign it a unique ID. 

<Button android:id="@+id/my_button" android:layout_width="wrap_content" 
android:layout_height="wrap_content" android:text="@string/my_button_text"/> 

From the onCreate method of an Activity, find the Button 

Button myButton = (Button) findViewById(R.id.my_button); 



View IDs need not be unique throughout the tree, but it is good practice to 
ensure that they are at least unique within the part of the tree you are 
searching. 

Position 

The geometry of a view is that of a rectangle. A view has a location, expressed 
as a pair of left and top coordinates, and two dimensions, expressed as a width 
and a height. The unit for location and dimensions is the pixel. 

It is possible to retrieve the location of a view by invoking the methods 
(|android.view.View|) and (|android.view.View|) . The former returns the left, 
or X, coordinate of the rectangle representing the view. The latter returns the 
top, or Y, coordinate of the rectangle representing the view. These methods 
both return the location of the view relative to its parent. For instance, when 
getLeft() returns 20, that means the view is located 20 pixels to the right of 
the left edge of its direct parent. 

In addition, several convenience methods are offered to avoid unnecessary 
computations, namely (|android.view.View|) and (|android.view.View|) . These 
methods return the coordinates of the right and bottom edges of the rectangle 
representing the view. For instance, calling (|android.view.View|) is similar 
to the following computation: getLeft() + getWidth() (see Size for more 
information about the width.) 

Size, padding and margins 

The size of a view is expressed with a width and a height. A view actually 
possess two pairs of width and height values. 

The first pair is known as measured width and measured height. These dimensions 
define how big a view wants to be within its parent (see Layout for more 
details.) The measured dimensions can be obtained by calling 
(|android.view.View|) and (|android.view.View|) . 

The second pair is simply known as width and height, or sometimes drawing width 
and drawing height. These dimensions define the actual size of the view on 
screen, at drawing time and after layout. These values may, but do not have to, 
be different from the measured width and height. The width and height can be 
obtained by calling (|android.view.View|) and (|android.view.View|) . 

To measure its dimensions, a view takes into account its padding. The padding 
is expressed in pixels for the left, top, right and bottom parts of the view. 
Padding can be used to offset the content of the view by a specific amount of 
pixels. For instance, a left padding of 2 will push the view's content by 2 
pixels to the right of the left edge. Padding can be set using the 
(|android.view.View|) or (|android.view.View|) method and queried by calling 
(|android.view.View|) , (|android.view.View|) , (|android.view.View|) , 
(|android.view.View|) , (|android.view.View|) , (|android.view.View|) . 

Even though a view can define a padding, it does not provide any support for 
margins. However, view groups provide such a support. Refer to 
(|android.view.ViewGroup|) and (|android.view.ViewGroup.MarginLayoutParams|) 
for further information. 

Layout 

Layout is a two pass process: a measure pass and a layout pass. The measuring 
pass is implemented in (|android.view.View|) and is a top-down traversal of the 
view tree. Each view pushes dimension specifications down the tree during the 
recursion. At the end of the measure pass, every view has stored its 
measurements. The second pass happens in (|android.view.View|) and is also 
top-down. During this pass each parent is responsible for positioning all of 
its children using the sizes computed in the measure pass. 

When a view's measure() method returns, its (|android.view.View|) and 
(|android.view.View|) values must be set, along with those for all of that 
view's descendants. A view's measured width and measured height values must 
respect the constraints imposed by the view's parents. This guarantees that at 
the end of the measure pass, all parents accept all of their children's 
measurements. A parent view may call measure() more than once on its children. 
For example, the parent may measure each child once with unspecified dimensions 
to find out how big they want to be, then call measure() on them again with 
actual numbers if the sum of all the children's unconstrained sizes is too big 
or too small. 

The measure pass uses two classes to communicate dimensions. The 
(|android.view.View.MeasureSpec|) class is used by views to tell their parents 
how they want to be measured and positioned. The base LayoutParams class just 
describes how big the view wants to be for both width and height. For each 
dimension, it can specify one of: 

an exact number MATCH_PARENT, which means the view wants to be as big as its 
parent (minus padding) WRAP_CONTENT, which means that the view wants to be just 
big enough to enclose its content (plus padding). 

There are subclasses of LayoutParams for different subclasses of ViewGroup. For 
example, AbsoluteLayout has its own subclass of LayoutParams which adds an X 
and Y value. 

MeasureSpecs are used to push requirements down the tree from parent to child. 
A MeasureSpec can be in one of three modes: 

UNSPECIFIED: This is used by a parent to determine the desired dimension of a 
child view. For example, a LinearLayout may call measure() on its child with 
the height set to UNSPECIFIED and a width of EXACTLY 240 to find out how tall 
the child view wants to be given a width of 240 pixels. EXACTLY: This is used 
by the parent to impose an exact size on the child. The child must use this 
size, and guarantee that all of its descendants will fit within this size. 
AT_MOST: This is used by the parent to impose a maximum size on the child. The 
child must gurantee that it and all of its descendants will fit within this 
size. 



To intiate a layout, call (|android.view.View|) . This method is typically 
called by a view on itself when it believes that is can no longer fit within 
its current bounds. 

Drawing 

Drawing is handled by walking the tree and rendering each view that intersects 
the invalid region. Because the tree is traversed in-order, this means that 
parents will draw before (i.e., behind) their children, with siblings drawn in 
the order they appear in the tree. If you set a background drawable for a View, 
then the View will draw it for you before calling back to its onDraw() method. 

Note that the framework will not draw views that are not in the invalid region. 

To force a view to draw, call (|android.view.View|) . 

Event Handling and Threading 

The basic cycle of a view is as follows: 

An event comes in and is dispatched to the appropriate view. The view handles 
the event and notifies any listeners. If in the course of processing the event, 
the view's bounds may need to be changed, the view will call 
(|android.view.View|) . Similarly, if in the course of processing the event the 
view's appearance may need to be changed, the view will call 
(|android.view.View|) . If either (|android.view.View|) or 
(|android.view.View|) were called, the framework will take care of measuring, 
laying out, and drawing the tree as appropriate. 



Note: The entire view tree is single threaded. You must always be on the UI 
thread when calling any method on any view. If you are doing work on other 
threads and want to update the state of a view from that thread, you should use 
a (|android.os.Handler|) . 

Focus Handling 

The framework will handle routine focus movement in response to user input. 
This includes changing the focus as views are removed or hidden, or as new 
views become available. Views indicate their willingness to take focus through 
the (|android.view.View|) method. To change whether a view can take focus, call 
(|android.view.View|) . When in touch mode (see notes below) views indicate 
whether they still would like focus via (|android.view.View|) and can change 
this via (|android.view.View|) . 

Focus movement is based on an algorithm which finds the nearest neighbor in a 
given direction. In rare cases, the default algorithm may not match the 
intended behavior of the developer. In these situations, you can provide 
explicit overrides by using these XML attributes in the layout file: 

nextFocusDown nextFocusLeft nextFocusRight nextFocusUp 



To get a particular view to take focus, call (|android.view.View|) . 

Touch Mode 

When a user is navigating a user interface via directional keys such as a 
D-pad, it is necessary to give focus to actionable items such as buttons so the 
user can see what will take input. If the device has touch capabilities, 
however, and the user begins interacting with the interface by touching it, it 
is no longer necessary to always highlight, or give focus to, a particular 
view. This motivates a mode for interaction named 'touch mode'. 

For a touch capable device, once the user touches the screen, the device will 
enter touch mode. From this point onward, only views for which 
(|android.view.View|) is true will be focusable, such as text editing widgets. 
Other views that are touchable, like buttons, will not take focus when touched; 
they will only fire the on click listeners. 

Any time a user hits a directional key, such as a D-pad direction, the view 
device will exit touch mode, and find a view to take focus, so that the user 
may resume interacting with the user interface without touching the screen 
again. 

The touch mode state is maintained across (|android.app.Activity|) s. Call 
(|android.view.View|) to see whether the device is currently in touch mode. 

Scrolling 

The framework provides basic support for views that wish to internally scroll 
their content. This includes keeping track of the X and Y scroll offset as well 
as mechanisms for drawing scrollbars. See (|android.view.View|) , 
(|android.view.View|) , and (|android.view.View|) for more details. 

Tags 

Unlike IDs, tags are not used to identify views. Tags are essentially an extra 
piece of information that can be associated with a view. They are most often 
used as a convenience to store data related to views in the views themselves 
rather than by putting them in a separate structure. 

Properties 

The View class exposes an (|android.view.View|) property, as well as several 
transform-related properties, such as (|android.view.View|) and 
(|android.view.View|) . These properties are available both in the 
(|android.util.Property|) form as well as in similarly-named setter/getter 
methods (such as (|android.view.View|) for (|android.view.View|) ). These 
properties can be used to set persistent state associated with these 
rendering-related properties on the view. The properties and methods can also 
be used in conjunction with Animator(|android.animation.Animator|) -based 
animations, described more in the Animation section. 

Animation 

Starting with Android 3.0, the preferred way of animating views is to use the 
(|android.animation|) package APIs. These 
Animator(|android.animation.Animator|) -based classes change actual properties 
of the View object, such as alpha(|android.view.View|) and 
translationX(|android.view.View|) . This behavior is contrasted to that of the 
pre-3.0 Animation(|android.view.animation.Animation|) -based classes, which 
instead animate only how the view is drawn on the display. In particular, the 
(|android.view.ViewPropertyAnimator|) class makes animating these View 
properties particularly easy and efficient. 

Alternatively, you can use the pre-3.0 animation classes to animate how Views 
are rendered. You can attach an (|android.view.animation.Animation|) object to 
a view using (|android.view.View|) or (|android.view.View|) . The animation can 
alter the scale, rotation, translation and alpha of a view over time. If the 
animation is attached to a view that has children, the animation will affect 
the entire subtree rooted by that node. When an animation is started, the 
framework will take care of redrawing the appropriate views until the animation 
completes. 

Security 

Sometimes it is essential that an application be able to verify that an action 
is being performed with the full knowledge and consent of the user, such as 
granting a permission request, making a purchase or clicking on an 
advertisement. Unfortunately, a malicious application could try to spoof the 
user into performing these actions, unaware, by concealing the intended purpose 
of the view. As a remedy, the framework offers a touch filtering mechanism that 
can be used to improve the security of views that provide access to sensitive 
functionality. 

To enable touch filtering, call (|android.view.View|) or set the 
android:filterTouchesWhenObscured layout attribute to true. When enabled, the 
framework will discard touches that are received whenever the view's window is 
obscured by another visible window. As a result, the view will not receive 
touches whenever a toast, dialog or other window appears above the view's 
window. 

For more fine-grained control over security, consider overriding the 
(|android.view.View|) method to implement your own security policy. See also 
(|android.view.MotionEvent|) . 



*int_android.view.View.ACCESSIBILITY_CURSOR_POSITION_UNDEFINED*

The undefined cursor position. 


*int_android.view.View.ACCESSIBILITY_LIVE_REGION_ASSERTIVE*

Live region mode specifying that accessibility services should interrupt 
ongoing speech to immediately announce changes to this view. 

Use with (|android.view.View|) . 


*int_android.view.View.ACCESSIBILITY_LIVE_REGION_NONE*

Live region mode specifying that accessibility services should not 
automatically announce changes to this view. This is the default live region 
mode for most views. 

Use with (|android.view.View|) . 


*int_android.view.View.ACCESSIBILITY_LIVE_REGION_POLITE*

Live region mode specifying that accessibility services should announce changes 
to this view. 

Use with (|android.view.View|) . 


*android.util.Property<android.view.View, java.lang.Float>_android.view.View.ALPHA*

A Property wrapper around the alpha functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 


*java.lang.String_android.view.View.DEBUG_LAYOUT_PROPERTY*

When set to true, apps will draw debugging information about their layouts. 


*int_android.view.View.DRAG_FLAG_GLOBAL*

Flag indicating that a drag can cross window boundaries. When 
(|android.view.View|) is called with this flag set, all visible applications 
will be able to participate in the drag operation and receive the dragged 
content. 


*int_android.view.View.DRAWING_CACHE_QUALITY_AUTO*

Enables automatic quality mode for the drawing cache. 


*int_android.view.View.DRAWING_CACHE_QUALITY_HIGH*

Enables high quality mode for the drawing cache. 


*int_android.view.View.DRAWING_CACHE_QUALITY_LOW*

Enables low quality mode for the drawing cache. 


*int[]_android.view.View.EMPTY_STATE_SET*

Indicates the view has no states set. States are used with 
(|android.graphics.drawable.Drawable|) to change the drawing of the view 
depending on its state. 


*int[]_android.view.View.ENABLED_FOCUSED_SELECTED_STATE_SET*

Indicates the view is enabled, focused and selected. 


*int[]_android.view.View.ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is enabled, focused, selected and its window has the focus. 


*int[]_android.view.View.ENABLED_FOCUSED_STATE_SET*

Indicates the view is enabled and has the focus. 


*int[]_android.view.View.ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is enabled, focused and its window has the focus. 


*int[]_android.view.View.ENABLED_SELECTED_STATE_SET*

Indicates the view is enabled and selected. 


*int[]_android.view.View.ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is enabled, selected and its window has the focus. 


*int[]_android.view.View.ENABLED_STATE_SET*

Indicates the view is enabled. States are used with 
(|android.graphics.drawable.Drawable|) to change the drawing of the view 
depending on its state. 


*int[]_android.view.View.ENABLED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is enabled and that its window has focus. 


*int_android.view.View.FIND_VIEWS_WITH_ACCESSIBILITY_NODE_PROVIDERS*

Find views that contain 
(|android.view.accessibility.AccessibilityNodeProvider|) . Such a View is a 
root of virtual view hierarchy and may contain the searched text. If this flag 
is set Views with providers are automatically added and it is a responsibility 
of the client to call the APIs of the provider to determine whether the virtual 
tree rooted at this View contains the text, i.e. getting the list of 
(|android.view.accessibility.AccessibilityNodeInfo|) s represeting the virtual 
views with this text. 


*int_android.view.View.FIND_VIEWS_WITH_CONTENT_DESCRIPTION*

Find find views that contain the specified content description. 


*int_android.view.View.FIND_VIEWS_WITH_TEXT*

Find views that render the specified text. 


*int_android.view.View.FOCUS_BACKWARD*

Use with (|android.view.View|) . Move focus to the previous selectable item. 


*int_android.view.View.FOCUS_DOWN*

Use with (|android.view.View|) . Move focus down. 


*int_android.view.View.FOCUS_FORWARD*

Use with (|android.view.View|) . Move focus to the next selectable item. 


*int_android.view.View.FOCUS_LEFT*

Use with (|android.view.View|) . Move focus to the left. 


*int_android.view.View.FOCUS_RIGHT*

Use with (|android.view.View|) . Move focus to the right. 


*int_android.view.View.FOCUS_UP*

Use with (|android.view.View|) . Move focus up. 


*int_android.view.View.FOCUSABLES_ALL*

View flag indicating whether (|android.view.View|) should add all focusable 
Views regardless if they are focusable in touch mode. 


*int_android.view.View.FOCUSABLES_TOUCH_MODE*

View flag indicating whether (|android.view.View|) should add only Views 
focusable in touch mode. 


*int[]_android.view.View.FOCUSED_SELECTED_STATE_SET*

Indicates the view is focused and selected. 


*int[]_android.view.View.FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is focused, selected and its window has the focus. 


*int[]_android.view.View.FOCUSED_STATE_SET*

Indicates the view is focused. States are used with 
(|android.graphics.drawable.Drawable|) to change the drawing of the view 
depending on its state. 


*int[]_android.view.View.FOCUSED_WINDOW_FOCUSED_STATE_SET*

Indicates the view has the focus and that its window has the focus. 


*int_android.view.View.GONE*

This view is invisible, and it doesn't take any space for layout purposes. Use 
with (|android.view.View|) and android:visibility. 


*int_android.view.View.HAPTIC_FEEDBACK_ENABLED*

View flag indicating whether this view should have haptic feedback enabled for 
events such as long presses. 


*int_android.view.View.IMPORTANT_FOR_ACCESSIBILITY_AUTO*

Automatically determine whether a view is important for accessibility. 


*int_android.view.View.IMPORTANT_FOR_ACCESSIBILITY_NO*

The view is not important for accessibility. 


*int_android.view.View.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS*

The view is not important for accessibility, nor are any of its descendant 
views. 


*int_android.view.View.IMPORTANT_FOR_ACCESSIBILITY_YES*

The view is important for accessibility. 


*int_android.view.View.INVISIBLE*

This view is invisible, but it still takes up space for layout purposes. Use 
with (|android.view.View|) and android:visibility. 


*int_android.view.View.KEEP_SCREEN_ON*

View flag indicating that the screen should remain on while the window 
containing this view is visible to the user. This effectively takes care of 
automatically setting the WindowManager's 
(|android.view.WindowManager.LayoutParams|) . 


*int_android.view.View.LAYER_TYPE_HARDWARE*

Indicates that the view has a hardware layer. A hardware layer is backed by a 
hardware specific texture (generally Frame Buffer Objects or FBO on OpenGL 
hardware) and causes the view to be rendered using Android's hardware rendering 
pipeline, but only if hardware acceleration is turned on for the view 
hierarchy. When hardware acceleration is turned off, hardware layers behave 
exactly as software layers(|android.view.View|) . 

A hardware layer is useful to apply a specific color filter and/or blending 
mode and/or translucency to a view and all its children. A hardware layer can 
be used to cache a complex view tree into a texture and reduce the complexity 
of drawing operations. For instance, when animating a complex view tree with a 
translation, a hardware layer can be used to render the view tree only once. A 
hardware layer can also be used to increase the rendering quality when rotation 
transformations are applied on a view. It can also be used to prevent potential 
clipping issues when applying 3D transforms on a view. 


*int_android.view.View.LAYER_TYPE_NONE*

Indicates that the view does not have a layer. 


*int_android.view.View.LAYER_TYPE_SOFTWARE*

Indicates that the view has a software layer. A software layer is backed by a 
bitmap and causes the view to be rendered using Android's software rendering 
pipeline, even if hardware acceleration is enabled. 

Software layers have various usages: When the application is not using hardware 
acceleration, a software layer is useful to apply a specific color filter 
and/or blending mode and/or translucency to a view and all its children. When 
the application is using hardware acceleration, a software layer is useful to 
render drawing primitives not supported by the hardware accelerated pipeline. 
It can also be used to cache a complex view tree into a texture and reduce the 
complexity of drawing operations. For instance, when animating a complex view 
tree with a translation, a software layer can be used to render the view tree 
only once. Software layers should be avoided when the affected view tree 
updates often. Every update will require to re-render the software layer, which 
can potentially be slow (particularly when hardware acceleration is turned on 
since the layer will have to be uploaded into a hardware texture after every 
update.) 


*int_android.view.View.LAYOUT_DIRECTION_INHERIT*

Horizontal layout direction of this view is inherited from its parent. Use with 
(|android.view.View|) . 


*int_android.view.View.LAYOUT_DIRECTION_LOCALE*

Horizontal layout direction of this view is from deduced from the default 
language script for the locale. Use with (|android.view.View|) . 


*int_android.view.View.LAYOUT_DIRECTION_LTR*

Horizontal layout direction of this view is from Left to Right. Use with 
(|android.view.View|) . 


*int_android.view.View.LAYOUT_DIRECTION_RTL*

Horizontal layout direction of this view is from Right to Left. Use with 
(|android.view.View|) . 


*int_android.view.View.mBottom*

The distance in pixels from the top edge of this view's parent to the bottom 
edge of this view. 


*boolean_android.view.View.mCachingFailed*

Set to true when drawing cache is enabled and cannot be created. 


*android.content.Context_android.view.View.mContext*

The application environment this view lives in. This field should be made 
private, so it is hidden from the SDK. 


*android.view.animation.Animation_android.view.View.mCurrentAnimation*

The animation currently associated with this view. 


*int_android.view.View.MEASURED_HEIGHT_STATE_SHIFT*

Bit shift of (|android.view.View|) to get to the height bits for functions that 
combine both width and height into a single int, such as (|android.view.View|) 
and the childState argument of (|android.view.View|) . 


*int_android.view.View.MEASURED_SIZE_MASK*

Bits of (|android.view.View|) and (|android.view.View|) that provide the actual 
measured size. 


*int_android.view.View.MEASURED_STATE_MASK*

Bits of (|android.view.View|) and (|android.view.View|) that provide the 
additional state bits. 


*int_android.view.View.MEASURED_STATE_TOO_SMALL*

Bit of (|android.view.View|) and (|android.view.View|) that indicates the 
measured size is smaller that the space the view would like to have. 


*android.view.InputEventConsistencyVerifier_android.view.View.mInputEventConsistencyVerifier*

Consistency verifier for debugging purposes. 


*android.view.ViewGroup.LayoutParams_android.view.View.mLayoutParams*

The layout parameters associated with this view and used by the parent 
(|android.view.ViewGroup|) to determine how this view should be laid out. 


*int_android.view.View.mLeft*

The distance in pixels from the left edge of this view's parent to the left 
edge of this view. 


*int_android.view.View.mPaddingBottom*

The bottom padding in pixels, that is the distance in pixels between the bottom 
edge of this view and the bottom edge of its content. 


*int_android.view.View.mPaddingLeft*

The left padding in pixels, that is the distance in pixels between the left 
edge of this view and the left edge of its content. 


*int_android.view.View.mPaddingRight*

The right padding in pixels, that is the distance in pixels between the right 
edge of this view and the right edge of its content. 


*int_android.view.View.mPaddingTop*

The top padding in pixels, that is the distance in pixels between the top edge 
of this view and the top edge of its content. 


*android.view.ViewParent_android.view.View.mParent*

The parent this view is attached to. 


*int_android.view.View.mRight*

The distance in pixels from the left edge of this view's parent to the right 
edge of this view. 


*int_android.view.View.mScrollX*

The offset, in pixels, by which the content of this view is scrolled 
horizontally. 


*int_android.view.View.mScrollY*

The offset, in pixels, by which the content of this view is scrolled 
vertically. 


*java.lang.Object_android.view.View.mTag*

The view's tag. 


*int_android.view.View.mTop*

The distance in pixels from the top edge of this view's parent to the top edge 
of this view. 


*int_android.view.View.mUserPaddingBottom*

Cache the paddingBottom set by the user to append to the scrollbar's size. 


*int_android.view.View.mUserPaddingLeft*

Cache the paddingLeft set by the user to append to the scrollbar's size. 


*int_android.view.View.mUserPaddingRight*

Cache the paddingRight set by the user to append to the scrollbar's size. 


*int_android.view.View.NAVIGATION_BAR_TRANSIENT*




*int_android.view.View.NAVIGATION_BAR_TRANSLUCENT*




*int_android.view.View.NAVIGATION_BAR_UNHIDE*




*int_android.view.View.NO_ID*

Used to mark a View that has no ID. 


*int_android.view.View.OVER_SCROLL_ALWAYS*

Always allow a user to over-scroll this view, provided it is a view that can 
scroll. 


*int_android.view.View.OVER_SCROLL_IF_CONTENT_SCROLLS*

Allow a user to over-scroll this view only if the content is large enough to 
meaningfully scroll, provided it is a view that can scroll. 


*int_android.view.View.OVER_SCROLL_NEVER*

Never allow a user to over-scroll this view. 


*int[]_android.view.View.PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET*

Indicates the view is pressed, enabled, focused and selected. 


*int[]_android.view.View.PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is pressed, enabled, focused, selected and its window has 
the focus. 


*int[]_android.view.View.PRESSED_ENABLED_FOCUSED_STATE_SET*

Indicates the view is pressed, enabled and focused. 


*int[]_android.view.View.PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is pressed, enabled, focused and its window has the focus. 


*int[]_android.view.View.PRESSED_ENABLED_SELECTED_STATE_SET*

Indicates the view is pressed, enabled and selected. 


*int[]_android.view.View.PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is pressed, enabled, selected and its window has the focus. 


*int[]_android.view.View.PRESSED_ENABLED_STATE_SET*

Indicates the view is pressed and enabled. 


*int[]_android.view.View.PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is pressed, enabled and its window has the focus. 


*int[]_android.view.View.PRESSED_FOCUSED_SELECTED_STATE_SET*

Indicates the view is pressed, focused and selected. 


*int[]_android.view.View.PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is pressed, focused, selected and its window has the focus. 


*int[]_android.view.View.PRESSED_FOCUSED_STATE_SET*

Indicates the view is pressed and focused. 


*int[]_android.view.View.PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is pressed, focused and its window has the focus. 


*int[]_android.view.View.PRESSED_SELECTED_STATE_SET*

Indicates the view is pressed and selected. 


*int[]_android.view.View.PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is pressed, selected and its window has the focus. 


*int[]_android.view.View.PRESSED_STATE_SET*

Indicates the view is pressed. States are used with 
(|android.graphics.drawable.Drawable|) to change the drawing of the view 
depending on its state. 


*int[]_android.view.View.PRESSED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is pressed and its window has the focus. 


*int_android.view.View.PUBLIC_STATUS_BAR_VISIBILITY_MASK*




*android.util.Property<android.view.View, java.lang.Float>_android.view.View.ROTATION*

A Property wrapper around the rotation functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 


*android.util.Property<android.view.View, java.lang.Float>_android.view.View.ROTATION_X*

A Property wrapper around the rotationX functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 


*android.util.Property<android.view.View, java.lang.Float>_android.view.View.ROTATION_Y*

A Property wrapper around the rotationY functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 


*android.util.Property<android.view.View, java.lang.Float>_android.view.View.SCALE_X*

A Property wrapper around the scaleX functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 


*android.util.Property<android.view.View, java.lang.Float>_android.view.View.SCALE_Y*

A Property wrapper around the scaleY functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 


*int_android.view.View.SCREEN_STATE_OFF*

Indicates that the screen has changed state and is now off. 


*int_android.view.View.SCREEN_STATE_ON*

Indicates that the screen has changed state and is now on. 


*int_android.view.View.SCROLLBAR_POSITION_DEFAULT*

Position the scroll bar at the default position as determined by the system. 


*int_android.view.View.SCROLLBAR_POSITION_LEFT*

Position the scroll bar along the left edge. 


*int_android.view.View.SCROLLBAR_POSITION_RIGHT*

Position the scroll bar along the right edge. 


*int_android.view.View.SCROLLBARS_INSIDE_INSET*

The scrollbar style to display the scrollbars inside the padded area, 
increasing the padding of the view. The scrollbars will not overlap the content 
area of the view. 


*int_android.view.View.SCROLLBARS_INSIDE_OVERLAY*

The scrollbar style to display the scrollbars inside the content area, without 
increasing the padding. The scrollbars will be overlaid with translucency on 
the view's content. 


*int_android.view.View.SCROLLBARS_OUTSIDE_INSET*

The scrollbar style to display the scrollbars at the edge of the view, 
increasing the padding of the view. The scrollbars will only overlap the 
background, if any. 


*int_android.view.View.SCROLLBARS_OUTSIDE_OVERLAY*

The scrollbar style to display the scrollbars at the edge of the view, without 
increasing the padding. The scrollbars will be overlaid with translucency. 


*int[]_android.view.View.SELECTED_STATE_SET*

Indicates the view is selected. States are used with 
(|android.graphics.drawable.Drawable|) to change the drawing of the view 
depending on its state. 


*int[]_android.view.View.SELECTED_WINDOW_FOCUSED_STATE_SET*

Indicates the view is selected and that its window has the focus. 


*int_android.view.View.SOUND_EFFECTS_ENABLED*

View flag indicating whether this view should have sound effects enabled for 
events such as clicking and touching. 


*int_android.view.View.STATUS_BAR_DISABLE_BACK*




*int_android.view.View.STATUS_BAR_DISABLE_CLOCK*




*int_android.view.View.STATUS_BAR_DISABLE_EXPAND*




*int_android.view.View.STATUS_BAR_DISABLE_HOME*




*int_android.view.View.STATUS_BAR_DISABLE_NOTIFICATION_ALERTS*




*int_android.view.View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS*




*int_android.view.View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER*




*int_android.view.View.STATUS_BAR_DISABLE_RECENT*




*int_android.view.View.STATUS_BAR_DISABLE_SEARCH*




*int_android.view.View.STATUS_BAR_DISABLE_SYSTEM_INFO*




*int_android.view.View.STATUS_BAR_HIDDEN*




*int_android.view.View.STATUS_BAR_TRANSIENT*




*int_android.view.View.STATUS_BAR_TRANSLUCENT*




*int_android.view.View.STATUS_BAR_UNHIDE*




*int_android.view.View.STATUS_BAR_VISIBLE*




*int_android.view.View.SYSTEM_UI_CLEARABLE_FLAGS*

These are the system UI flags that can be cleared by events outside of an 
application. Currently this is just the ability to tap on the screen while 
hiding the navigation bar to have it return. 


*int_android.view.View.SYSTEM_UI_FLAG_FULLSCREEN*

Flag for (|android.view.View|) : View has requested to go into the normal 
fullscreen mode so that its content can take over the screen while still 
allowing the user to interact with the application. 

This has the same visual effect as 
WindowManager.LayoutParams.FLAG_FULLSCREEN(|android.view.WindowManager.LayoutParams|)
, meaning that non-critical screen decorations (such as the status bar) will be 
hidden while the user is in the View's window, focusing the experience on that 
content. Unlike the window flag, if you are using ActionBar in overlay mode 
with Window.FEATURE_ACTION_BAR_OVERLAY(|android.view.Window|) , then enabling 
this flag will also hide the action bar. 

This approach to going fullscreen is best used over the window flag when it is 
a transient state -- that is, the application does this at certain points in 
its user interaction where it wants to allow the user to focus on content, but 
not as a continuous state. For situations where the application would like to 
simply stay full screen the entire time (such as a game that wants to take over 
the screen), the window flag(|android.view.WindowManager.LayoutParams|) is 
usually a better approach. The state set here will be removed by the system in 
various situations (such as the user moving to another application) like the 
other system UI states. 

When using this flag, the application should provide some easy facility for the 
user to go out of it. A common example would be in an e-book reader, where 
tapping on the screen brings back whatever screen and UI decorations that had 
been hidden while the user was immersed in reading the book. 


*int_android.view.View.SYSTEM_UI_FLAG_HIDE_NAVIGATION*

Flag for (|android.view.View|) : View has requested that the system navigation 
be temporarily hidden. 

This is an even less obtrusive state than that called for by 
(|android.view.View|) ; on devices that draw essential navigation controls 
(Home, Back, and the like) on screen, SYSTEM_UI_FLAG_HIDE_NAVIGATION will cause 
those to disappear. This is useful (in conjunction with the 
FLAG_FULLSCREEN(|android.view.WindowManager.LayoutParams|) and 
FLAG_LAYOUT_IN_SCREEN(|android.view.WindowManager.LayoutParams|) window flags) 
for displaying content using every last pixel on the display. 

There is a limitation: because navigation controls are so important, the least 
user interaction will cause them to reappear immediately. When this happens, 
both this flag and (|android.view.View|) will be cleared automatically, so that 
both elements reappear at the same time. 


*int_android.view.View.SYSTEM_UI_FLAG_IMMERSIVE*

Flag for (|android.view.View|) : View would like to remain interactive when 
hiding the navigation bar with (|android.view.View|) . If this flag is not set, 
(|android.view.View|) will be force cleared by the system on any user 
interaction. Since this flag is a modifier for (|android.view.View|) , it only 
has an effect when used in combination with that flag. 


*int_android.view.View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY*

Flag for (|android.view.View|) : View would like to remain interactive when 
hiding the status bar with (|android.view.View|) and/or hiding the navigation 
bar with (|android.view.View|) . Use this flag to create an immersive 
experience while also hiding the system bars. If this flag is not set, 
(|android.view.View|) will be force cleared by the system on any user 
interaction, and (|android.view.View|) will be force-cleared by the system if 
the user swipes from the top of the screen. When system bars are hidden in 
immersive mode, they can be revealed temporarily with system gestures, such as 
swiping from the top of the screen. These transient system bars will overlay 
apps content, may have some degree of transparency, and will automatically 
hide after a short timeout. Since this flag is a modifier for 
(|android.view.View|) and (|android.view.View|) , it only has an effect when 
used in combination with one or both of those flags. 


*int_android.view.View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN*

Flag for (|android.view.View|) : View would like its window to be layed out as 
if it has requested (|android.view.View|) , even if it currently hasn't. This 
allows it to avoid artifacts when switching in and out of that mode, at the 
expense that some of its user interface may be covered by screen decorations 
when they are shown. You can perform layout of your inner UI elements to 
account for non-fullscreen system UI through the (|android.view.View|) method. 


*int_android.view.View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION*

Flag for (|android.view.View|) : View would like its window to be layed out as 
if it has requested (|android.view.View|) , even if it currently hasn't. This 
allows it to avoid artifacts when switching in and out of that mode, at the 
expense that some of its user interface may be covered by screen decorations 
when they are shown. You can perform layout of your inner UI elements to 
account for the navigation system UI through the (|android.view.View|) method. 


*int_android.view.View.SYSTEM_UI_FLAG_LAYOUT_STABLE*

Flag for (|android.view.View|) : When using other layout flags, we would like a 
stable view of the content insets given to (|android.view.View|) . This means 
that the insets seen there will always represent the worst case that the 
application can expect as a continuous state. In the stock Android UI this is 
the space for the system bar, nav bar, and status bar, but not more transient 
elements such as an input method. 

The stable layout your UI sees is based on the system UI modes you can switch 
to. That is, if you specify (|android.view.View|) then you will get a stable 
layout for changes of the (|android.view.View|) mode; if you specify 
(|android.view.View|) and (|android.view.View|) , then you can transition to 
(|android.view.View|) and (|android.view.View|) with a stable layout. (Note 
that you should avoid using (|android.view.View|) by itself.) 

If you have set the window flag (|android.view.WindowManager.LayoutParams|) to 
hide the status bar (instead of using (|android.view.View|) ), then a hidden 
status bar will be considered a "stable" state for purposes here. This allows 
your UI to continually hide the status bar, while still using the system UI 
flags to hide the action bar while still retaining a stable layout. Note that 
changing the window fullscreen flag will never provide a stable layout for a 
clean transition. 

If you are using ActionBar in overlay mode with 
Window.FEATURE_ACTION_BAR_OVERLAY(|android.view.Window|) , this flag will also 
impact the insets it adds to those given to the application. 


*int_android.view.View.SYSTEM_UI_FLAG_LOW_PROFILE*

Flag for (|android.view.View|) : View has requested the system UI to enter an 
unobtrusive "low profile" mode. 

This is for use in games, book readers, video players, or any other "immersive" 
application where the usual system chrome is deemed too distracting. 

In low profile mode, the status bar and/or navigation icons may dim. 


*int_android.view.View.SYSTEM_UI_FLAG_VISIBLE*

Special constant for (|android.view.View|) : View has requested the system UI 
(status bar) to be visible (the default). 


*int_android.view.View.SYSTEM_UI_LAYOUT_FLAGS*

Flags that can impact the layout in relation to system UI. 


*int_android.view.View.TEXT_ALIGNMENT_CENTER*

Center the paragraph, e.g. ALIGN_CENTER. 

Use with (|android.view.View|) 


*int_android.view.View.TEXT_ALIGNMENT_GRAVITY*

Default for the root view. The gravity determines the text alignment, 
ALIGN_NORMAL, ALIGN_CENTER, or ALIGN_OPPOSITE, which are relative to each 
paragraphs text direction. 

Use with (|android.view.View|) 


*int_android.view.View.TEXT_ALIGNMENT_INHERIT*




*int_android.view.View.TEXT_ALIGNMENT_TEXT_END*

Align to the end of the paragraph, e.g. ALIGN_OPPOSITE. 

Use with (|android.view.View|) 


*int_android.view.View.TEXT_ALIGNMENT_TEXT_START*

Align to the start of the paragraph, e.g. ALIGN_NORMAL. 

Use with (|android.view.View|) 


*int_android.view.View.TEXT_ALIGNMENT_VIEW_END*

Align to the end of the view, which is ALIGN_RIGHT if the views resolved 
layoutDirection is LTR, and ALIGN_LEFT otherwise. 

Use with (|android.view.View|) 


*int_android.view.View.TEXT_ALIGNMENT_VIEW_START*

Align to the start of the view, which is ALIGN_LEFT if the views resolved 
layoutDirection is LTR, and ALIGN_RIGHT otherwise. 

Use with (|android.view.View|) 


*int_android.view.View.TEXT_DIRECTION_ANY_RTL*

Text direction is using "any-RTL" algorithm. The paragraph direction is RTL if 
it contains any strong RTL character, otherwise it is LTR if it contains any 
strong LTR characters. If there are neither, the paragraph direction is the 
view's resolved layout direction. 


*int_android.view.View.TEXT_DIRECTION_FIRST_STRONG*

Text direction is using "first strong algorithm". The first strong directional 
character determines the paragraph direction. If there is no strong directional 
character, the paragraph direction is the view's resolved layout direction. 


*int_android.view.View.TEXT_DIRECTION_INHERIT*

Text direction is inherited thru (|android.view.ViewGroup|) 


*int_android.view.View.TEXT_DIRECTION_LOCALE*

Text direction is coming from the system Locale. 


*int_android.view.View.TEXT_DIRECTION_LTR*

Text direction is forced to LTR. 


*int_android.view.View.TEXT_DIRECTION_RTL*

Text direction is forced to RTL. 


*android.util.Property<android.view.View, java.lang.Float>_android.view.View.TRANSLATION_X*

A Property wrapper around the translationX functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 


*android.util.Property<android.view.View, java.lang.Float>_android.view.View.TRANSLATION_Y*

A Property wrapper around the translationY functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 


*java.lang.String_android.view.View.VIEW_LOG_TAG*

The logging tag used by this class with android.util.Log. 


*int_android.view.View.VISIBLE*

This view is visible. Use with (|android.view.View|) and android:visibility. 


*int[]_android.view.View.WINDOW_FOCUSED_STATE_SET*

Indicates the view's window has focus. States are used with 
(|android.graphics.drawable.Drawable|) to change the drawing of the view 
depending on its state. 


*android.util.Property<android.view.View, java.lang.Float>_android.view.View.X*

A Property wrapper around the x functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 


*android.util.Property<android.view.View, java.lang.Float>_android.view.View.Y*

A Property wrapper around the y functionality handled by the 
(|android.view.View|) and (|android.view.View|) methods. 



*android.view.View(Context)*

public View(android.content.Context context)

Simple constructor to use when creating a view from code. 

    context - The Context the view is running in, through which it can access the current 
       theme, resources, etc. 

*android.view.View(Context,AttributeSet)*

public View(
  android.content.Context context,
  android.util.AttributeSet attrs)

Constructor that is called when inflating a view from XML. This is called when 
a view is being constructed from an XML file, supplying attributes that were 
specified in the XML file. This version uses a default style of 0, so the only 
attribute values applied are those in the Context's Theme and the given 
AttributeSet. 

The method onFinishInflate() will be called after all children have been added. 

    context - The Context the view is running in, through which it can access the current 
       theme, resources, etc. 
    attrs - The attributes of the XML tag that is inflating the view. 

*android.view.View(Context,AttributeSet,int)*

public View(
  android.content.Context context,
  android.util.AttributeSet attrs,
  int defStyleAttr)

Perform inflation from XML and apply a class-specific base style. This 
constructor of View allows subclasses to use their own base style when they are 
inflating. For example, a Button class's constructor would call this version of 
the super class constructor and supply R.attr.buttonStyle for defStyle; this 
allows the theme's button style to modify all of the base view attributes (in 
particular its background) as well as the Button class's attributes. 

    context - The Context the view is running in, through which it can access the current 
       theme, resources, etc. 
    attrs - The attributes of the XML tag that is inflating the view. 
    defStyleAttr - An attribute in the current theme that contains a reference to a style resource 
       to apply to this view. If 0, no default style will be applied. 

*android.view.View.addChildrenForAccessibility(ArrayList<View>)*

public void addChildrenForAccessibility(java.util.ArrayList<android.view.View> children)

Adds the children of a given View for accessibility. Since some Views are not 
important for accessibility the children for accessibility are not necessarily 
direct children of the view, rather they are the first level of descendants 
important for accessibility. 


    children - The list of children for accessibility. 

*android.view.View.addFocusables(ArrayList<View>,int)*

public void addFocusables(
  java.util.ArrayList<android.view.View> views,
  int direction)

Add any focusable views that are descendants of this view (possibly including 
this view if it is focusable itself) to views. If we are in touch mode, only 
add views that are also focusable in touch mode. 


    views - Focusable views found so far 
    direction - The direction of the focus 

*android.view.View.addFocusables(ArrayList<View>,int,int)*

public void addFocusables(
  java.util.ArrayList<android.view.View> views,
  int direction,
  int focusableMode)

Adds any focusable views that are descendants of this view (possibly including 
this view if it is focusable itself) to views. This method adds all focusable 
views regardless if we are in touch mode or only views focusable in touch mode 
if we are in touch mode or only views that can take accessibility focus if 
accessibility is enabeld depending on the focusable mode paramater. 


    views - Focusable views found so far or null if all we are interested is the number of 
       focusables. 
    direction - The direction of the focus. 
    focusableMode - The type of focusables to be added. 

*android.view.View.addOnAttachStateChangeListener(View.OnAttachStateChangeListener)*

public void addOnAttachStateChangeListener(android.view.View.OnAttachStateChangeListener listener)

Add a listener for attach state changes. 

This listener will be called whenever this view is attached or detached from a 
window. Remove the listener using (|android.view.View|) . 


    listener - Listener to attach 

*android.view.View.addOnLayoutChangeListener(View.OnLayoutChangeListener)*

public void addOnLayoutChangeListener(android.view.View.OnLayoutChangeListener listener)

Add a listener that will be called when the bounds of the view change due to 
layout processing. 


    listener - The listener that will be called when layout bounds change. 

*android.view.View.addTouchables(ArrayList<View>)*

public void addTouchables(java.util.ArrayList<android.view.View> views)

Add any touchable views that are descendants of this view (possibly including 
this view if it is touchable itself) to views. 


    views - Touchable views found so far 

*android.view.View.animate()*

public |android.view.ViewPropertyAnimator| animate()

This method returns a ViewPropertyAnimator object, which can be used to animate 
specific properties on this View. 



    Returns: ViewPropertyAnimator The ViewPropertyAnimator associated with this View. 

*android.view.View.announceForAccessibility(CharSequence)*

public void announceForAccessibility(java.lang.CharSequence text)

Convenience method for sending a 
(|android.view.accessibility.AccessibilityEvent|) 
(|android.view.accessibility.AccessibilityEvent|) to make an announcement which 
is related to some sort of a context change for which none of the events 
representing UI transitions is a good fit. For example, announcing a new page 
in a book. If accessibility is not enabled this method does nothing. 


    text - The announcement text. 

*android.view.View.applyDrawableToTransparentRegion(Drawable,Region)*

public void applyDrawableToTransparentRegion(
  Drawable dr,
  Region region)

Given a Drawable whose bounds have been set to draw into this view, update a 
Region being computed for (|android.view.View|) so that any non-transparent 
parts of the Drawable are removed from the given transparent region. 


    dr - The Drawable whose transparency is to be applied to the region. 
    region - A Region holding the current transparency information, where any parts of the 
       region that are set are considered to be transparent. On return, this 
       region will be modified to have the transparency information reduced by 
       the corresponding parts of the Drawable that are not transparent. 
       {@hide} 

*android.view.View.awakenScrollBars()*

protected boolean awakenScrollBars()

Trigger the scrollbars to draw. When invoked this method starts an animation to 
fade the scrollbars out after a default delay. If a subclass provides animated 
scrolling, the start delay should equal the duration of the scrolling 
animation. 

The animation starts only if at least one of the scrollbars is enabled, as 
specified by (|android.view.View|) and (|android.view.View|) . When the 
animation is started, this method returns true, and false otherwise. If the 
animation is started, this method calls (|android.view.View|) ; in that case 
the caller should not call (|android.view.View|) . 

This method should be invoked every time a subclass directly updates the scroll 
parameters. 

This method is automatically invoked by (|android.view.View|) and 
(|android.view.View|) . 



    Returns: true if the animation is played, false otherwise 

*android.view.View.awakenScrollBars(int)*

protected boolean awakenScrollBars(int startDelay)

Trigger the scrollbars to draw. When invoked this method starts an animation to 
fade the scrollbars out after a fixed delay. If a subclass provides animated 
scrolling, the start delay should equal the duration of the scrolling 
animation. 

The animation starts only if at least one of the scrollbars is enabled, as 
specified by (|android.view.View|) and (|android.view.View|) . When the 
animation is started, this method returns true, and false otherwise. If the 
animation is started, this method calls (|android.view.View|) ; in that case 
the caller should not call (|android.view.View|) . 

This method should be invoked everytime a subclass directly updates the scroll 
parameters. 


    startDelay - the delay, in milliseconds, after which the animation should start; when the 
       delay is 0, the animation starts immediately 

    Returns: true if the animation is played, false otherwise 

*android.view.View.awakenScrollBars(int,boolean)*

protected boolean awakenScrollBars(
  int startDelay,
  boolean invalidate)

Trigger the scrollbars to draw. When invoked this method starts an animation to 
fade the scrollbars out after a fixed delay. If a subclass provides animated 
scrolling, the start delay should equal the duration of the scrolling 
animation. 

The animation starts only if at least one of the scrollbars is enabled, as 
specified by (|android.view.View|) and (|android.view.View|) . When the 
animation is started, this method returns true, and false otherwise. If the 
animation is started, this method calls (|android.view.View|) if the invalidate 
parameter is set to true; in that case the caller should not call 
(|android.view.View|) . 

This method should be invoked everytime a subclass directly updates the scroll 
parameters. 


    startDelay - the delay, in milliseconds, after which the animation should start; when the 
       delay is 0, the animation starts immediately 
    invalidate - Wheter this method should call invalidate 

    Returns: true if the animation is played, false otherwise 

*android.view.View.bringToFront()*

public void bringToFront()

Change the view's z order in the tree, so it's on top of other sibling views. 
This ordering change may affect layout, if the parent container uses an 
order-dependent layout scheme (e.g., LinearLayout). Prior to 
(|android.os.Build.VERSION_CODES|) this method should be followed by calls to 
(|android.view.View|) and (|android.view.View|) on the view's parent to force 
the parent to redraw with the new child ordering. 



*android.view.View.buildDrawingCache()*

public void buildDrawingCache()

Calling this method is equivalent to calling buildDrawingCache(false). 



*android.view.View.buildDrawingCache(boolean)*

public void buildDrawingCache(boolean autoScale)

Forces the drawing cache to be built if the drawing cache is invalid. 

If you call (|android.view.View|) manually without calling 
setDrawingCacheEnabled(true)(|android.view.View|) , you should cleanup the 
cache by calling (|android.view.View|) afterwards. 

Note about auto scaling in compatibility mode: When auto scaling is not 
enabled, this method will create a bitmap of the same size as this view. 
Because this bitmap will be drawn scaled by the parent ViewGroup, the result on 
screen might show scaling artifacts. To avoid such artifacts, you should call 
this method by setting the auto scaling to true. Doing so, however, will 
generate a bitmap of a different size than the view. This implies that your 
application must be able to handle this size. 

You should avoid calling this method when hardware acceleration is enabled. If 
you do not need the drawing cache bitmap, calling this method will increase 
memory usage and cause the view to be rendered in software once, thus 
negatively impacting performance. 



*android.view.View.buildLayer()*

public void buildLayer()

Forces this view's layer to be created and this view to be rendered into its 
layer. If this view's layer type is set to (|android.view.View|) , invoking 
this method will have no effect. 

This method can for instance be used to render a view into its layer before 
starting an animation. If this view is complex, rendering into the layer before 
starting the animation will avoid skipping frames. 



*android.view.View.callOnClick()*

public boolean callOnClick()

Directly call any attached OnClickListener. Unlike (|android.view.View|) , this 
only calls the listener, and does not do any associated clicking actions like 
reporting an accessibility event. 



    Returns: True there was an assigned OnClickListener that was called, false otherwise is 
             returned. 

*android.view.View.cancelLongPress()*

public void cancelLongPress()

Cancels a pending long press. Your subclass can use this if you want the 
context menu to come up if the user presses and holds at the same place, but 
you don't want it to come up if they press and then move around enough to cause 
scrolling. 



*android.view.View.cancelPendingInputEvents()*

public final void cancelPendingInputEvents()

Cancel any deferred high-level input events that were previously posted to the 
event queue. 

Many views post high-level events such as click handlers to the event queue to 
run deferred in order to preserve a desired user experience - clearing visible 
pressed states before executing, etc. This method will abort any events of this 
nature that are currently in flight. 

Custom views that generate their own high-level deferred input events should 
override (|android.view.View|) and remove those pending events from the queue. 

This will also cancel pending input events for any child views. 

Note that this may not be sufficient as a debouncing strategy for clicks in all 
cases. This will not impact newer events posted after this call that may occur 
as a result of lower-level input events still waiting in the queue. If you are 
trying to prevent double-submitted events for the duration of some sort of 
asynchronous transaction you should also take other steps to protect against 
unexpected double inputs e.g. calling setEnabled(false)(|android.view.View|) 
and re-enabling the view when the transaction completes, tracking already 
submitted transaction IDs, etc. 



*android.view.View.canHaveDisplayList()*

public boolean canHaveDisplayList()

A view that is not attached or hardware accelerated cannot create a display 
list. This method checks these conditions and returns the appropriate result. 



    Returns: true if view has the ability to create a display list, false otherwise. 

*android.view.View.canResolveLayoutDirection()*

public boolean canResolveLayoutDirection()

Check if layout direction resolution can be done. 



    Returns: true if layout direction resolution can be done otherwise return false. 

*android.view.View.canResolveTextAlignment()*

public boolean canResolveTextAlignment()

Check if text alignment resolution can be done. 



    Returns: true if text alignment resolution can be done otherwise return false. 

*android.view.View.canResolveTextDirection()*

public boolean canResolveTextDirection()

Check if text direction resolution can be done. 



    Returns: true if text direction resolution can be done otherwise return false. 

*android.view.View.canScrollHorizontally(int)*

public boolean canScrollHorizontally(int direction)

Check if this view can be scrolled horizontally in a certain direction. 


    direction - Negative to check scrolling left, positive to check scrolling right. 

    Returns: true if this view can be scrolled in the specified direction, false otherwise. 

*android.view.View.canScrollVertically(int)*

public boolean canScrollVertically(int direction)

Check if this view can be scrolled vertically in a certain direction. 


    direction - Negative to check scrolling up, positive to check scrolling down. 

    Returns: true if this view can be scrolled in the specified direction, false otherwise. 

*android.view.View.checkInputConnectionProxy(View)*

public boolean checkInputConnectionProxy(android.view.View view)

Called by the (|android.view.inputmethod.InputMethodManager|) when a view who 
is not the current input connection target is trying to make a call on the 
manager. The default implementation returns false; you can override this to 
return true for certain views if you are performing InputConnection proxying to 
them. 


    view - The View that is making the InputMethodManager call. 

    Returns: Return true to allow the call, false to reject. 

*android.view.View.clearAccessibilityFocus()*

public void clearAccessibilityFocus()

Call this to try to clear accessibility focus of this view. 

See also (|android.view.View|) , which is what you call to say that you have 
focus, and you want your parent to look for the next one. 



*android.view.View.clearAnimation()*

public void clearAnimation()

Cancels any animations for this view. 



*android.view.View.clearFocus()*

public void clearFocus()

Called when this view wants to give up focus. If focus is cleared 
(|android.view.View|) is called. 

Note: When a View clears focus the framework is trying to give focus to the 
first focusable View from the top. Hence, if this View is the first from the 
top that can take focus, then all callbacks related to clearing focus will be 
invoked after wich the framework will give focus to this view. 



*android.view.View.combineMeasuredStates(int,int)*

public static int combineMeasuredStates(
  int curState,
  int newState)

Merge two states as returned by (|android.view.View|) . 


    curState - The current state as returned from a view or the result of combining multiple 
       views. 
    newState - The new view state to combine. 

    Returns: Returns a new integer reflecting the combination of the two states. 

*android.view.View.computeFitSystemWindows(Rect,Rect)*

protected boolean computeFitSystemWindows(
  Rect inoutInsets,
  Rect outLocalInsets)





*android.view.View.computeHorizontalScrollExtent()*

protected int computeHorizontalScrollExtent()

Compute the horizontal extent of the horizontal scrollbar's thumb within the 
horizontal range. This value is used to compute the length of the thumb within 
the scrollbar's track. 

The range is expressed in arbitrary units that must be the same as the units 
used by (|android.view.View|) and (|android.view.View|) . 

The default extent is the drawing width of this view. 



    Returns: the horizontal extent of the scrollbar's thumb 

*android.view.View.computeHorizontalScrollOffset()*

protected int computeHorizontalScrollOffset()

Compute the horizontal offset of the horizontal scrollbar's thumb within the 
horizontal range. This value is used to compute the position of the thumb 
within the scrollbar's track. 

The range is expressed in arbitrary units that must be the same as the units 
used by (|android.view.View|) and (|android.view.View|) . 

The default offset is the scroll offset of this view. 



    Returns: the horizontal offset of the scrollbar's thumb 

*android.view.View.computeHorizontalScrollRange()*

protected int computeHorizontalScrollRange()

Compute the horizontal range that the horizontal scrollbar represents. 

The range is expressed in arbitrary units that must be the same as the units 
used by (|android.view.View|) and (|android.view.View|) . 

The default range is the drawing width of this view. 



    Returns: the total horizontal range represented by the horizontal scrollbar 

*android.view.View.computeOpaqueFlags()*

protected void computeOpaqueFlags()





*android.view.View.computeScroll()*

public void computeScroll()

Called by a parent to request that a child update its values for mScrollX and 
mScrollY if necessary. This will typically be done if the child is animating a 
scroll using a Scroller(|android.widget.Scroller|) object. 



*android.view.View.computeVerticalScrollExtent()*

protected int computeVerticalScrollExtent()

Compute the vertical extent of the horizontal scrollbar's thumb within the 
vertical range. This value is used to compute the length of the thumb within 
the scrollbar's track. 

The range is expressed in arbitrary units that must be the same as the units 
used by (|android.view.View|) and (|android.view.View|) . 

The default extent is the drawing height of this view. 



    Returns: the vertical extent of the scrollbar's thumb 

*android.view.View.computeVerticalScrollOffset()*

protected int computeVerticalScrollOffset()

Compute the vertical offset of the vertical scrollbar's thumb within the 
horizontal range. This value is used to compute the position of the thumb 
within the scrollbar's track. 

The range is expressed in arbitrary units that must be the same as the units 
used by (|android.view.View|) and (|android.view.View|) . 

The default offset is the scroll offset of this view. 



    Returns: the vertical offset of the scrollbar's thumb 

*android.view.View.computeVerticalScrollRange()*

protected int computeVerticalScrollRange()

Compute the vertical range that the vertical scrollbar represents. 

The range is expressed in arbitrary units that must be the same as the units 
used by (|android.view.View|) and (|android.view.View|) . 



    Returns: the total vertical range represented by the vertical scrollbar 

The default range is the drawing height of this view. 

*android.view.View.createAccessibilityNodeInfo()*

public |android.view.accessibility.AccessibilityNodeInfo| createAccessibilityNodeInfo()

Returns an (|android.view.accessibility.AccessibilityNodeInfo|) representing 
this view from the point of view of an 
(|android.accessibilityservice.AccessibilityService|) . This method is 
responsible for obtaining an accessibility node info from a pool of reusable 
instances and calling (|android.view.View|) on this view to initialize the 
former. 

Note: The client is responsible for recycling the obtained instance by calling 
(|android.view.accessibility.AccessibilityNodeInfo|) to minimize object 
creation. 



    Returns: A populated {@link AccessibilityNodeInfo}. 

*android.view.View.createContextMenu(ContextMenu)*

public void createContextMenu(android.view.ContextMenu menu)

Show the context menu for this view. It is not safe to hold on to the menu 
after returning from this method. 

You should normally not overload this method. Overload (|android.view.View|) or 
define an (|android.view.View.OnCreateContextMenuListener|) to add items to the 
context menu. 


    menu - The context menu to populate 

*android.view.View.debug()*

public void debug()

Prints information about this view in the log output, with the tag 
(|android.view.View|) . 



*android.view.View.debug(int)*

protected void debug(int depth)

Prints information about this view in the log output, with the tag 
(|android.view.View|) . Each line in the output is preceded with an indentation 
defined by the depth. 


    depth - the indentation level 

*android.view.View.debugIndent(int)*

protected static |java.lang.String| debugIndent(int depth)

Creates a string of whitespaces used for indentation. 


    depth - the indentation level 

    Returns: a String containing (depth * 2 + 3) * 2 white spaces 

*android.view.View.destroyDrawingCache()*

public void destroyDrawingCache()

Frees the resources used by the drawing cache. If you call 
(|android.view.View|) manually without calling 
setDrawingCacheEnabled(true)(|android.view.View|) , you should cleanup the 
cache with this method afterwards. 



*android.view.View.destroyHardwareResources()*

protected void destroyHardwareResources()

Destroys all hardware rendering resources. This method is invoked when the 
system needs to reclaim resources. Upon execution of this method, you should 
free any OpenGL resources created by the view. 

Note: you must call super.destroyHardwareResources() when overriding this 
method. 



*android.view.View.dispatchConfigurationChanged(Configuration)*

public void dispatchConfigurationChanged(android.content.res.Configuration newConfig)

Dispatch a notification about a resource configuration change down the view 
hierarchy. ViewGroups should override to route to their children. 


    newConfig - The new resource configuration. 

*android.view.View.dispatchDisplayHint(int)*

public void dispatchDisplayHint(int hint)

Dispatch a hint about whether this view is displayed. For instance, when a View 
moves out of the screen, it might receives a display hint indicating the view 
is not displayed. Applications should not rely on this hint as there is no 
guarantee that they will receive one. 


    hint - A hint about whether or not this view is displayed: {@link #VISIBLE} or {@link 
       #INVISIBLE}. 

*android.view.View.dispatchDragEvent(DragEvent)*

public boolean dispatchDragEvent(android.view.DragEvent event)

Detects if this View is enabled and has a drag event listener. If both are 
true, then it calls the drag event listener with the (|android.view.DragEvent|) 
it received. If the drag event listener returnstrue, then dispatchDragEvent() 
returnstrue. 

For all other cases, the method calls the onDragEvent()(|android.view.View|) 
drag event handler method and returns its result. 

This ensures that a drag event is always consumed, even if the View does not 
have a drag event listener. However, if the View has a listener and the 
listener returns true, then onDragEvent() is not called. 



*android.view.View.dispatchDraw(Canvas)*

protected void dispatchDraw(Canvas canvas)

Called by draw to draw the child views. This may be overridden by derived 
classes to gain control just before its children are drawn (but after its own 
view has been drawn). 


    canvas - the canvas on which to draw the view 

*android.view.View.dispatchFinishTemporaryDetach()*

public void dispatchFinishTemporaryDetach()





*android.view.View.dispatchGenericFocusedEvent(MotionEvent)*

protected boolean dispatchGenericFocusedEvent(android.view.MotionEvent event)

Dispatch a generic motion event to the currently focused view. 

Do not call this method directly. Call (|android.view.View|) instead. 


    event - The motion event to be dispatched. 

    Returns: True if the event was handled by the view, false otherwise. 

*android.view.View.dispatchGenericMotionEvent(MotionEvent)*

public boolean dispatchGenericMotionEvent(android.view.MotionEvent event)

Dispatch a generic motion event. 

Generic motion events with source class (|android.view.InputDevice|) are 
delivered to the view under the pointer. All other generic motion events are 
delivered to the focused view. Hover events are handled specially and are 
delivered to (|android.view.View|) . 


    event - The motion event to be dispatched. 

    Returns: True if the event was handled by the view, false otherwise. 

*android.view.View.dispatchGenericPointerEvent(MotionEvent)*

protected boolean dispatchGenericPointerEvent(android.view.MotionEvent event)

Dispatch a generic motion event to the view under the first pointer. 

Do not call this method directly. Call (|android.view.View|) instead. 


    event - The motion event to be dispatched. 

    Returns: True if the event was handled by the view, false otherwise. 

*android.view.View.dispatchGetDisplayList()*

protected void dispatchGetDisplayList()

This method is used by ViewGroup to cause its children to restore or recreate 
their display lists. It is called by getDisplayList() when the parent ViewGroup 
does not need to recreate its own display list, which would happen if it went 
through the normal draw/dispatchDraw mechanisms. 



*android.view.View.dispatchHoverEvent(MotionEvent)*

protected boolean dispatchHoverEvent(android.view.MotionEvent event)

Dispatch a hover event. 

Do not call this method directly. Call (|android.view.View|) instead. 


    event - The motion event to be dispatched. 

    Returns: True if the event was handled by the view, false otherwise. 

*android.view.View.dispatchKeyEvent(KeyEvent)*

public boolean dispatchKeyEvent(android.view.KeyEvent event)

Dispatch a key event to the next view on the focus path. This path runs from 
the top of the view tree down to the currently focused view. If this view has 
focus, it will dispatch to itself. Otherwise it will dispatch the next node 
down the focus path. This method also fires any key listeners. 


    event - The key event to be dispatched. 

    Returns: True if the event was handled, false otherwise. 

*android.view.View.dispatchKeyEventPreIme(KeyEvent)*

public boolean dispatchKeyEventPreIme(android.view.KeyEvent event)

Dispatch a key event before it is processed by any input method associated with 
the view hierarchy. This can be used to intercept key events in special 
situations before the IME consumes them; a typical example would be handling 
the BACK key to update the application's UI instead of allowing the IME to see 
it and close itself. 


    event - The key event to be dispatched. 

    Returns: True if the event was handled, false otherwise. 

*android.view.View.dispatchKeyShortcutEvent(KeyEvent)*

public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)

Dispatches a key shortcut event. 


    event - The key event to be dispatched. 

    Returns: True if the event was handled by the view, false otherwise. 

*android.view.View.dispatchPointerEvent(MotionEvent)*

public final boolean dispatchPointerEvent(android.view.MotionEvent event)

Dispatch a pointer event. 

Dispatches touch related pointer events to (|android.view.View|) and all other 
events to (|android.view.View|) . This separation of concerns reinforces the 
invariant that (|android.view.View|) is really about touches and should not be 
expected to handle other pointing device features. 


    event - The motion event to be dispatched. 

    Returns: True if the event was handled by the view, false otherwise. 

*android.view.View.dispatchPopulateAccessibilityEvent(AccessibilityEvent)*

public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)

Dispatches an (|android.view.accessibility.AccessibilityEvent|) to the 
(|android.view.View|) first and then to its children for adding their text 
content to the event. Note that the event text is populated in a separate 
dispatch path since we add to the event not only the text of the source but 
also the text of all its descendants. A typical implementation will call 
(|android.view.View|) on the this view and then call the (|android.view.View|) 
on each child. Override this method if custom population of the event text 
content is required. 

If an (|android.view.View.AccessibilityDelegate|) has been specified via 
calling (|android.view.View|) its (|android.view.View.AccessibilityDelegate|) 
is responsible for handling this call. 

Note: Accessibility events of certain types are not dispatched for populating 
the event text via this method. For details refer to 
(|android.view.accessibility.AccessibilityEvent|) . 


    event - The event. 

    Returns: True if the event population was completed. 

*android.view.View.dispatchRestoreInstanceState(SparseArray<Parcelable>)*

protected void dispatchRestoreInstanceState(android.util.SparseArray<android.os.Parcelable> container)

Called by (|android.view.View|) to retrieve the state for this view and its 
children. May be overridden to modify how restoring happens to a view's 
children; for example, some views may want to not store state for their 
children. 


    container - The SparseArray which holds previously saved state. 

*android.view.View.dispatchSaveInstanceState(SparseArray<Parcelable>)*

protected void dispatchSaveInstanceState(android.util.SparseArray<android.os.Parcelable> container)

Called by (|android.view.View|) to store the state for this view and its 
children. May be overridden to modify how freezing happens to a view's 
children; for example, some views may want to not store state for their 
children. 


    container - The SparseArray in which to save the view's state. 

*android.view.View.dispatchSetActivated(boolean)*

protected void dispatchSetActivated(boolean activated)

Dispatch setActivated to all of this View's children. 


    activated - The new activated state 

*android.view.View.dispatchSetPressed(boolean)*

protected void dispatchSetPressed(boolean pressed)

Dispatch setPressed to all of this View's children. 


    pressed - The new pressed state 

*android.view.View.dispatchSetSelected(boolean)*

protected void dispatchSetSelected(boolean selected)

Dispatch setSelected to all of this View's children. 


    selected - The new selected state 

*android.view.View.dispatchStartTemporaryDetach()*

public void dispatchStartTemporaryDetach()





*android.view.View.dispatchSystemUiVisibilityChanged(int)*

public void dispatchSystemUiVisibilityChanged(int visibility)

Dispatch callbacks to (|android.view.View|) down the view hierarchy. 



*android.view.View.dispatchTouchEvent(MotionEvent)*

public boolean dispatchTouchEvent(android.view.MotionEvent event)

Pass the touch screen motion event down to the target view, or this view if it 
is the target. 


    event - The motion event to be dispatched. 

    Returns: True if the event was handled by the view, false otherwise. 

*android.view.View.dispatchTrackballEvent(MotionEvent)*

public boolean dispatchTrackballEvent(android.view.MotionEvent event)

Pass a trackball motion event down to the focused view. 


    event - The motion event to be dispatched. 

    Returns: True if the event was handled by the view, false otherwise. 

*android.view.View.dispatchUnhandledMove(View,int)*

public boolean dispatchUnhandledMove(
  android.view.View focused,
  int direction)

This method is the last chance for the focused view and its ancestors to 
respond to an arrow key. This is called when the focused view did not consume 
the key internally, nor could the view system find a new view in the requested 
direction to give focus to. 


    focused - The currently focused view. 
    direction - The direction focus wants to move. One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and 
       FOCUS_RIGHT. 

    Returns: True if the this view consumed this unhandled move. 

*android.view.View.dispatchVisibilityChanged(View,int)*

protected void dispatchVisibilityChanged(
  android.view.View changedView,
  int visibility)

Dispatch a view visibility change down the view hierarchy. ViewGroups should 
override to route to their children. 


    changedView - The view whose visibility changed. Could be 'this' or an ancestor view. 
    visibility - The new visibility of changedView: {@link #VISIBLE}, {@link #INVISIBLE} or 
       {@link #GONE}. 

*android.view.View.dispatchWindowFocusChanged(boolean)*

public void dispatchWindowFocusChanged(boolean hasFocus)

Called when the window containing this view gains or loses window focus. 
ViewGroups should override to route to their children. 


    hasFocus - True if the window containing this view now has focus, false otherwise. 

*android.view.View.dispatchWindowSystemUiVisiblityChanged(int)*

public void dispatchWindowSystemUiVisiblityChanged(int visible)

Dispatch callbacks to (|android.view.View|) down the view hierarchy. 



*android.view.View.dispatchWindowVisibilityChanged(int)*

public void dispatchWindowVisibilityChanged(int visibility)

Dispatch a window visibility change down the view hierarchy. ViewGroups should 
override to route to their children. 


    visibility - The new visibility of the window. 

*android.view.View.draw(Canvas)*

public void draw(Canvas canvas)

Manually render this view (and all of its children) to the given Canvas. The 
view must have already done a full layout before this function is called. When 
implementing a view, implement (|android.view.View|) instead of overriding this 
method. If you do need to override this method, call the superclass version. 


    canvas - The Canvas to which the View is rendered. 

*android.view.View.drawableStateChanged()*

protected void drawableStateChanged()

This function is called whenever the state of the view changes in such a way 
that it impacts the state of drawables being shown. 

Be sure to call through to the superclass when overriding this function. 



*android.view.View.executeHardwareAction(Runnable)*

public boolean executeHardwareAction(java.lang.Runnable action)

This method ensures the hardware renderer is in a valid state before executing 
the specified action. 

This method will attempt to set a valid state even if the window the renderer 
is attached to was destroyed. 

This method is not guaranteed to work. If the hardware renderer does not exist 
or cannot be put in a valid state, this method will not executed the specified 
action. 

The specified action is executed synchronously. 


    action - The action to execute after the renderer is in a valid state 

    Returns: True if the specified Runnable was executed, false otherwise 

*android.view.View.findFocus()*

public |android.view.View| findFocus()

Find the view in the hierarchy rooted at this view that currently has focus. 



    Returns: The view that currently has focus, or null if no focused view can be found. 

*android.view.View.findViewByAccessibilityIdTraversal(int)*

public |android.view.View| findViewByAccessibilityIdTraversal(int accessibilityId)

Performs the traversal to find a view by its unuque and stable accessibility 
id. 

Note:This method does not stop at the root namespace boundary since the user 
can touch the screen at an arbitrary location potentially crossing the root 
namespace bounday which will send an accessibility event to accessibility 
services and they should be able to obtain the event source. Also accessibility 
ids are guaranteed to be unique in the window. 


    accessibilityId - The accessibility id. 

    Returns: The found view. 

*android.view.View.findViewById(int)*

public final |android.view.View| findViewById(int id)

Look for a child view with the given id. If this view has the given id, return 
this view. 


    id - The id to search for. 

    Returns: The view that has the given id in the hierarchy or null 

*android.view.View.findViewByPredicate(Predicate<View>)*

public final |android.view.View| findViewByPredicate(com.android.internal.util.Predicate<android.view.View> predicate)

Look for a child view that matches the specified predicate. If this view 
matches the predicate, return this view. 


    predicate - The predicate to evaluate. 

    Returns: The first view that matches the predicate or null. 

*android.view.View.findViewByPredicateInsideOut(View,Predicate<View>)*

public final |android.view.View| findViewByPredicateInsideOut(
  android.view.View start,
  com.android.internal.util.Predicate<android.view.View> predicate)

Look for a child view that matches the specified predicate, starting with the 
specified view and its descendents and then recusively searching the ancestors 
and siblings of that view until this view is reached. 

This method is useful in cases where the predicate does not match a single 
unique view (perhaps multiple views use the same id) and we are trying to find 
the view that is "closest" in scope to the starting view. 


    start - The view to start from. 
    predicate - The predicate to evaluate. 

    Returns: The first view that matches the predicate or null. 

*android.view.View.findViewByPredicateTraversal(Predicate<View>,View)*

protected |android.view.View| findViewByPredicateTraversal(
  com.android.internal.util.Predicate<android.view.View> predicate,
  android.view.View childToSkip)




    predicate - The predicate to evaluate. 
    childToSkip - If not null, ignores this child during the recursive traversal. 

    Returns: The first view that matches the predicate or null. 

*android.view.View.findViewsWithText(ArrayList<View>,CharSequence,int)*

public void findViewsWithText(
  java.util.ArrayList<android.view.View> outViews,
  java.lang.CharSequence searched,
  int flags)

Finds the Views that contain given text. The containment is case insensitive. 
The search is performed by either the text that the View renders or the content 
description that describes the view for accessibility purposes and the view 
does not render or both. Clients can specify how the search is to be performed 
via passing the (|android.view.View|) and (|android.view.View|) flags. 


    outViews - The output list of matching Views. 
    searched - The text to match against. 

*android.view.View.findViewTraversal(int)*

protected |android.view.View| findViewTraversal(int id)




    id - the id of the view to be found 

    Returns: the view of the specified id, null if cannot be found 

*android.view.View.findViewWithTag(Object)*

public final |android.view.View| findViewWithTag(java.lang.Object tag)

Look for a child view with the given tag. If this view has the given tag, 
return this view. 


    tag - The tag to search for, using "tag.equals(getTag())". 

    Returns: The View that has the given tag in the hierarchy or null 

*android.view.View.findViewWithTagTraversal(Object)*

protected |android.view.View| findViewWithTagTraversal(java.lang.Object tag)




    tag - the tag of the view to be found 

    Returns: the view of specified tag, null if cannot be found 

*android.view.View.fitsSystemWindows()*

public boolean fitsSystemWindows()





*android.view.View.fitSystemWindows(Rect)*

protected boolean fitSystemWindows(Rect insets)

Called by the view hierarchy when the content insets for a window have changed, 
to allow it to adjust its content to fit within those windows. The content 
insets tell you the space that the status bar, input method, and other system 
windows infringe on the application's window. 

You do not normally need to deal with this function, since the default window 
decoration given to applications takes care of applying it to the content of 
the window. If you use (|android.view.View|) or (|android.view.View|) this will 
not be the case, and your content can be placed under those system elements. 
You can then use this method within your view hierarchy if you have parts of 
your UI which you would like to ensure are not being covered. 

The default implementation of this method simply applies the content insets to 
the view's padding, consuming that content (modifying the insets to be 0), and 
returning true. This behavior is off by default, but can be enabled through 
(|android.view.View|) . 

This function's traversal down the hierarchy is depth-first. The same content 
insets object is propagated down the hierarchy, so any changes made to it will 
be seen by all following views (including potentially ones above in the 
hierarchy since this is a depth-first traversal). The first view that returns 
true will abort the entire traversal. 

The default implementation works well for a situation where it is used with a 
container that covers the entire window, allowing it to apply the appropriate 
insets to its content on all edges. If you need a more complicated layout (such 
as two different views fitting system windows, one on the top of the window, 
and one on the bottom), you can override the method and handle the insets 
however you would like. Note that the insets provided by the framework are 
always relative to the far edges of the window, not accounting for the location 
of the called view within that window. (In fact when this method is called you 
do not yet know where the layout will place the view, as it is done before 
layout happens.) 

Note: unlike many View methods, there is no dispatch phase to this call. If you 
are overriding it in a ViewGroup and want to allow the call to continue to your 
children, you must be sure to call the super implementation. 

Here is a sample layout that makes use of fitting system windows to have 
controls for a video view placed inside of the window decorations that it hides 
and shows. This can be used with code like the second sample (video player) 
shown in (|android.view.View|) 
.development/samples/ApiDemos/res/layout/video_player.xml complete 


    insets - Current content insets of the window. Prior to {@link 
       android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify the 
       insets or else you and Android will be unhappy. 

    Returns: {@code true} if this view applied the insets and it should not continue 
             propagating further down the hierarchy, {@code false} otherwise. 

*android.view.View.focusSearch(int)*

public |android.view.View| focusSearch(int direction)

Find the nearest view in the specified direction that can take focus. This does 
not actually give focus to that view. 


    direction - One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT 

    Returns: The nearest focusable in the specified direction, or null if none can be found. 

*android.view.View.forceLayout()*

public void forceLayout()

Forces this view to be laid out during the next layout pass. This method does 
not call requestLayout() or forceLayout() on the parent. 



*android.view.View.gatherTransparentRegion(Region)*

public boolean gatherTransparentRegion(Region region)

This is used by the RootView to perform an optimization when the view hierarchy 
contains one or several SurfaceView. SurfaceView is always considered 
transparent, but its children are not, therefore all View objects remove 
themselves from the global transparent region (passed as a parameter to this 
function). 


    region - The transparent region for this ViewAncestor (window). 

    Returns: Returns true if the effective visibility of the view at this point is opaque, 
             regardless of the transparent region; returns false if it is 
             possible for underlying windows to be seen behind the view. 



*android.view.View.generateViewId()*

public static int generateViewId()

Generate a value suitable for use in (|android.view.View|) . This value will 
not collide with ID values generated at build time by aapt for R.id. 



    Returns: a generated ID value 

*android.view.View.getAccessibilityDelegate()*

public |android.view.View.AccessibilityDelegate| getAccessibilityDelegate()

Returns the delegate for implementing accessibility support via composition. 
For more details see (|android.view.View.AccessibilityDelegate|) . 



    Returns: The delegate, or null if none set. 

*android.view.View.getAccessibilityLiveRegion()*

public int getAccessibilityLiveRegion()

Gets the live region mode for this View. 



    Returns: The live region mode for the view. 

*android.view.View.getAccessibilityNodeProvider()*

public |android.view.accessibility.AccessibilityNodeProvider| getAccessibilityNodeProvider()

Gets the provider for managing a virtual view hierarchy rooted at this View and 
reported to (|android.accessibilityservice.AccessibilityService|) s that 
explore the window content. 

If this method returns an instance, this instance is responsible for managing 
(|android.view.accessibility.AccessibilityNodeInfo|) s describing the virtual 
sub-tree rooted at this View including the one representing the View itself. 
Similarly the returned instance is responsible for performing accessibility 
actions on any virtual view or the root view itself. 

If an (|android.view.View.AccessibilityDelegate|) has been specified via 
calling (|android.view.View|) its (|android.view.View.AccessibilityDelegate|) 
is responsible for handling this call. 



    Returns: The provider. 

*android.view.View.getAccessibilitySelectionEnd()*

public int getAccessibilitySelectionEnd()





*android.view.View.getAccessibilitySelectionStart()*

public int getAccessibilitySelectionStart()





*android.view.View.getAccessibilityViewId()*

public int getAccessibilityViewId()

Gets the unique identifier of this view on the screen for accessibility 
purposes. If this (|android.view.View|) is not attached to any window,#NO_IDis 
returned. 



    Returns: The view accessibility id. 

*android.view.View.getAccessibilityWindowId()*

public int getAccessibilityWindowId()

Gets the unique identifier of the window in which this View reseides. 



    Returns: The window accessibility id. 

*android.view.View.getAlpha()*

public float getAlpha()

The opacity of the view. This is a value from 0 to 1, where 0 means the view is 
completely transparent and 1 means the view is completely opaque. 

By default this is 1.0f. 



    Returns: The opacity of the view. 

*android.view.View.getAnimation()*

public |android.view.animation.Animation| getAnimation()

Get the animation currently associated with this view. 



    Returns: The animation that is currently playing or scheduled to play for this view. 

*android.view.View.getApplicationWindowToken()*

public |android.os.IBinder| getApplicationWindowToken()

Retrieve a unique token identifying the top-level "real" window of the window 
that this view is attached to. That is, this is like (|android.view.View|) , 
except if the window this view in is a panel window (attached to another 
containing window), then the token of the containing window is returned 
instead. 



    Returns: Returns the associated window token, either {@link #getWindowToken()} or the 
             containing window's token. 

*android.view.View.getBackground()*

public Drawable getBackground()

Gets the background drawable 



    Returns: The drawable used as the background for this view, if any. 

*android.view.View.getBaseline()*

public int getBaseline()

Return the offset of the widget's text baseline from the widget's top boundary. 
If this widget does not support baseline alignment, this method returns -1. 



    Returns: the offset of the baseline within the widget's bounds or -1 if baseline 
             alignment is not supported 

*android.view.View.getBottom()*

public final int getBottom()

Bottom position of this view relative to its parent. 



    Returns: The bottom of this view, in pixels. 

*android.view.View.getBottomFadingEdgeStrength()*

protected float getBottomFadingEdgeStrength()

Returns the strength, or intensity, of the bottom faded edge. The strength is a 
value between 0.0 (no fade) and 1.0 (full fade). The default implementation 
returns 0.0 or 1.0 but no value in between. 

Subclasses should override this method to provide a smoother fade transition 
when scrolling occurs. 



    Returns: the intensity of the bottom fade as a float between 0.0f and 1.0f 

*android.view.View.getBottomPaddingOffset()*

protected int getBottomPaddingOffset()

Amount by which to extend the bottom fading region. Called only when 
(|android.view.View|) returns true. 



    Returns: The bottom padding offset in pixels. 

*android.view.View.getCameraDistance()*

public float getCameraDistance()

Gets the distance along the Z axis from the camera to this view. 



    Returns: The distance along the Z axis. 

*android.view.View.getClipBounds()*

public Rect getClipBounds()

Returns a copy of the current clipBounds(|android.view.View|) . 



    Returns: A copy of the current clip bounds if clip bounds are set, otherwise null. 

*android.view.View.getContentDescription()*

public |java.lang.CharSequence| getContentDescription()

Gets the (|android.view.View|) description. It briefly describes the view and 
is primarily used for accessibility support. Set this property to enable better 
accessibility support for your application. This is especially true for views 
that do not have textual representation (For example, ImageButton). 



    Returns: The content description. 

*android.view.View.getContext()*

public final |android.content.Context| getContext()

Returns the context the view is running in, through which it can access the 
current theme, resources, etc. 



    Returns: The view's Context. 

*android.view.View.getContextMenuInfo()*

protected |android.view.ContextMenu.ContextMenuInfo| getContextMenuInfo()

Views should implement this if they have extra information to associate with 
the context menu. The return result is supplied as a parameter to the 
(|android.view.View.OnCreateContextMenuListener|) callback. 



    Returns: Extra information about the item for which the context menu should be shown. 
             This information will vary across different subclasses of View. 

*android.view.View.getDefaultSize(int,int)*

public static int getDefaultSize(
  int size,
  int measureSpec)

Utility to return a default size. Uses the supplied size if the MeasureSpec 
imposed no constraints. Will get larger if allowed by the MeasureSpec. 


    size - Default size for this view 
    measureSpec - Constraints imposed by the parent 

    Returns: The size this view should be. 

*android.view.View.getDisplay()*

public |android.view.Display| getDisplay()

Gets the logical display to which the view's window has been attached. 



    Returns: The logical display, or null if the view is not currently attached to a window. 

*android.view.View.getDisplayList()*

public |android.view.DisplayList| getDisplayList()

Returns a display list that can be used to draw this view again without 
executing its draw method. 



    Returns: A DisplayList ready to replay, or null if caching is not enabled. 

*android.view.View.getDrawableState()*

public final int[] getDrawableState()

Return an array of resource IDs of the drawable states representing the current 
state of the view. 



    Returns: The current drawable state 

*android.view.View.getDrawingCache()*

public Bitmap getDrawingCache()

Calling this method is equivalent to calling getDrawingCache(false). 



    Returns: A non-scaled bitmap representing this view or null if cache is disabled. 

*android.view.View.getDrawingCache(boolean)*

public Bitmap getDrawingCache(boolean autoScale)

Returns the bitmap in which this view drawing is cached. The returned bitmap is 
null when caching is disabled. If caching is enabled and the cache is not 
ready, this method will create it. Calling (|android.view.View|) will not draw 
from the cache when the cache is enabled. To benefit from the cache, you must 
request the drawing cache by calling this method and draw it on screen if the 
returned bitmap is not null. 

Note about auto scaling in compatibility mode: When auto scaling is not 
enabled, this method will create a bitmap of the same size as this view. 
Because this bitmap will be drawn scaled by the parent ViewGroup, the result on 
screen might show scaling artifacts. To avoid such artifacts, you should call 
this method by setting the auto scaling to true. Doing so, however, will 
generate a bitmap of a different size than the view. This implies that your 
application must be able to handle this size. 


    autoScale - Indicates whether the generated bitmap should be scaled based on the current 
       density of the screen when the application is in compatibility mode. 

    Returns: A bitmap representing this view or null if cache is disabled. 

*android.view.View.getDrawingCacheBackgroundColor()*

public int getDrawingCacheBackgroundColor()





    Returns: The background color to used for the drawing cache's bitmap 

*android.view.View.getDrawingCacheQuality()*

public int getDrawingCacheQuality()

Returns the quality of the drawing cache. 



    Returns: One of {@link #DRAWING_CACHE_QUALITY_AUTO}, {@link #DRAWING_CACHE_QUALITY_LOW}, 
             or {@link #DRAWING_CACHE_QUALITY_HIGH} 

*android.view.View.getDrawingRect(Rect)*

public void getDrawingRect(Rect outRect)

Return the visible drawing bounds of your view. Fills in the output rectangle 
with the values from getScrollX(), getScrollY(), getWidth(), and getHeight(). 
These bounds do not account for any transformation properties currently set on 
the view, such as (|android.view.View|) or (|android.view.View|) . 


    outRect - The (scrolled) drawing bounds of the view. 

*android.view.View.getDrawingTime()*

public long getDrawingTime()

Return the time at which the drawing of the view hierarchy started. 



    Returns: the drawing start time in milliseconds 

*android.view.View.getFadeHeight(boolean)*

protected int getFadeHeight(boolean offsetRequired)




    offsetRequired - 

*android.view.View.getFadeTop(boolean)*

protected int getFadeTop(boolean offsetRequired)




    offsetRequired - 

*android.view.View.getFilterTouchesWhenObscured()*

public boolean getFilterTouchesWhenObscured()

Gets whether the framework should discard touches when the view's window is 
obscured by another visible window. Refer to the (|android.view.View|) security 
documentation for more details. 



    Returns: True if touch filtering is enabled. 

*android.view.View.getFitsSystemWindows()*

public boolean getFitsSystemWindows()

Check for state of (|android.view.View|) . If this method returnstrue, the 
default implementation of (|android.view.View|) will be executed. 



    Returns: {@code true} if the default implementation of {@link #fitSystemWindows(Rect)} 
             will be executed. 

*android.view.View.getFocusables(int)*

public |java.util.ArrayList|<View> getFocusables(int direction)

Find and return all focusable views that are descendants of this view, possibly 
including this view if it is focusable itself. 


    direction - The direction of the focus 

    Returns: A list of focusable views 

*android.view.View.getFocusedRect(Rect)*

public void getFocusedRect(Rect r)

When a view has focus and the user navigates away from it, the next view is 
searched for starting from the rectangle filled in by this method. 

By default, the rectangle is the (|android.view.View|) ) of the view. However, 
if your view maintains some idea of internal selection, such as a cursor, or a 
selected row or column, you should override this method and fill in a more 
specific rectangle. 


    r - The rectangle to fill in, in this view's coordinates. 

*android.view.View.getGlobalVisibleRect(Rect)*

public final boolean getGlobalVisibleRect(Rect r)





*android.view.View.getGlobalVisibleRect(Rect,Point)*

public boolean getGlobalVisibleRect(
  Rect r,
  Point globalOffset)

If some part of this view is not clipped by any of its parents, then return 
that area in r in global (root) coordinates. To convert r to local coordinates 
(without taking possible View rotations into account), offset it by 
-globalOffset (e.g. r.offset(-globalOffset.x, -globalOffset.y)). If the view is 
completely clipped or translated out, return false. 


    r - If true is returned, r holds the global coordinates of the visible portion of 
       this view. 
    globalOffset - If true is returned, globalOffset holds the dx,dy between this view and its 
       root. globalOffet may be null. 

    Returns: true if r is non-empty (i.e. part of the view is visible at the root level. 

*android.view.View.getHandler()*

public |android.os.Handler| getHandler()





    Returns: A handler associated with the thread running the View. This handler can be used 
             to pump events in the UI events queue. 

*android.view.View.getHardwareRenderer()*

public |android.view.HardwareRenderer| getHardwareRenderer()





    Returns: The {@link HardwareRenderer} associated with that view or null if hardware 
             rendering is not supported or this view is not attached to a 
             window. 

*android.view.View.getHeight()*

public final int getHeight()

Return the height of your view. 



    Returns: The height of your view, in pixels. 

*android.view.View.getHitRect(Rect)*

public void getHitRect(Rect outRect)

Hit rectangle in parent's coordinates 


    outRect - The hit rectangle of the view. 

*android.view.View.getHorizontalFadingEdgeLength()*

public int getHorizontalFadingEdgeLength()

Returns the size of the horizontal faded edges used to indicate that more 
content in this view is visible. 



    Returns: The size in pixels of the horizontal faded edge or 0 if horizontal faded edges 
             are not enabled for this view. 

*android.view.View.getHorizontalScrollbarHeight()*

protected int getHorizontalScrollbarHeight()

Returns the height of the horizontal scrollbar. 



    Returns: The height in pixels of the horizontal scrollbar or 0 if there is no horizontal 
             scrollbar. 

*android.view.View.getHorizontalScrollFactor()*

protected float getHorizontalScrollFactor()

Gets a scale factor that determines the distance the view should scroll 
horizontally in response to (|android.view.MotionEvent|) . 



    Returns: The horizontal scroll scale factor. 

*android.view.View.getId()*

public int getId()

Returns this view's identifier. 



    Returns: a positive integer used to identify the view or {@link #NO_ID} if the view has 
             no ID 

*android.view.View.getImportantForAccessibility()*

public int getImportantForAccessibility()

Gets the mode for determining whether this View is important for accessibility 
which is if it fires accessibility events and if it is reported to 
accessibility services that query the screen. 



    Returns: The mode for determining whether a View is important for accessibility. 

*android.view.View.getIterableTextForAccessibility()*

public |java.lang.CharSequence| getIterableTextForAccessibility()

Gets the text reported for accessibility purposes. 



    Returns: The accessibility text. 

*android.view.View.getIteratorForGranularity(int)*

public |android.view.AccessibilityIterators.TextSegmentIterator| getIteratorForGranularity(int granularity)





*android.view.View.getKeepScreenOn()*

public boolean getKeepScreenOn()

Returns whether the screen should remain on, corresponding to the current value 
of (|android.view.View|) . 



    Returns: Returns true if {@link #KEEP_SCREEN_ON} is set. 

*android.view.View.getKeyDispatcherState()*

public |android.view.KeyEvent.DispatcherState| getKeyDispatcherState()

Return the global 
KeyEvent.DispatcherState(|android.view.KeyEvent.DispatcherState|) for this 
view's window. Returns null if the view is not currently attached to the 
window. Normally you will not need to use this directly, but just use the 
standard high-level event callbacks like (|android.view.View|) . 



*android.view.View.getLabelFor()*

public int getLabelFor()

Gets the id of a view for which this view serves as a label for accessibility 
purposes. 



    Returns: The labeled view id. 

*android.view.View.getLayerType()*

public int getLayerType()

Indicates what type of layer is currently associated with this view. By default 
a view does not have a layer, and the layer type is (|android.view.View|) . 
Refer to the documentation of (|android.view.View|) for more information on the 
different types of layers. 



    Returns: {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or {@link 
             #LAYER_TYPE_HARDWARE} 

*android.view.View.getLayoutDirection()*

public int getLayoutDirection()

Returns the resolved layout direction for this view. 



    Returns: {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns {@link 
             #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL. 

For compatibility, this will return {@link #LAYOUT_DIRECTION_LTR} if API 
             version is lower than {@link 
             android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}. 

*android.view.View.getLayoutParams()*

public |android.view.ViewGroup.LayoutParams| getLayoutParams()

Get the LayoutParams associated with this view. All views should have layout 
parameters. These supply parameters to the parent of this view specifying how 
it should be arranged. There are many subclasses of ViewGroup.LayoutParams, and 
these correspond to the different subclasses of ViewGroup that are responsible 
for arranging their children. 

This method may return null if this View is not attached to a parent ViewGroup 
or (|android.view.View|) was not invoked successfully. When a View is attached 
to a parent ViewGroup, this method must not return null. 



    Returns: The LayoutParams associated with this view, or null if no parameters have been 
             set yet 

*android.view.View.getLeft()*

public final int getLeft()

Left position of this view relative to its parent. 



    Returns: The left edge of this view, in pixels. 

*android.view.View.getLeftFadingEdgeStrength()*

protected float getLeftFadingEdgeStrength()

Returns the strength, or intensity, of the left faded edge. The strength is a 
value between 0.0 (no fade) and 1.0 (full fade). The default implementation 
returns 0.0 or 1.0 but no value in between. 

Subclasses should override this method to provide a smoother fade transition 
when scrolling occurs. 



    Returns: the intensity of the left fade as a float between 0.0f and 1.0f 

*android.view.View.getLeftPaddingOffset()*

protected int getLeftPaddingOffset()

Amount by which to extend the left fading region. Called only when 
(|android.view.View|) returns true. 



    Returns: The left padding offset in pixels. 

*android.view.View.getLocalVisibleRect(Rect)*

public final boolean getLocalVisibleRect(Rect r)





*android.view.View.getLocationInWindow(int[])*

public void getLocationInWindow(int[] location)

Computes the coordinates of this view in its window. The argument must be an 
array of two integers. After the method returns, the array contains the x and y 
location in that order. 


    location - an array of two integers in which to hold the coordinates 

*android.view.View.getLocationOnScreen(int[])*

public void getLocationOnScreen(int[] location)

Computes the coordinates of this view on the screen. The argument must be an 
array of two integers. After the method returns, the array contains the x and y 
location in that order. 


    location - an array of two integers in which to hold the coordinates 

*android.view.View.getMatrix()*

public Matrix getMatrix()

The transform matrix of this view, which is calculated based on the current 
roation, scale, and pivot properties. 



    Returns: The current transform matrix for the view 

*android.view.View.getMeasuredHeight()*

public final int getMeasuredHeight()

Like (|android.view.View|) , but only returns the raw width component (that is 
the result is masked by (|android.view.View|) ). 



    Returns: The raw measured height of this view. 

*android.view.View.getMeasuredHeightAndState()*

public final int getMeasuredHeightAndState()

Return the full height measurement information for this view as computed by the 
most recent call to (|android.view.View|) . This result is a bit mask as 
defined by (|android.view.View|) and (|android.view.View|) . This should be 
used during measurement and layout calculations only. Use (|android.view.View|) 
to see how wide a view is after layout. 



    Returns: The measured width of this view as a bit mask. 

*android.view.View.getMeasuredState()*

public final int getMeasuredState()

Return only the state bits of (|android.view.View|) and (|android.view.View|) , 
combined into one integer. The width component is in the regular bits 
(|android.view.View|) and the height component is at the shifted bits 
(|android.view.View|) >> (|android.view.View|) . 



*android.view.View.getMeasuredWidth()*

public final int getMeasuredWidth()

Like (|android.view.View|) , but only returns the raw width component (that is 
the result is masked by (|android.view.View|) ). 



    Returns: The raw measured width of this view. 

*android.view.View.getMeasuredWidthAndState()*

public final int getMeasuredWidthAndState()

Return the full width measurement information for this view as computed by the 
most recent call to (|android.view.View|) . This result is a bit mask as 
defined by (|android.view.View|) and (|android.view.View|) . This should be 
used during measurement and layout calculations only. Use (|android.view.View|) 
to see how wide a view is after layout. 



    Returns: The measured width of this view as a bit mask. 

*android.view.View.getMinimumHeight()*

public int getMinimumHeight()

Returns the minimum height of the view. 



    Returns: the minimum height the view will try to be. 

*android.view.View.getMinimumWidth()*

public int getMinimumWidth()

Returns the minimum width of the view. 



    Returns: the minimum width the view will try to be. 

*android.view.View.getNextFocusDownId()*

public int getNextFocusDownId()

Gets the id of the view to use when the next focus is (|android.view.View|) . 



    Returns: The next focus ID, or {@link #NO_ID} if the framework should decide 
             automatically. 

*android.view.View.getNextFocusForwardId()*

public int getNextFocusForwardId()

Gets the id of the view to use when the next focus is (|android.view.View|) . 



    Returns: The next focus ID, or {@link #NO_ID} if the framework should decide 
             automatically. 

*android.view.View.getNextFocusLeftId()*

public int getNextFocusLeftId()

Gets the id of the view to use when the next focus is (|android.view.View|) . 



    Returns: The next focus ID, or {@link #NO_ID} if the framework should decide 
             automatically. 

*android.view.View.getNextFocusRightId()*

public int getNextFocusRightId()

Gets the id of the view to use when the next focus is (|android.view.View|) . 



    Returns: The next focus ID, or {@link #NO_ID} if the framework should decide 
             automatically. 

*android.view.View.getNextFocusUpId()*

public int getNextFocusUpId()

Gets the id of the view to use when the next focus is (|android.view.View|) . 



    Returns: The next focus ID, or {@link #NO_ID} if the framework should decide 
             automatically. 

*android.view.View.getOnFocusChangeListener()*

public |android.view.View.OnFocusChangeListener| getOnFocusChangeListener()

Returns the focus-change callback registered for this view. 



    Returns: The callback, or null if one is not registered. 

*android.view.View.getOpticalInsets()*

public Insets getOpticalInsets()





*android.view.View.getOverlay()*

public |android.view.ViewOverlay| getOverlay()

Returns the overlay for this view, creating it if it does not yet exist. Adding 
drawables to the overlay will cause them to be displayed whenever the view 
itself is redrawn. Objects in the overlay should be actively managed: remove 
them when they should not be displayed anymore. The overlay will always have 
the same size as its host view. 

Note: Overlays do not currently work correctly with 
(|android.view.SurfaceView|) or (|android.view.TextureView|) ; contents in 
overlays for these types of views may not display correctly. 



    Returns: The ViewOverlay object for this view. 

*android.view.View.getOverScrollMode()*

public int getOverScrollMode()

Returns the over-scroll mode for this view. The result will be one of 
(|android.view.View|) (default), (|android.view.View|) (allow over-scrolling 
only if the view content is larger than the container), or 
(|android.view.View|) . 



    Returns: This view's over-scroll mode. 

*android.view.View.getPaddingBottom()*

public int getPaddingBottom()

Returns the bottom padding of this view. If there are inset and enabled 
scrollbars, this value may include the space required to display the scrollbars 
as well. 



    Returns: the bottom padding in pixels 

*android.view.View.getPaddingEnd()*

public int getPaddingEnd()

Returns the end padding of this view depending on its resolved layout 
direction. If there are inset and enabled scrollbars, this value may include 
the space required to display the scrollbars as well. 



    Returns: the end padding in pixels 

*android.view.View.getPaddingLeft()*

public int getPaddingLeft()

Returns the left padding of this view. If there are inset and enabled 
scrollbars, this value may include the space required to display the scrollbars 
as well. 



    Returns: the left padding in pixels 

*android.view.View.getPaddingRight()*

public int getPaddingRight()

Returns the right padding of this view. If there are inset and enabled 
scrollbars, this value may include the space required to display the scrollbars 
as well. 



    Returns: the right padding in pixels 

*android.view.View.getPaddingStart()*

public int getPaddingStart()

Returns the start padding of this view depending on its resolved layout 
direction. If there are inset and enabled scrollbars, this value may include 
the space required to display the scrollbars as well. 



    Returns: the start padding in pixels 

*android.view.View.getPaddingTop()*

public int getPaddingTop()

Returns the top padding of this view. 



    Returns: the top padding in pixels 

*android.view.View.getParent()*

public final |android.view.ViewParent| getParent()

Gets the parent of this view. Note that the parent is a ViewParent and not 
necessarily a View. 



    Returns: Parent of this view. 

*android.view.View.getParentForAccessibility()*

public |android.view.ViewParent| getParentForAccessibility()

Gets the parent for accessibility purposes. Note that the parent for 
accessibility is not necessary the immediate parent. It is the first 
predecessor that is important for accessibility. 



    Returns: The parent for accessibility purposes. 

*android.view.View.getPivotX()*

public float getPivotX()

The x location of the point around which the view is 
rotated(|android.view.View|) and scaled(|android.view.View|) . 



    Returns: The x location of the pivot point. 

*android.view.View.getPivotY()*

public float getPivotY()

The y location of the point around which the view is 
rotated(|android.view.View|) and scaled(|android.view.View|) . 



    Returns: The y location of the pivot point. 

*android.view.View.getRawLayoutDirection()*

public int getRawLayoutDirection()

Returns the layout direction for this view. 



    Returns: One of {@link #LAYOUT_DIRECTION_LTR}, {@link #LAYOUT_DIRECTION_RTL}, {@link 
             #LAYOUT_DIRECTION_INHERIT} or {@link #LAYOUT_DIRECTION_LOCALE}. 

*android.view.View.getRawTextAlignment()*

public int getRawTextAlignment()

Return the value specifying the text alignment or policy that was set with 
(|android.view.View|) . 



    Returns: the defined text alignment. It can be one of: 

{@link #TEXT_ALIGNMENT_INHERIT}, {@link #TEXT_ALIGNMENT_GRAVITY}, {@link 
             #TEXT_ALIGNMENT_CENTER}, {@link #TEXT_ALIGNMENT_TEXT_START}, 
             {@link #TEXT_ALIGNMENT_TEXT_END}, {@link 
             #TEXT_ALIGNMENT_VIEW_START}, {@link #TEXT_ALIGNMENT_VIEW_END} 

*android.view.View.getRawTextDirection()*

public int getRawTextDirection()

Return the value specifying the text direction or policy that was set with 
(|android.view.View|) . 



    Returns: the defined text direction. It can be one of: 

{@link #TEXT_DIRECTION_INHERIT}, {@link #TEXT_DIRECTION_FIRST_STRONG} {@link 
             #TEXT_DIRECTION_ANY_RTL}, {@link #TEXT_DIRECTION_LTR}, {@link 
             #TEXT_DIRECTION_RTL}, {@link #TEXT_DIRECTION_LOCALE} 

*android.view.View.getResources()*

public |android.content.res.Resources| getResources()

Returns the resources associated with this view. 



    Returns: Resources object. 

*android.view.View.getRight()*

public final int getRight()

Right position of this view relative to its parent. 



    Returns: The right edge of this view, in pixels. 

*android.view.View.getRightFadingEdgeStrength()*

protected float getRightFadingEdgeStrength()

Returns the strength, or intensity, of the right faded edge. The strength is a 
value between 0.0 (no fade) and 1.0 (full fade). The default implementation 
returns 0.0 or 1.0 but no value in between. 

Subclasses should override this method to provide a smoother fade transition 
when scrolling occurs. 



    Returns: the intensity of the right fade as a float between 0.0f and 1.0f 

*android.view.View.getRightPaddingOffset()*

protected int getRightPaddingOffset()

Amount by which to extend the right fading region. Called only when 
(|android.view.View|) returns true. 



    Returns: The right padding offset in pixels. 

*android.view.View.getRootView()*

public |android.view.View| getRootView()

Finds the topmost view in the current view hierarchy. 



    Returns: the topmost view containing this view 

*android.view.View.getRotation()*

public float getRotation()

The degrees that the view is rotated around the pivot point. 



    Returns: The degrees of rotation. 

*android.view.View.getRotationX()*

public float getRotationX()

The degrees that the view is rotated around the horizontal axis through the 
pivot point. 



    Returns: The degrees of X rotation. 

*android.view.View.getRotationY()*

public float getRotationY()

The degrees that the view is rotated around the vertical axis through the pivot 
point. 



    Returns: The degrees of Y rotation. 

*android.view.View.getScaleX()*

public float getScaleX()

The amount that the view is scaled in x around the pivot point, as a proportion 
of the view's unscaled width. A value of 1, the default, means that no scaling 
is applied. 

By default, this is 1.0f. 



    Returns: The scaling factor. 

*android.view.View.getScaleY()*

public float getScaleY()

The amount that the view is scaled in y around the pivot point, as a proportion 
of the view's unscaled height. A value of 1, the default, means that no scaling 
is applied. 

By default, this is 1.0f. 



    Returns: The scaling factor. 

*android.view.View.getScrollBarDefaultDelayBeforeFade()*

public int getScrollBarDefaultDelayBeforeFade()

Returns the delay before scrollbars fade. 



    Returns: the delay before scrollbars fade 

*android.view.View.getScrollBarFadeDuration()*

public int getScrollBarFadeDuration()

Returns the scrollbar fade duration. 



    Returns: the scrollbar fade duration 

*android.view.View.getScrollBarSize()*

public int getScrollBarSize()

Returns the scrollbar size. 



    Returns: the scrollbar size 

*android.view.View.getScrollBarStyle()*

public int getScrollBarStyle()

Returns the current scrollbar style. 



    Returns: the current scrollbar style 

*android.view.View.getScrollX()*

public final int getScrollX()

Return the scrolled left position of this view. This is the left edge of the 
displayed part of your view. You do not need to draw any pixels farther left, 
since those are outside of the frame of your view on screen. 



    Returns: The left edge of the displayed part of your view, in pixels. 

*android.view.View.getScrollY()*

public final int getScrollY()

Return the scrolled top position of this view. This is the top edge of the 
displayed part of your view. You do not need to draw any pixels above it, since 
those are outside of the frame of your view on screen. 



    Returns: The top edge of the displayed part of your view, in pixels. 

*android.view.View.getSolidColor()*

public int getSolidColor()

Override this if your view is known to always be drawn on top of a solid color 
background, and needs to draw fading edges. Returning a non-zero color enables 
the view system to optimize the drawing of the fading edges. If you do return a 
non-zero color, the alpha should be set to 0xFF. 



    Returns: The known solid color background for this view, or 0 if the color may vary 

*android.view.View.getSuggestedMinimumHeight()*

protected int getSuggestedMinimumHeight()

Returns the suggested minimum height that the view should use. This returns the 
maximum of the view's minimum height and the background's minimum height ( 
(|android.graphics.drawable.Drawable|) ). 

When being used in (|android.view.View|) , the caller should still ensure the 
returned height is within the requirements of the parent. 



    Returns: The suggested minimum height of the view. 

*android.view.View.getSuggestedMinimumWidth()*

protected int getSuggestedMinimumWidth()

Returns the suggested minimum width that the view should use. This returns the 
maximum of the view's minimum width) and the background's minimum width ( 
(|android.graphics.drawable.Drawable|) ). 

When being used in (|android.view.View|) , the caller should still ensure the 
returned width is within the requirements of the parent. 



    Returns: The suggested minimum width of the view. 

*android.view.View.getSystemUiVisibility()*

public int getSystemUiVisibility()

Returns the last (|android.view.View|) that this view has requested. 



    Returns: Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE}, {@link 
             #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link 
             #SYSTEM_UI_FLAG_FULLSCREEN}, {@link 
             #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link 
             #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION}, {@link 
             #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}, {@link 
             #SYSTEM_UI_FLAG_IMMERSIVE}, and {@link 
             #SYSTEM_UI_FLAG_IMMERSIVE_STICKY}. 

*android.view.View.getTag()*

public |java.lang.Object| getTag()

Returns this view's tag. 



    Returns: the Object stored in this view as a tag 

*android.view.View.getTag(int)*

public |java.lang.Object| getTag(int key)

Returns the tag associated with this view and the specified key. 


    key - The key identifying the tag 

    Returns: the Object stored in this view as a tag 

*android.view.View.getTextAlignment()*

public int getTextAlignment()

Return the resolved text alignment. 



    Returns: the resolved text alignment. Returns one of: 

{@link #TEXT_ALIGNMENT_GRAVITY}, {@link #TEXT_ALIGNMENT_CENTER}, {@link 
             #TEXT_ALIGNMENT_TEXT_START}, {@link #TEXT_ALIGNMENT_TEXT_END}, 
             {@link #TEXT_ALIGNMENT_VIEW_START}, {@link 
             #TEXT_ALIGNMENT_VIEW_END} 

*android.view.View.getTextDirection()*

public int getTextDirection()

Return the resolved text direction. 



    Returns: the resolved text direction. Returns one of: 

{@link #TEXT_DIRECTION_FIRST_STRONG} {@link #TEXT_DIRECTION_ANY_RTL}, {@link 
             #TEXT_DIRECTION_LTR}, {@link #TEXT_DIRECTION_RTL}, {@link 
             #TEXT_DIRECTION_LOCALE} 

*android.view.View.getTop()*

public final int getTop()

Top position of this view relative to its parent. 



    Returns: The top of this view, in pixels. 

*android.view.View.getTopFadingEdgeStrength()*

protected float getTopFadingEdgeStrength()

Returns the strength, or intensity, of the top faded edge. The strength is a 
value between 0.0 (no fade) and 1.0 (full fade). The default implementation 
returns 0.0 or 1.0 but no value in between. 

Subclasses should override this method to provide a smoother fade transition 
when scrolling occurs. 



    Returns: the intensity of the top fade as a float between 0.0f and 1.0f 

*android.view.View.getTopPaddingOffset()*

protected int getTopPaddingOffset()

Amount by which to extend the top fading region. Called only when 
(|android.view.View|) returns true. 



    Returns: The top padding offset in pixels. 

*android.view.View.getTouchables()*

public |java.util.ArrayList|<View> getTouchables()

Find and return all touchable views that are descendants of this view, possibly 
including this view if it is touchable itself. 



    Returns: A list of touchable views 

*android.view.View.getTouchDelegate()*

public |android.view.TouchDelegate| getTouchDelegate()

Gets the TouchDelegate for this View. 



*android.view.View.getTransitionAlpha()*

public float getTransitionAlpha()

This property is hidden and intended only for use by the Fade transition, which 
animates it to produce a visual translucency that does not side-effect (or get 
affected by) the real alpha property. This value is composited with the other 
alpha value (and the AlphaAnimation value, when that is present) to produce a 
final visual translucency result, which is what is passed into the DisplayList. 



*android.view.View.getTranslationX()*

public float getTranslationX()

The horizontal location of this view relative to its left(|android.view.View|) 
position. This position is post-layout, in addition to wherever the object's 
layout placed it. 



    Returns: The horizontal position of this view relative to its left position, in pixels. 

*android.view.View.getTranslationY()*

public float getTranslationY()

The horizontal location of this view relative to its top(|android.view.View|) 
position. This position is post-layout, in addition to wherever the object's 
layout placed it. 



    Returns: The vertical position of this view relative to its top position, in pixels. 

*android.view.View.getVerticalFadingEdgeLength()*

public int getVerticalFadingEdgeLength()

Returns the size of the vertical faded edges used to indicate that more content 
in this view is visible. 



    Returns: The size in pixels of the vertical faded edge or 0 if vertical faded edges are 
             not enabled for this view. 

*android.view.View.getVerticalScrollbarPosition()*

public int getVerticalScrollbarPosition()





    Returns: The position where the vertical scroll bar will show, if applicable. 

*android.view.View.getVerticalScrollbarWidth()*

public int getVerticalScrollbarWidth()

Returns the width of the vertical scrollbar. 



    Returns: The width in pixels of the vertical scrollbar or 0 if there is no vertical 
             scrollbar. 

*android.view.View.getVerticalScrollFactor()*

protected float getVerticalScrollFactor()

Gets a scale factor that determines the distance the view should scroll 
vertically in response to (|android.view.MotionEvent|) . 



    Returns: The vertical scroll scale factor. 

*android.view.View.getViewRootImpl()*

public |android.view.ViewRootImpl| getViewRootImpl()

Gets the view root associated with the View. 



    Returns: The view root, or null if none. 

*android.view.View.getViewTreeObserver()*

public |android.view.ViewTreeObserver| getViewTreeObserver()

Returns the ViewTreeObserver for this view's hierarchy. The view tree observer 
can be used to get notifications when global events, like layout, happen. 

The returned ViewTreeObserver observer is not guaranteed to remain valid for 
the lifetime of this View. If the caller of this method keeps a long-lived 
reference to ViewTreeObserver, it should always check for the return value of 
(|android.view.ViewTreeObserver|) . 



    Returns: The ViewTreeObserver for this view's hierarchy. 

*android.view.View.getVisibility()*

public int getVisibility()

Returns the visibility status for this view. 



    Returns: One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}. 

*android.view.View.getWidth()*

public final int getWidth()

Return the width of the your view. 



    Returns: The width of your view, in pixels. 

*android.view.View.getWindowAttachCount()*

protected int getWindowAttachCount()





    Returns: The number of times this view has been attached to a window 

*android.view.View.getWindowId()*

public |android.view.WindowId| getWindowId()

Retrieve the (|android.view.WindowId|) for the window this view is currently 
attached to. 



*android.view.View.getWindowSystemUiVisibility()*

public int getWindowSystemUiVisibility()

Returns the current system UI visibility that is currently set for the entire 
window. This is the combination of the (|android.view.View|) values supplied by 
all of the views in the window. 



*android.view.View.getWindowToken()*

public |android.os.IBinder| getWindowToken()

Retrieve a unique token identifying the window this view is attached to. 



    Returns: Return the window's token for use in {@link WindowManager.LayoutParams#token 
             WindowManager.LayoutParams.token}. 

*android.view.View.getWindowVisibility()*

public int getWindowVisibility()

Returns the current visibility of the window this view is attached to (either 
(|android.view.View|) , (|android.view.View|) , or (|android.view.View|) ). 



    Returns: Returns the current visibility of the view's window. 

*android.view.View.getWindowVisibleDisplayFrame(Rect)*

public void getWindowVisibleDisplayFrame(Rect outRect)

Retrieve the overall visible display size in which the window this view is 
attached to has been positioned in. This takes into account screen decorations 
above the window, for both cases where the window itself is being position 
inside of them or the window is being placed under then and covered insets are 
used for the window to position its content inside. In effect, this tells you 
the available area where content can be placed and remain visible to users. 

This function requires an IPC back to the window manager to retrieve the 
requested information, so should not be used in performance critical code like 
drawing. 


    outRect - Filled in with the visible display frame. If the view is not attached to a 
       window, this is simply the raw display size. 

*android.view.View.getX()*

public float getX()

The visual x position of this view, in pixels. This is equivalent to the 
translationX(|android.view.View|) property plus the current 
left(|android.view.View|) property. 



    Returns: The visual x position of this view, in pixels. 

*android.view.View.getY()*

public float getY()

The visual y position of this view, in pixels. This is equivalent to the 
translationY(|android.view.View|) property plus the current 
top(|android.view.View|) property. 



    Returns: The visual y position of this view, in pixels. 

*android.view.View.hackTurnOffWindowResizeAnim(boolean)*

public void hackTurnOffWindowResizeAnim(boolean off)





*android.view.View.hasFocus()*

public boolean hasFocus()

Returns true if this view has focus iteself, or is the ancestor of the view 
that has focus. 



    Returns: True if this view has or contains focus, false otherwise. 

*android.view.View.hasFocusable()*

public boolean hasFocusable()

Returns true if this view is focusable or if it contains a reachable View for 
which (|android.view.View|) returns true. A "reachable hasFocusable()" is a 
View whose parents do not block descendants focus. 

Only (|android.view.View|) views are considered focusable. 



    Returns: True if the view is focusable or if the view contains a focusable View, false 
             otherwise. 

*android.view.View.hasHoveredChild()*

protected boolean hasHoveredChild()

Returns true if the view has a child to which it has recently sent 
(|android.view.MotionEvent|) . If this view is hovered and it does not have a 
hovered child, then it must be the innermost hovered view. 



*android.view.View.hasOnClickListeners()*

public boolean hasOnClickListeners()

Return whether this view has an attached OnClickListener. Returns true if there 
is a listener, false if there is none. 



*android.view.View.hasOpaqueScrollbars()*

protected boolean hasOpaqueScrollbars()





*android.view.View.hasOverlappingRendering()*

public boolean hasOverlappingRendering()

Returns whether this View has content which overlaps. 

This function, intended to be overridden by specific View types, is an 
optimization when alpha is set on a view. If rendering overlaps in a view with 
alpha 

The current implementation of the saveLayer and saveLayerAlpha methods in 
(|Canvas|) necessitates that a View return true if it uses the methods 
internally without passing the (|Canvas|) . 



    Returns: true if the content in this view might overlap, false otherwise. 

*android.view.View.hasTransientState()*

public boolean hasTransientState()

Indicates whether the view is currently tracking transient state that the app 
should not need to concern itself with saving and restoring, but that the 
framework should take special note to preserve when possible. 

A view with transient state cannot be trivially rebound from an external data 
source, such as an adapter binding item views in a list. This may be because 
the view is performing an animation, tracking user selection of content, or 
similar. 



    Returns: true if the view has transient state 

*android.view.View.hasWindowFocus()*

public boolean hasWindowFocus()

Returns true if this view is in a window that currently has window focus. Note 
that this is not the same as the view itself having focus. 



    Returns: True if this view is in a window that currently has window focus. 

*android.view.View.includeForAccessibility()*

public boolean includeForAccessibility()

Whether to regard this view for accessibility. A view is regarded for 
accessibility if it is important for accessibility or the querying 
accessibility service has explicitly requested that view not important for 
accessibility are regarded. 



    Returns: Whether to regard the view for accessibility. 

*android.view.View.inflate(Context,int,ViewGroup)*

public static |android.view.View| inflate(
  android.content.Context context,
  int resource,
  android.view.ViewGroup root)

Inflate a view from an XML resource. This convenience method wraps the 
(|android.view.LayoutInflater|) class, which provides a full range of options 
for view inflation. 


    context - The Context object for your activity or application. 
    resource - The resource ID to inflate 
    root - A view group that will be the parent. Used to properly inflate the layout_* 
       parameters. 

*android.view.View.initializeFadingEdge(TypedArray)*

protected void initializeFadingEdge(android.content.res.TypedArray a)

Initializes the fading edges from a given set of styled attributes. This method 
should be called by subclasses that need fading edges and when an instance of 
these subclasses is created programmatically rather than being inflated from 
XML. This method is automatically called when the XML is inflated. 


    a - the styled attributes set to initialize the fading edges from 

*android.view.View.initializeScrollbars(TypedArray)*

protected void initializeScrollbars(android.content.res.TypedArray a)

Initializes the scrollbars from a given set of styled attributes. This method 
should be called by subclasses that need scrollbars and when an instance of 
these subclasses is created programmatically rather than being inflated from 
XML. This method is automatically called when the XML is inflated. 


    a - the styled attributes set to initialize the scrollbars from 

*android.view.View.internalSetPadding(int,int,int,int)*

protected void internalSetPadding(
  int left,
  int top,
  int right,
  int bottom)





*android.view.View.invalidate()*

public void invalidate()

Invalidate the whole view. If the view is visible, (|android.view.View|) will 
be called at some point in the future. This must be called from a UI thread. To 
call from a non-UI thread, call (|android.view.View|) . 



*android.view.View.invalidate(int,int,int,int)*

public void invalidate(
  int l,
  int t,
  int r,
  int b)

Mark the area defined by the rect (l,t,r,b) as needing to be drawn. The 
coordinates of the dirty rect are relative to the view. If the view is visible, 
(|android.view.View|) will be called at some point in the future. This must be 
called from a UI thread. To call from a non-UI thread, call 
(|android.view.View|) . 


    l - the left position of the dirty region 
    t - the top position of the dirty region 
    r - the right position of the dirty region 
    b - the bottom position of the dirty region 

*android.view.View.invalidate(Rect)*

public void invalidate(Rect dirty)

Mark the area defined by dirty as needing to be drawn. If the view is visible, 
(|android.view.View|) will be called at some point in the future. This must be 
called from a UI thread. To call from a non-UI thread, call 
(|android.view.View|) . 

WARNING: This method is destructive to dirty. 


    dirty - the rectangle representing the bounds of the dirty region 

*android.view.View.invalidateDrawable(Drawable)*

public void invalidateDrawable(Drawable drawable)

Invalidates the specified Drawable. 


    drawable - the drawable to invalidate 

*android.view.View.invalidateParentCaches()*

protected void invalidateParentCaches()

Used to indicate that the parent of this view should clear its caches. This 
functionality is used to force the parent to rebuild its display list (when 
hardware-accelerated), which is necessary when various parent-managed 
properties of the view change, such as alpha, translationX/Y, scrollX/Y, 
scaleX/Y, and rotation/X/Y. This method only clears the parent caches and does 
not causes an invalidate event. 



*android.view.View.invalidateParentIfNeeded()*

protected void invalidateParentIfNeeded()

Used to indicate that the parent of this view should be invalidated. This 
functionality is used to force the parent to rebuild its display list (when 
hardware-accelerated), which is necessary when various parent-managed 
properties of the view change, such as alpha, translationX/Y, scrollX/Y, 
scaleX/Y, and rotation/X/Y. This method will propagate an invalidation event to 
the parent. 



*android.view.View.isAccessibilityFocused()*

public boolean isAccessibilityFocused()

Returns whether this View is accessibility focused. 



    Returns: True if this View is accessibility focused. 

*android.view.View.isAccessibilitySelectionExtendable()*

public boolean isAccessibilitySelectionExtendable()

Gets whether accessibility selection can be extended. 



    Returns: If selection is extensible. 

*android.view.View.isActionableForAccessibility()*

public boolean isActionableForAccessibility()

Returns whether the View is considered actionable from accessibility 
perspective. Such view are important for accessibility. 



    Returns: True if the view is actionable for accessibility. 

*android.view.View.isActivated()*

public boolean isActivated()

Indicates the activation state of this view. 



    Returns: true if the view is activated, false otherwise 

*android.view.View.isAttachedToWindow()*

public boolean isAttachedToWindow()

Returns true if this view is currently attached to a window. 



*android.view.View.isClickable()*

public boolean isClickable()

Indicates whether this view reacts to click events or not. 



    Returns: true if the view is clickable, false otherwise 

*android.view.View.isDirty()*

public boolean isDirty()

True if this view has changed since the last time being drawn. 



    Returns: The dirty state of this view. 

*android.view.View.isDrawingCacheEnabled()*

public boolean isDrawingCacheEnabled()

Indicates whether the drawing cache is enabled for this view. 



    Returns: true if the drawing cache is enabled 

*android.view.View.isDuplicateParentStateEnabled()*

public boolean isDuplicateParentStateEnabled()

Indicates whether this duplicates its drawable state from its parent. 



    Returns: True if this view's drawable state is duplicated from the parent, false 
             otherwise 

*android.view.View.isEnabled()*

public boolean isEnabled()

Returns the enabled status for this view. The interpretation of the enabled 
state varies by subclass. 



    Returns: True if this view is enabled, false otherwise. 

*android.view.View.isFocusable()*

public final boolean isFocusable()

Returns whether this View is able to take focus. 



    Returns: True if this view can take focus, or false otherwise. 

*android.view.View.isFocusableInTouchMode()*

public final boolean isFocusableInTouchMode()

When a view is focusable, it may not want to take focus when in touch mode. For 
example, a button would like focus when the user is navigating via a D-pad so 
that the user can click on it, but once the user starts touching the screen, 
the button shouldn't take focus 



    Returns: Whether the view is focusable in touch mode. 

*android.view.View.isFocused()*

public boolean isFocused()

Returns true if this view has focus 



    Returns: True if this view has focus, false otherwise. 

*android.view.View.isHapticFeedbackEnabled()*

public boolean isHapticFeedbackEnabled()





    Returns: whether this view should have haptic feedback enabled for events long presses. 

*android.view.View.isHardwareAccelerated()*

public boolean isHardwareAccelerated()

Indicates whether this view is attached to a hardware accelerated window or 
not. 

Even if this method returns true, it does not mean that every call to 
(|android.view.View|) will be made with an hardware accelerated 
(|android.graphics.Canvas|) . For instance, if this view is drawn onto an 
offscreen (|android.graphics.Bitmap|) and its window is hardware accelerated, 
(|android.graphics.Canvas|) will likely return false, and this method will 
return true. 



    Returns: True if the view is attached to a window and the window is hardware 
             accelerated; false in any other case. 

*android.view.View.isHorizontalFadingEdgeEnabled()*

public boolean isHorizontalFadingEdgeEnabled()

Indicate whether the horizontal edges are faded when the view is scrolled 
horizontally. 



    Returns: true if the horizontal edges should are faded on scroll, false otherwise 

*android.view.View.isHorizontalScrollBarEnabled()*

public boolean isHorizontalScrollBarEnabled()

Indicate whether the horizontal scrollbar should be drawn or not. The scrollbar 
is not drawn by default. 



    Returns: true if the horizontal scrollbar should be painted, false otherwise 

*android.view.View.isHovered()*

public boolean isHovered()

Returns true if the view is currently hovered. 



    Returns: True if the view is currently hovered. 

*android.view.View.isImportantForAccessibility()*

public boolean isImportantForAccessibility()

Gets whether this view should be exposed for accessibility. 



    Returns: Whether the view is exposed for accessibility. 

*android.view.View.isInEditMode()*

public boolean isInEditMode()

Indicates whether this View is currently in edit mode. A View is usually in 
edit mode when displayed within a developer tool. For instance, if this View is 
being drawn by a visual user interface builder, this method should return true. 

Subclasses should check the return value of this method to provide different 
behaviors if their normal behavior might interfere with the host environment. 
For instance: the class spawns a thread in its constructor, the drawing code 
relies on device-specific features, etc. 

This method is usually checked in the drawing code of custom widgets. 



    Returns: True if this View is in edit mode, false otherwise. 

*android.view.View.isInLayout()*

public boolean isInLayout()

Returns whether the view hierarchy is currently undergoing a layout pass. This 
information is useful to avoid situations such as calling (|android.view.View|) 
during a layout pass. 



    Returns: whether the view hierarchy is currently undergoing a layout pass 

*android.view.View.isInScrollingContainer()*

public boolean isInScrollingContainer()





*android.view.View.isInTouchMode()*

public boolean isInTouchMode()

Returns whether the device is currently in touch mode. Touch mode is entered 
once the user begins interacting with the device by touch, and affects various 
things like whether focus is always visible to the user. 



    Returns: Whether the device is in touch mode. 

*android.view.View.isLaidOut()*

public boolean isLaidOut()

Returns true if this view has been through at least one layout since it was 
last attached to or detached from a window. 



*android.view.View.isLayoutDirectionInherited()*

public boolean isLayoutDirectionInherited()





    Returns: true if the layout direction is inherited. 

*android.view.View.isLayoutDirectionResolved()*

public boolean isLayoutDirectionResolved()





    Returns: true if layout direction has been resolved. 

*android.view.View.isLayoutModeOptical(Object)*

public static boolean isLayoutModeOptical(java.lang.Object o)

Return true if o is a ViewGroup that is laying out using optical bounds. 



*android.view.View.isLayoutRequested()*

public boolean isLayoutRequested()

Indicates whether or not this view's layout will be requested during the next 
hierarchy layout pass. 



    Returns: true if the layout will be forced during next layout pass 

*android.view.View.isLayoutRtl()*

public boolean isLayoutRtl()

Indicates whether or not this view's layout is right-to-left. This is resolved 
from layout attribute and/or the inherited value from the parent 



    Returns: true if the layout is right-to-left. 

*android.view.View.isLongClickable()*

public boolean isLongClickable()

Indicates whether this view reacts to long click events or not. 



    Returns: true if the view is long clickable, false otherwise 

*android.view.View.isOpaque()*

public boolean isOpaque()

Indicates whether this View is opaque. An opaque View guarantees that it will 
draw all the pixels overlapping its bounds using a fully opaque color. 

Subclasses of View should override this method whenever possible to indicate 
whether an instance is opaque. Opaque Views are treated in a special way by the 
View hierarchy, possibly allowing it to perform optimizations during 
invalidate/draw passes. 



    Returns: True if this View is guaranteed to be fully opaque, false otherwise. 

*android.view.View.isPaddingOffsetRequired()*

protected boolean isPaddingOffsetRequired()

If the View draws content inside its padding and enables fading edges, it needs 
to support padding offsets. Padding offsets are added to the fading edges to 
extend the length of the fade so that it covers pixels drawn inside the 
padding. 

Subclasses of this class should override this method if they need to draw 
content inside the padding. 



    Returns: True if padding offset must be applied, false otherwise. 

*android.view.View.isPaddingRelative()*

public boolean isPaddingRelative()

Return if the padding as been set thru relative values (|android.view.View|) or 
thru 



    Returns: true if the padding is relative or false if it is not. 

*android.view.View.isPressed()*

public boolean isPressed()

Indicates whether the view is currently in pressed state. Unless 
(|android.view.View|) is explicitly called, only clickable views can enter the 
pressed state. 



    Returns: true if the view is currently pressed, false otherwise 

*android.view.View.isRootNamespace()*

public boolean isRootNamespace()





    Returns: true if the view belongs to the root namespace, false otherwise 

*android.view.View.isSaveEnabled()*

public boolean isSaveEnabled()

Indicates whether this view will save its state (that is, whether its 
(|android.view.View|) method will be called). 



    Returns: Returns true if the view state saving is enabled, else false. 

*android.view.View.isSaveFromParentEnabled()*

public boolean isSaveFromParentEnabled()

Indicates whether the entire hierarchy under this view will save its state when 
a state saving traversal occurs from its parent. The default is true; if false, 
these views will not be saved unless (|android.view.View|) is called directly 
on this view. 



    Returns: Returns true if the view state saving from parent is enabled, else false. 

*android.view.View.isScrollbarFadingEnabled()*

public boolean isScrollbarFadingEnabled()

Returns true if scrollbars will fade when this view is not scrolling 



    Returns: true if scrollbar fading is enabled 

*android.view.View.isScrollContainer()*

public boolean isScrollContainer()

Indicates whether this view is one of the set of scrollable containers in its 
window. 



    Returns: whether this view is one of the set of scrollable containers in its window 

*android.view.View.isSelected()*

public boolean isSelected()

Indicates the selection state of this view. 



    Returns: true if the view is selected, false otherwise 

*android.view.View.isShown()*

public boolean isShown()

Returns the visibility of this view and all of its ancestors 



    Returns: True if this view and all of its ancestors are {@link #VISIBLE} 

*android.view.View.isSoundEffectsEnabled()*

public boolean isSoundEffectsEnabled()





    Returns: whether this view should have sound effects enabled for events such as clicking 
             and touching. 

*android.view.View.isTextAlignmentInherited()*

public boolean isTextAlignmentInherited()





    Returns: true if text alignment is inherited. 

*android.view.View.isTextAlignmentResolved()*

public boolean isTextAlignmentResolved()





    Returns: true if text alignment is resolved. 

*android.view.View.isTextDirectionInherited()*

public boolean isTextDirectionInherited()





    Returns: true if text direction is inherited. 

*android.view.View.isTextDirectionResolved()*

public boolean isTextDirectionResolved()





    Returns: true if text direction is resolved. 

*android.view.View.isVerticalFadingEdgeEnabled()*

public boolean isVerticalFadingEdgeEnabled()

Indicate whether the vertical edges are faded when the view is scrolled 
horizontally. 



    Returns: true if the vertical edges should are faded on scroll, false otherwise 

*android.view.View.isVerticalScrollBarEnabled()*

public boolean isVerticalScrollBarEnabled()

Indicate whether the vertical scrollbar should be drawn or not. The scrollbar 
is not drawn by default. 



    Returns: true if the vertical scrollbar should be painted, false otherwise 

*android.view.View.isVerticalScrollBarHidden()*

protected boolean isVerticalScrollBarHidden()

Override this if the vertical scrollbar needs to be hidden in a subclass, like 
when FastScroller is visible. 



    Returns: whether to temporarily hide the vertical scrollbar 

*android.view.View.isVisibleToUser()*

protected boolean isVisibleToUser()

Computes whether this view is visible to the user. Such a view is attached, 
visible, all its predecessors are visible, it is not clipped entirely by its 
predecessors, and has an alpha greater than zero. 



    Returns: Whether the view is visible on the screen. 

*android.view.View.isVisibleToUser(Rect)*

protected boolean isVisibleToUser(Rect boundInView)

Computes whether the given portion of this view is visible to the user. Such a 
view is attached, visible, all its predecessors are visible, has an alpha 
greater than zero, and the specified portion is not clipped entirely by its 
predecessors. 


    boundInView - the portion of the view to test; coordinates should be relative; may be null, 
       and the entire view will be tested in this case. When true is returned 
       by the function, the actual visible region will be stored in this 
       parameter; that is, if boundInView is fully contained within the view, 
       no modification will be made, otherwise regions outside of the visible 
       area of the view will be clipped. 

    Returns: Whether the specified portion of the view is visible on the screen. 

*android.view.View.jumpDrawablesToCurrentState()*

public void jumpDrawablesToCurrentState()

Call Drawable.jumpToCurrentState()(|Drawable|) on all Drawable objects 
associated with this view. 



*android.view.View.layout(int,int,int,int)*

public void layout(
  int l,
  int t,
  int r,
  int b)

Assign a size and position to a view and all of its descendants 

This is the second phase of the layout mechanism. (The first is measuring). In 
this phase, each parent calls layout on all of its children to position them. 
This is typically done using the child measurements that were stored in the 
measure pass(). 

Derived classes should not override this method. Derived classes with children 
should override onLayout. In that method, they should call layout on each of 
their children. 


    l - Left position, relative to parent 
    t - Top position, relative to parent 
    r - Right position, relative to parent 
    b - Bottom position, relative to parent 

*android.view.View.makeOptionalFitsSystemWindows()*

public void makeOptionalFitsSystemWindows()

For use by PhoneWindow to make its own system window fitting optional. 



*android.view.View.measure(int,int)*

public final void measure(
  int widthMeasureSpec,
  int heightMeasureSpec)

This is called to find out how big a view should be. The parent supplies 
constraint information in the width and height parameters. 

The actual measurement work of a view is performed in (|android.view.View|) , 
called by this method. Therefore, only (|android.view.View|) can and must be 
overridden by subclasses. 


    widthMeasureSpec - Horizontal space requirements as imposed by the parent 
    heightMeasureSpec - Vertical space requirements as imposed by the parent 

*android.view.View.mergeDrawableStates(int[],int[])*

protected static int[] mergeDrawableStates(
  int[] baseState,
  int[] additionalState)

Merge your own state values in additionalState into the base state values 
baseState that were returned by (|android.view.View|) . 


    baseState - The base state values returned by {@link #onCreateDrawableState(int)}, which 
       will be modified to also hold your own additional state values. 
    additionalState - The additional state values you would like added to baseState; this array is 
       not modified. 

    Returns: As a convenience, the baseState array you originally passed into the function 
             is returned. 

*android.view.View.notifySubtreeAccessibilityStateChangedIfNeeded()*

public void notifySubtreeAccessibilityStateChangedIfNeeded()

Notifies that the accessibility state of this view changed. The change is *not* 
local to this view and does represent structural changes such as children and 
parent. For example, the view size changed. The notification is at at most once 
every (|android.view.ViewConfiguration|) to avoid unnecessary load to the 
system. Also once a view has a pending notifucation this method is a NOP until 
the notification has been sent. 



*android.view.View.notifyViewAccessibilityStateChangedIfNeeded(int)*

public void notifyViewAccessibilityStateChangedIfNeeded(int changeType)

Notifies that the accessibility state of this view changed. The change is local 
to this view and does not represent structural changes such as children and 
parent. For example, the view became focusable. The notification is at at most 
once every (|android.view.ViewConfiguration|) to avoid unnecessary load to the 
system. Also once a view has a pending notifucation this method is a NOP until 
the notification has been sent. 



*android.view.View.offsetLeftAndRight(int)*

public void offsetLeftAndRight(int offset)

Offset this view's horizontal location by the specified amount of pixels. 


    offset - the number of pixels to offset the view by 

*android.view.View.offsetTopAndBottom(int)*

public void offsetTopAndBottom(int offset)

Offset this view's vertical location by the specified number of pixels. 


    offset - the number of pixels to offset the view by 

*android.view.View.onAnimationEnd()*

protected void onAnimationEnd()

Invoked by a parent ViewGroup to notify the end of the animation currently 
associated with this view. If you override this method, always call 
super.onAnimationEnd(); 



*android.view.View.onAnimationStart()*

protected void onAnimationStart()

Invoked by a parent ViewGroup to notify the start of the animation currently 
associated with this view. If you override this method, always call 
super.onAnimationStart(); 



*android.view.View.onAttachedToWindow()*

protected void onAttachedToWindow()

This is called when the view is attached to a window. At this point it has a 
Surface and will start drawing. Note that this function is guaranteed to be 
called before (|android.view.View|) , however it may be called any time before 
the first onDraw -- including before or after (|android.view.View|) . 



*android.view.View.onCancelPendingInputEvents()*

public void onCancelPendingInputEvents()

Called as the result of a call to (|android.view.View|) on this view or a 
parent view. 

This method is responsible for removing any pending high-level input events 
that were posted to the event queue to run later. Custom view classes that post 
their own deferred high-level events via (|android.view.View|) , 
(|android.view.View|) or (|android.os.Handler|) should override this method, 
call super.onCancelPendingInputEvents() and remove those callbacks as 
appropriate. 



*android.view.View.onCheckIsTextEditor()*

public boolean onCheckIsTextEditor()

Check whether the called view is a text editor, in which case it would make 
sense to automatically display a soft input window for it. Subclasses should 
override this if they implement (|android.view.View|) to return true if a call 
on that method would return a non-null InputConnection, and they are really a 
first-class editor that the user would normally start typing on when the go 
into a window containing your view. 

The default implementation always returns false. This does not mean that its 
(|android.view.View|) will not be called or the user can not otherwise perform 
edits on your view; it is just a hint to the system that this is not the 
primary purpose of this view. 



    Returns: Returns true if this view is a text editor, else false. 

*android.view.View.onCloseSystemDialogs(String)*

public void onCloseSystemDialogs(java.lang.String reason)

This needs to be a better API (NOT ON VIEW) before it is exposed. If it is ever 
exposed at all. 



*android.view.View.onConfigurationChanged(Configuration)*

protected void onConfigurationChanged(android.content.res.Configuration newConfig)

Called when the current configuration of the resources being used by the 
application have changed. You can use this to decide when to reload resources 
that can changed based on orientation and other configuration characterstics. 
You only need to use this if you are not relying on the normal 
(|android.app.Activity|) mechanism of recreating the activity instance upon a 
configuration change. 


    newConfig - The new resource configuration. 

*android.view.View.onCreateContextMenu(ContextMenu)*

protected void onCreateContextMenu(android.view.ContextMenu menu)

Views should implement this if the view itself is going to add items to the 
context menu. 


    menu - the context menu to populate 

*android.view.View.onCreateDrawableState(int)*

protected int[] onCreateDrawableState(int extraSpace)

Generate the new (|android.graphics.drawable.Drawable|) state for this view. 
This is called by the view system when the cached Drawable state is determined 
to be invalid. To retrieve the current state, you should use 
(|android.view.View|) . 


    extraSpace - if non-zero, this is the number of extra entries you would like in the returned 
       array in which you can place your own states. 

    Returns: Returns an array holding the current {@link Drawable} state of the view. 

*android.view.View.onCreateInputConnection(EditorInfo)*

public |android.view.inputmethod.InputConnection| onCreateInputConnection(android.view.inputmethod.EditorInfo outAttrs)

Create a new InputConnection for an InputMethod to interact with the view. The 
default implementation returns null, since it doesn't support input methods. 
You can override this to implement such support. This is only needed for views 
that take focus and text input. 

When implementing this, you probably also want to implement 
(|android.view.View|) to indicate you will return a non-null InputConnection. 


    outAttrs - Fill in with attribute information about the connection. 

*android.view.View.onDetachedFromWindow()*

protected void onDetachedFromWindow()

This is called when the view is detached from a window. At this point it no 
longer has a surface for drawing. 



*android.view.View.onDisplayHint(int)*

protected void onDisplayHint(int hint)

Gives this view a hint about whether is displayed or not. For instance, when a 
View moves out of the screen, it might receives a display hint indicating the 
view is not displayed. Applications should not rely on this hint as there is no 
guarantee that they will receive one. 


    hint - A hint about whether or not this view is displayed: {@link #VISIBLE} or {@link 
       #INVISIBLE}. 

*android.view.View.onDragEvent(DragEvent)*

public boolean onDragEvent(android.view.DragEvent event)

Handles drag events sent by the system following a call to 
startDrag()(|android.view.View|) . 

When the system calls this method, it passes a (|android.view.DragEvent|) 
object. A call to (|android.view.DragEvent|) returns one of the action type 
constants defined in DragEvent. The method uses these to determine what is 
happening in the drag and drop operation. 


    event - The {@link android.view.DragEvent} sent by the system. The {@link 
       android.view.DragEvent#getAction()} method returns an action type 
       constant defined in DragEvent, indicating the type of drag event 
       represented by this object. 

    Returns: {@code true} if the method was successful, otherwise {@code false}. 

The method should return {@code true} in response to an action type of {@link 
             android.view.DragEvent#ACTION_DRAG_STARTED} to receive drag events 
             for the current operation. 

The method should also return {@code true} in response to an action type of 
             {@link android.view.DragEvent#ACTION_DROP} if it consumed the 
             drop, or {@code false} if it didn't. 

*android.view.View.onDraw(Canvas)*

protected void onDraw(Canvas canvas)

Implement this to do your drawing. 


    canvas - the canvas on which the background will be drawn 

*android.view.View.onDrawHorizontalScrollBar(Canvas,Drawable,int,int,int,int)*

protected void onDrawHorizontalScrollBar(
  Canvas canvas,
  Drawable scrollBar,
  int l,
  int t,
  int r,
  int b)

Draw the horizontal scrollbar if (|android.view.View|) returns true. 


    canvas - the canvas on which to draw the scrollbar 
    scrollBar - the scrollbar's drawable 

*android.view.View.onDrawScrollBars(Canvas)*

protected final void onDrawScrollBars(Canvas canvas)

Request the drawing of the horizontal and the vertical scrollbar. The 
scrollbars are painted only if they have been awakened first. 


    canvas - the canvas on which to draw the scrollbars 

*android.view.View.onDrawVerticalScrollBar(Canvas,Drawable,int,int,int,int)*

protected void onDrawVerticalScrollBar(
  Canvas canvas,
  Drawable scrollBar,
  int l,
  int t,
  int r,
  int b)

Draw the vertical scrollbar if (|android.view.View|) returns true. 


    canvas - the canvas on which to draw the scrollbar 
    scrollBar - the scrollbar's drawable 

*android.view.View.onFilterTouchEventForSecurity(MotionEvent)*

public boolean onFilterTouchEventForSecurity(android.view.MotionEvent event)

Filter the touch event to apply security policies. 


    event - The motion event to be filtered. 

    Returns: True if the event should be dispatched, false if the event should be dropped. 

*android.view.View.onFinishInflate()*

protected void onFinishInflate()

Finalize inflating a view from XML. This is called as the last phase of 
inflation, after all child views have been added. 

Even if the subclass overrides onFinishInflate, they should always be sure to 
call the super method, so that we get called. 



*android.view.View.onFinishTemporaryDetach()*

public void onFinishTemporaryDetach()

Called after (|android.view.View|) when the container is done changing the 
view. 



*android.view.View.onFocusChanged(boolean,int,Rect)*

protected void onFocusChanged(
  boolean gainFocus,
  int direction,
  Rect previouslyFocusedRect)

Called by the view system when the focus state of this view changes. When the 
focus change event is caused by directional navigation, direction and 
previouslyFocusedRect provide insight into where the focus is coming from. When 
overriding, be sure to call up through to the super class so that the standard 
focus handling will occur. 


    gainFocus - True if the View has focus; false otherwise. 
    direction - The direction focus has moved when requestFocus() is called to give this view 
       focus. Values are {@link #FOCUS_UP}, {@link #FOCUS_DOWN}, {@link 
       #FOCUS_LEFT}, {@link #FOCUS_RIGHT}, {@link #FOCUS_FORWARD}, or {@link 
       #FOCUS_BACKWARD}. It may not always apply, in which case use the 
       default. 
    previouslyFocusedRect - The rectangle, in this view's coordinate system, of the previously focused 
       view. If applicable, this will be passed in as finer grained information 
       about where the focus is coming from (in addition to direction). Will be 
       null otherwise. 

*android.view.View.onFocusLost()*

protected void onFocusLost()

Invoked whenever this view loses focus, either by losing window focus or by 
losing focus within its window. This method can be used to clear any state tied 
to the focus. For instance, if a button is held pressed with the trackball and 
the window loses focus, this method can be used to cancel the press. 

Subclasses of View overriding this method should always call 
super.onFocusLost(). 



*android.view.View.onGenericMotionEvent(MotionEvent)*

public boolean onGenericMotionEvent(android.view.MotionEvent event)

Implement this method to handle generic motion events. 

Generic motion events describe joystick movements, mouse hovers, track pad 
touches, scroll wheel movements and other input events. The 
source(|android.view.MotionEvent|) of the motion event specifies the class of 
input that was received. Implementations of this method must examine the bits 
in the source before processing the event. The following code example shows how 
this is done. 

Generic motion events with source class (|android.view.InputDevice|) are 
delivered to the view under the pointer. All other generic motion events are 
delivered to the focused view. 

public boolean onGenericMotionEvent(MotionEvent event) { if 
(event.isFromSource(InputDevice.SOURCE_CLASS_JOYSTICK)) { if (event.getAction() 
== MotionEvent.ACTION_MOVE) { // process the joystick movement... return true; 
} } if (event.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) { switch 
(event.getAction()) { case MotionEvent.ACTION_HOVER_MOVE: // process the mouse 
hover movement... return true; case MotionEvent.ACTION_SCROLL: // process the 
scroll wheel movement... return true; } } return 
super.onGenericMotionEvent(event); } 


    event - The generic motion event being processed. 

    Returns: True if the event was handled, false otherwise. 

*android.view.View.onHoverChanged(boolean)*

public void onHoverChanged(boolean hovered)

Implement this method to handle hover state changes. 

This method is called whenever the hover state changes as a result of a call to 
(|android.view.View|) . 


    hovered - The current hover state, as returned by {@link #isHovered}. 

*android.view.View.onHoverEvent(MotionEvent)*

public boolean onHoverEvent(android.view.MotionEvent event)

Implement this method to handle hover events. 

This method is called whenever a pointer is hovering into, over, or out of the 
bounds of a view and the view is not currently being touched. Hover events are 
represented as pointer events with action (|android.view.MotionEvent|) , 
(|android.view.MotionEvent|) , or (|android.view.MotionEvent|) . 

The view receives a hover event with action (|android.view.MotionEvent|) when 
the pointer enters the bounds of the view. The view receives a hover event with 
action (|android.view.MotionEvent|) when the pointer has already entered the 
bounds of the view and has moved. The view receives a hover event with action 
(|android.view.MotionEvent|) when the pointer has exited the bounds of the view 
or when the pointer is about to go down due to a button click, tap, or similar 
user action that causes the view to be touched. 

The view should implement this method to return true to indicate that it is 
handling the hover event, such as by changing its drawable state. 

The default implementation calls (|android.view.View|) to update the hovered 
state of the view when a hover enter or hover exit event is received, if the 
view is enabled and is clickable. The default implementation also sends hover 
accessibility events. 


    event - The motion event that describes the hover. 

    Returns: True if the view handled the hover event. 

*android.view.View.onInitializeAccessibilityEvent(AccessibilityEvent)*

public void onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)

Initializes an (|android.view.accessibility.AccessibilityEvent|) with 
information about this View which is the event source. In other words, the 
source of an accessibility event is the view whose state change triggered 
firing the event. 

Example: Setting the password property of an event in addition to properties 
set by the super implementation: 

public void onInitializeAccessibilityEvent(AccessibilityEvent event) { 
super.onInitializeAccessibilityEvent(event); event.setPassword(true); } 

If an (|android.view.View.AccessibilityDelegate|) has been specified via 
calling (|android.view.View|) its (|android.view.View.AccessibilityDelegate|) 
is responsible for handling this call. 

Note: Always call the super implementation before adding information to the 
event, in case the default implementation has basic information to add. 


    event - The event to initialize. 

*android.view.View.onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)*

public void onInitializeAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo info)

Initializes an (|android.view.accessibility.AccessibilityNodeInfo|) with 
information about this view. The base implementation sets: 

(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 
(|android.view.accessibility.AccessibilityNodeInfo|) , 

Subclasses should override this method, call the super implementation, and set 
additional attributes. 

If an (|android.view.View.AccessibilityDelegate|) has been specified via 
calling (|android.view.View|) its (|android.view.View.AccessibilityDelegate|) 
is responsible for handling this call. 


    info - The instance to initialize. 

*android.view.View.onKeyDown(int,KeyEvent)*

public boolean onKeyDown(
  int keyCode,
  android.view.KeyEvent event)

Default implementation of 
KeyEvent.Callback.onKeyDown()(|android.view.KeyEvent.Callback|) : perform press 
of the view when (|android.view.KeyEvent|) or (|android.view.KeyEvent|) is 
released, if the view is enabled and clickable. 

Key presses in software keyboards will generally NOT trigger this listener, 
although some may elect to do so in some situations. Do not rely on this to 
catch software key presses. 


    keyCode - A key code that represents the button pressed, from {@link 
       android.view.KeyEvent}. 
    event - The KeyEvent object that defines the button action. 

*android.view.View.onKeyLongPress(int,KeyEvent)*

public boolean onKeyLongPress(
  int keyCode,
  android.view.KeyEvent event)

Default implementation of 
KeyEvent.Callback.onKeyLongPress()(|android.view.KeyEvent.Callback|) : always 
returns false (doesn't handle the event). Key presses in software keyboards 
will generally NOT trigger this listener, although some may elect to do so in 
some situations. Do not rely on this to catch software key presses. 



*android.view.View.onKeyMultiple(int,int,KeyEvent)*

public boolean onKeyMultiple(
  int keyCode,
  int repeatCount,
  android.view.KeyEvent event)

Default implementation of 
KeyEvent.Callback.onKeyMultiple()(|android.view.KeyEvent.Callback|) : always 
returns false (doesn't handle the event). Key presses in software keyboards 
will generally NOT trigger this listener, although some may elect to do so in 
some situations. Do not rely on this to catch software key presses. 


    keyCode - A key code that represents the button pressed, from {@link 
       android.view.KeyEvent}. 
    repeatCount - The number of times the action was made. 
    event - The KeyEvent object that defines the button action. 

*android.view.View.onKeyPreIme(int,KeyEvent)*

public boolean onKeyPreIme(
  int keyCode,
  android.view.KeyEvent event)

Handle a key event before it is processed by any input method associated with 
the view hierarchy. This can be used to intercept key events in special 
situations before the IME consumes them; a typical example would be handling 
the BACK key to update the application's UI instead of allowing the IME to see 
it and close itself. 


    keyCode - The value in event.getKeyCode(). 
    event - Description of the key event. 

    Returns: If you handled the event, return true. If you want to allow the event to be 
             handled by the next receiver, return false. 

*android.view.View.onKeyShortcut(int,KeyEvent)*

public boolean onKeyShortcut(
  int keyCode,
  android.view.KeyEvent event)

Called on the focused view when a key shortcut event is not handled. Override 
this method to implement local key shortcuts for the View. Key shortcuts can 
also be implemented by setting the shortcut(|android.view.MenuItem|) property 
of menu items. 


    keyCode - The value in event.getKeyCode(). 
    event - Description of the key event. 

    Returns: If you handled the event, return true. If you want to allow the event to be 
             handled by the next receiver, return false. 

*android.view.View.onKeyUp(int,KeyEvent)*

public boolean onKeyUp(
  int keyCode,
  android.view.KeyEvent event)

Default implementation of 
KeyEvent.Callback.onKeyUp()(|android.view.KeyEvent.Callback|) : perform 
clicking of the view when (|android.view.KeyEvent|) or 
(|android.view.KeyEvent|) is released. Key presses in software keyboards will 
generally NOT trigger this listener, although some may elect to do so in some 
situations. Do not rely on this to catch software key presses. 


    keyCode - A key code that represents the button pressed, from {@link 
       android.view.KeyEvent}. 
    event - The KeyEvent object that defines the button action. 

*android.view.View.onLayout(boolean,int,int,int,int)*

protected void onLayout(
  boolean changed,
  int left,
  int top,
  int right,
  int bottom)

Called from layout when this view should assign a size and position to each of 
its children. 

Derived classes with children should override this method and call layout on 
each of their children. 


    changed - This is a new size or position for this view 
    left - Left position, relative to parent 
    top - Top position, relative to parent 
    right - Right position, relative to parent 
    bottom - Bottom position, relative to parent 

*android.view.View.onMeasure(int,int)*

protected void onMeasure(
  int widthMeasureSpec,
  int heightMeasureSpec)

Measure the view and its content to determine the measured width and the 
measured height. This method is invoked by (|android.view.View|) and should be 
overriden by subclasses to provide accurate and efficient measurement of their 
contents. 

CONTRACT: When overriding this method, you must call (|android.view.View|) to 
store the measured width and height of this view. Failure to do so will trigger 
an IllegalStateException, thrown by (|android.view.View|) . Calling the 
superclass' (|android.view.View|) is a valid use. 

The base class implementation of measure defaults to the background size, 
unless a larger size is allowed by the MeasureSpec. Subclasses should override 
(|android.view.View|) to provide better measurements of their content. 

If this method is overridden, it is the subclass's responsibility to make sure 
the measured height and width are at least the view's minimum height and width 
( (|android.view.View|) and (|android.view.View|) ). 


    widthMeasureSpec - horizontal space requirements as imposed by the parent. The requirements are 
       encoded with {@link android.view.View.MeasureSpec}. 
    heightMeasureSpec - vertical space requirements as imposed by the parent. The requirements are 
       encoded with {@link android.view.View.MeasureSpec}. 

*android.view.View.onOverScrolled(int,int,boolean,boolean)*

protected void onOverScrolled(
  int scrollX,
  int scrollY,
  boolean clampedX,
  boolean clampedY)

Called by (|android.view.View|) to respond to the results of an over-scroll 
operation. 


    scrollX - New X scroll value in pixels 
    scrollY - New Y scroll value in pixels 
    clampedX - True if scrollX was clamped to an over-scroll boundary 
    clampedY - True if scrollY was clamped to an over-scroll boundary 

*android.view.View.onPopulateAccessibilityEvent(AccessibilityEvent)*

public void onPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)

Called from (|android.view.View|) giving a chance to this View to populate the 
accessibility event with its text content. While this method is free to modify 
event attributes other than text content, doing so should normally be performed 
in (|android.view.View|) . 

Example: Adding formatted date string to an accessibility event in addition to 
the text added by the super implementation: 

public void onPopulateAccessibilityEvent(AccessibilityEvent event) { 
super.onPopulateAccessibilityEvent(event); final int flags = 
DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_SHOW_WEEKDAY; String 
selectedDateUtterance = DateUtils.formatDateTime(mContext, 
mCurrentDate.getTimeInMillis(), flags); 
event.getText().add(selectedDateUtterance); } 

If an (|android.view.View.AccessibilityDelegate|) has been specified via 
calling (|android.view.View|) its (|android.view.View.AccessibilityDelegate|) 
is responsible for handling this call. 

Note: Always call the super implementation before adding information to the 
event, in case the default implementation has basic information to add. 


    event - The accessibility event which to populate. 

*android.view.View.onResolveDrawables(int)*

public void onResolveDrawables(int layoutDirection)

Called when layout direction has been resolved. 

The default implementation does nothing. 


    layoutDirection - The resolved layout direction. 

*android.view.View.onRestoreInstanceState(Parcelable)*

protected void onRestoreInstanceState(android.os.Parcelable state)

Hook allowing a view to re-apply a representation of its internal state that 
had previously been generated by (|android.view.View|) . This function will 
never be called with a null state. 


    state - The frozen state that had previously been returned by {@link 
       #onSaveInstanceState}. 

*android.view.View.onRtlPropertiesChanged(int)*

public void onRtlPropertiesChanged(int layoutDirection)

Called when any RTL property (layout direction or text direction or text 
alignment) has been changed. 

Subclasses need to override this method to take care of cached information that 
depends on the resolved layout direction, or to inform child views that inherit 
their layout direction. 

The default implementation does nothing. 


    layoutDirection - the direction of the layout 

*android.view.View.onSaveInstanceState()*

protected |android.os.Parcelable| onSaveInstanceState()

Hook allowing a view to generate a representation of its internal state that 
can later be used to create a new instance with that same state. This state 
should only contain information that is not persistent or can not be 
reconstructed later. For example, you will never store your current position on 
screen because that will be computed again when a new instance of the view is 
placed in its view hierarchy. 

Some examples of things you may store here: the current cursor position in a 
text view (but usually not the text itself since that is stored in a content 
provider or other persistent storage), the currently selected item in a list 
view. 



    Returns: Returns a Parcelable object containing the view's current dynamic state, or 
             null if there is nothing interesting to save. The default 
             implementation returns null. 

*android.view.View.onScreenStateChanged(int)*

public void onScreenStateChanged(int screenState)

This method is called whenever the state of the screen this view is attached to 
changes. A state change will usually occurs when the screen turns on or off 
(whether it happens automatically or the user does it manually.) 


    screenState - The new state of the screen. Can be either {@link #SCREEN_STATE_ON} or {@link 
       #SCREEN_STATE_OFF} 

*android.view.View.onScrollChanged(int,int,int,int)*

protected void onScrollChanged(
  int l,
  int t,
  int oldl,
  int oldt)

This is called in response to an internal scroll in this view (i.e., the view 
scrolled its own contents). This is typically as a result of 
(|android.view.View|) or (|android.view.View|) having been called. 


    l - Current horizontal scroll origin. 
    t - Current vertical scroll origin. 
    oldl - Previous horizontal scroll origin. 
    oldt - Previous vertical scroll origin. 

*android.view.View.onSetAlpha(int)*

protected boolean onSetAlpha(int alpha)

Invoked if there is a Transform that involves alpha. Subclass that can draw 
themselves with the specified alpha should return true, and then respect that 
alpha when their onDraw() is called. If this returns false then the view may be 
redirected to draw into an offscreen buffer to fulfill the request, which will 
look fine, but may be slower than if the subclass handles it internally. The 
default implementation returns false. 


    alpha - The alpha (0..255) to apply to the view's drawing 

    Returns: true if the view can draw with the specified alpha. 

*android.view.View.onSizeChanged(int,int,int,int)*

protected void onSizeChanged(
  int w,
  int h,
  int oldw,
  int oldh)

This is called during layout when the size of this view has changed. If you 
were just added to the view hierarchy, you're called with the old values of 0. 


    w - Current width of this view. 
    h - Current height of this view. 
    oldw - Old width of this view. 
    oldh - Old height of this view. 

*android.view.View.onStartTemporaryDetach()*

public void onStartTemporaryDetach()

This is called when a container is going to temporarily detach a child, with 
ViewGroup.detachViewFromParent(|android.view.ViewGroup|) . It will either be 
followed by (|android.view.View|) or (|android.view.View|) when the container 
is done. 



*android.view.View.onTouchEvent(MotionEvent)*

public boolean onTouchEvent(android.view.MotionEvent event)

Implement this method to handle touch screen motion events. 

If this method is used to detect click actions, it is recommended that the 
actions be performed by implementing and calling (|android.view.View|) . This 
will ensure consistent system behavior, including: 

obeying click sound preferences dispatching OnClickListener calls handling 
ACTION_CLICK(|android.view.accessibility.AccessibilityNodeInfo|) when 
accessibility features are enabled 


    event - The motion event. 

    Returns: True if the event was handled, false otherwise. 

*android.view.View.onTrackballEvent(MotionEvent)*

public boolean onTrackballEvent(android.view.MotionEvent event)

Implement this method to handle trackball motion events. The relative movement 
of the trackball since the last event can be retrieve with 
MotionEvent.getX()(|android.view.MotionEvent|) and 
MotionEvent.getY()(|android.view.MotionEvent|) . These are normalized so that a 
movement of 1 corresponds to the user pressing one DPAD key (so they will often 
be fractional values, representing the more fine-grained movement information 
available from a trackball). 


    event - The motion event. 

    Returns: True if the event was handled, false otherwise. 

*android.view.View.onVisibilityChanged(View,int)*

protected void onVisibilityChanged(
  android.view.View changedView,
  int visibility)

Called when the visibility of the view or an ancestor of the view is changed. 


    changedView - The view whose visibility changed. Could be 'this' or an ancestor view. 
    visibility - The new visibility of changedView: {@link #VISIBLE}, {@link #INVISIBLE} or 
       {@link #GONE}. 

*android.view.View.onWindowFocusChanged(boolean)*

public void onWindowFocusChanged(boolean hasWindowFocus)

Called when the window containing this view gains or loses focus. Note that 
this is separate from view focus: to receive key events, both your view and its 
window must have focus. If a window is displayed on top of yours that takes 
input focus, then your own window will lose focus but the view focus will 
remain unchanged. 


    hasWindowFocus - True if the window containing this view now has focus, false otherwise. 

*android.view.View.onWindowSystemUiVisibilityChanged(int)*

public void onWindowSystemUiVisibilityChanged(int visible)

Override to find out when the window's requested system UI visibility has 
changed, that is the value returned by (|android.view.View|) . This is 
different from the callbacks received through (|android.view.View|) in that 
this is only telling you about the local request of the window, not the actual 
values applied by the system. 



*android.view.View.onWindowVisibilityChanged(int)*

protected void onWindowVisibilityChanged(int visibility)

Called when the window containing has change its visibility (between 
(|android.view.View|) , (|android.view.View|) , and (|android.view.View|) ). 
Note that this tells you whether or not your window is being made visible to 
the window manager; this does not tell you whether or not your window is 
obscured by other windows on the screen, even if it is itself visible. 


    visibility - The new visibility of the window. 

*android.view.View.outputDirtyFlags(String,boolean,int)*

public void outputDirtyFlags(
  java.lang.String indent,
  boolean clear,
  int clearMask)

Debugging utility which recursively outputs the dirty state of a view and its 
descendants. 



*android.view.View.overScrollBy(int,int,int,int,int,int,int,int,boolean)*

protected boolean overScrollBy(
  int deltaX,
  int deltaY,
  int scrollX,
  int scrollY,
  int scrollRangeX,
  int scrollRangeY,
  int maxOverScrollX,
  int maxOverScrollY,
  boolean isTouchEvent)

Scroll the view with standard behavior for scrolling beyond the normal content 
boundaries. Views that call this method should override (|android.view.View|) 
to respond to the results of an over-scroll operation. 

Views can use this method to handle any touch or fling-based scrolling. 


    deltaX - Change in X in pixels 
    deltaY - Change in Y in pixels 
    scrollX - Current X scroll value in pixels before applying deltaX 
    scrollY - Current Y scroll value in pixels before applying deltaY 
    scrollRangeX - Maximum content scroll range along the X axis 
    scrollRangeY - Maximum content scroll range along the Y axis 
    maxOverScrollX - Number of pixels to overscroll by in either direction along the X axis. 
    maxOverScrollY - Number of pixels to overscroll by in either direction along the Y axis. 
    isTouchEvent - true if this scroll operation is the result of a touch event. 

    Returns: true if scrolling was clamped to an over-scroll boundary along either axis, 
             false otherwise. 

*android.view.View.performAccessibilityAction(int,Bundle)*

public boolean performAccessibilityAction(
  int action,
  android.os.Bundle arguments)

Performs the specified accessibility action on the view. For possible 
accessibility actions look at 
(|android.view.accessibility.AccessibilityNodeInfo|) . 

If an (|android.view.View.AccessibilityDelegate|) has been specified via 
calling (|android.view.View|) its (|android.view.View.AccessibilityDelegate|) 
is responsible for handling this call. 


    action - The action to perform. 
    arguments - Optional action arguments. 

    Returns: Whether the action was performed. 

*android.view.View.performButtonActionOnTouchDown(MotionEvent)*

protected boolean performButtonActionOnTouchDown(android.view.MotionEvent event)

Performs button-related actions during a touch down event. 


    event - The event. 

    Returns: True if the down was consumed. 

*android.view.View.performClick()*

public boolean performClick()

Call this view's OnClickListener, if it is defined. Performs all normal actions 
associated with clicking: reporting accessibility event, playing a sound, etc. 



    Returns: True there was an assigned OnClickListener that was called, false otherwise is 
             returned. 

*android.view.View.performHapticFeedback(int)*

public boolean performHapticFeedback(int feedbackConstant)

BZZZTT!!1! 

Provide haptic feedback to the user for this view. 

The framework will provide haptic feedback for some built in actions, such as 
long presses, but you may wish to provide feedback for your own widget. 

The feedback will only be performed if (|android.view.View|) is true. 


    feedbackConstant - One of the constants defined in {@link HapticFeedbackConstants} 

*android.view.View.performHapticFeedback(int,int)*

public boolean performHapticFeedback(
  int feedbackConstant,
  int flags)

BZZZTT!!1! 

Like (|android.view.View|) , with additional options. 


    feedbackConstant - One of the constants defined in {@link HapticFeedbackConstants} 
    flags - Additional flags as per {@link HapticFeedbackConstants}. 

*android.view.View.performLongClick()*

public boolean performLongClick()

Call this view's OnLongClickListener, if it is defined. Invokes the context 
menu if the OnLongClickListener did not consume the event. 



    Returns: True if one of the above receivers consumed the event, false otherwise. 

*android.view.View.playSoundEffect(int)*

public void playSoundEffect(int soundConstant)

Play a sound effect for this view. 

The framework will play sound effects for some built in actions, such as 
clicking, but you may wish to play these effects in your widget, for instance, 
for internal navigation. 

The sound effect will only be played if sound effects are enabled by the user, 
and (|android.view.View|) is true. 


    soundConstant - One of the constants defined in {@link SoundEffectConstants} 

*android.view.View.pointInView(float,float,float)*

public boolean pointInView(
  float localX,
  float localY,
  float slop)

Utility method to determine whether the given point, in local coordinates, is 
inside the view, where the area of the view is expanded by the slop factor. 
This method is called while processing touch-move events to determine if the 
event is still within the view. 



*android.view.View.post(Runnable)*

public boolean post(java.lang.Runnable action)

Causes the Runnable to be added to the message queue. The runnable will be run 
on the user interface thread. 


    action - The Runnable that will be executed. 

    Returns: Returns true if the Runnable was successfully placed in to the message queue. 
             Returns false on failure, usually because the looper processing 
             the message queue is exiting. 

*android.view.View.postDelayed(Runnable,long)*

public boolean postDelayed(
  java.lang.Runnable action,
  long delayMillis)

Causes the Runnable to be added to the message queue, to be run after the 
specified amount of time elapses. The runnable will be run on the user 
interface thread. 


    action - The Runnable that will be executed. 
    delayMillis - The delay (in milliseconds) until the Runnable will be executed. 

    Returns: true if the Runnable was successfully placed in to the message queue. Returns 
             false on failure, usually because the looper processing the 
             message queue is exiting. Note that a result of true does not mean 
             the Runnable will be processed -- if the looper is quit before the 
             delivery time of the message occurs then the message will be 
             dropped. 

*android.view.View.postInvalidate()*

public void postInvalidate()

Cause an invalidate to happen on a subsequent cycle through the event loop. Use 
this to invalidate the View from a non-UI thread. 

This method can be invoked from outside of the UI thread only when this View is 
attached to a window. 



*android.view.View.postInvalidate(int,int,int,int)*

public void postInvalidate(
  int left,
  int top,
  int right,
  int bottom)

Cause an invalidate of the specified area to happen on a subsequent cycle 
through the event loop. Use this to invalidate the View from a non-UI thread. 

This method can be invoked from outside of the UI thread only when this View is 
attached to a window. 


    left - The left coordinate of the rectangle to invalidate. 
    top - The top coordinate of the rectangle to invalidate. 
    right - The right coordinate of the rectangle to invalidate. 
    bottom - The bottom coordinate of the rectangle to invalidate. 

*android.view.View.postInvalidateDelayed(long)*

public void postInvalidateDelayed(long delayMilliseconds)

Cause an invalidate to happen on a subsequent cycle through the event loop. 
Waits for the specified amount of time. 

This method can be invoked from outside of the UI thread only when this View is 
attached to a window. 


    delayMilliseconds - the duration in milliseconds to delay the invalidation by 

*android.view.View.postInvalidateDelayed(long,int,int,int,int)*

public void postInvalidateDelayed(
  long delayMilliseconds,
  int left,
  int top,
  int right,
  int bottom)

Cause an invalidate of the specified area to happen on a subsequent cycle 
through the event loop. Waits for the specified amount of time. 

This method can be invoked from outside of the UI thread only when this View is 
attached to a window. 


    delayMilliseconds - the duration in milliseconds to delay the invalidation by 
    left - The left coordinate of the rectangle to invalidate. 
    top - The top coordinate of the rectangle to invalidate. 
    right - The right coordinate of the rectangle to invalidate. 
    bottom - The bottom coordinate of the rectangle to invalidate. 

*android.view.View.postInvalidateOnAnimation()*

public void postInvalidateOnAnimation()

Cause an invalidate to happen on the next animation time step, typically the 
next display frame. 

This method can be invoked from outside of the UI thread only when this View is 
attached to a window. 



*android.view.View.postInvalidateOnAnimation(int,int,int,int)*

public void postInvalidateOnAnimation(
  int left,
  int top,
  int right,
  int bottom)

Cause an invalidate of the specified area to happen on the next animation time 
step, typically the next display frame. 

This method can be invoked from outside of the UI thread only when this View is 
attached to a window. 


    left - The left coordinate of the rectangle to invalidate. 
    top - The top coordinate of the rectangle to invalidate. 
    right - The right coordinate of the rectangle to invalidate. 
    bottom - The bottom coordinate of the rectangle to invalidate. 

*android.view.View.postOnAnimation(Runnable)*

public void postOnAnimation(java.lang.Runnable action)

Causes the Runnable to execute on the next animation time step. The runnable 
will be run on the user interface thread. 


    action - The Runnable that will be executed. 

*android.view.View.postOnAnimationDelayed(Runnable,long)*

public void postOnAnimationDelayed(
  java.lang.Runnable action,
  long delayMillis)

Causes the Runnable to execute on the next animation time step, after the 
specified amount of time elapses. The runnable will be run on the user 
interface thread. 


    action - The Runnable that will be executed. 
    delayMillis - The delay (in milliseconds) until the Runnable will be executed. 

*android.view.View.recomputePadding()*

protected void recomputePadding()





*android.view.View.refreshDrawableState()*

public void refreshDrawableState()

Call this to force a view to update its drawable state. This will cause 
drawableStateChanged to be called on this view. Views that are interested in 
the new state should call getDrawableState. 



*android.view.View.removeCallbacks(Runnable)*

public boolean removeCallbacks(java.lang.Runnable action)

Removes the specified Runnable from the message queue. 


    action - The Runnable to remove from the message handling queue 

    Returns: true if this view could ask the Handler to remove the Runnable, false 
             otherwise. When the returned value is true, the Runnable may or 
             may not have been actually removed from the message queue (for 
             instance, if the Runnable was not in the queue already.) 

*android.view.View.removeOnAttachStateChangeListener(View.OnAttachStateChangeListener)*

public void removeOnAttachStateChangeListener(android.view.View.OnAttachStateChangeListener listener)

Remove a listener for attach state changes. The listener will receive no 
further notification of window attach/detach events. 


    listener - Listener to remove 

*android.view.View.removeOnLayoutChangeListener(View.OnLayoutChangeListener)*

public void removeOnLayoutChangeListener(android.view.View.OnLayoutChangeListener listener)

Remove a listener for layout changes. 


    listener - The listener for layout bounds change. 

*android.view.View.requestAccessibilityFocus()*

public boolean requestAccessibilityFocus()

Call this to try to give accessibility focus to this view. 

A view will not actually take focus if 
(|android.view.accessibility.AccessibilityManager|) returns false or the view 
is no visible or the view already has accessibility focus. 

See also (|android.view.View|) , which is what you call to say that you have 
focus, and you want your parent to look for the next one. 



    Returns: Whether this view actually took accessibility focus. 

*android.view.View.requestFitSystemWindows()*

public void requestFitSystemWindows()

Ask that a new dispatch of (|android.view.View|) be performed. 



*android.view.View.requestFocus()*

public final boolean requestFocus()

Call this to try to give focus to a specific view or to one of its descendants. 

A view will not actually take focus if it is not focusable ( 
(|android.view.View|) returns false), or if it is focusable and it is not 
focusable in touch mode ( (|android.view.View|) ) while the device is in touch 
mode. 

See also (|android.view.View|) , which is what you call to say that you have 
focus, and you want your parent to look for the next one. 

This is equivalent to calling (|android.view.View|) with arguments 
(|android.view.View|) and null. 



    Returns: Whether this view or one of its descendants actually took focus. 

*android.view.View.requestFocus(int)*

public final boolean requestFocus(int direction)

Call this to try to give focus to a specific view or to one of its descendants 
and give it a hint about what direction focus is heading. 

A view will not actually take focus if it is not focusable ( 
(|android.view.View|) returns false), or if it is focusable and it is not 
focusable in touch mode ( (|android.view.View|) ) while the device is in touch 
mode. 

See also (|android.view.View|) , which is what you call to say that you have 
focus, and you want your parent to look for the next one. 

This is equivalent to calling (|android.view.View|) with null set for the 
previously focused rectangle. 


    direction - One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT 

    Returns: Whether this view or one of its descendants actually took focus. 

*android.view.View.requestFocus(int,Rect)*

public boolean requestFocus(
  int direction,
  Rect previouslyFocusedRect)

Call this to try to give focus to a specific view or to one of its descendants 
and give it hints about the direction and a specific rectangle that the focus 
is coming from. The rectangle can help give larger views a finer grained hint 
about where focus is coming from, and therefore, where to show selection, or 
forward focus change internally. 

A view will not actually take focus if it is not focusable ( 
(|android.view.View|) returns false), or if it is focusable and it is not 
focusable in touch mode ( (|android.view.View|) ) while the device is in touch 
mode. 

A View will not take focus if it is not visible. 

A View will not take focus if one of its parents has (|android.view.ViewGroup|) 
equal to (|android.view.ViewGroup|) . 

See also (|android.view.View|) , which is what you call to say that you have 
focus, and you want your parent to look for the next one. 

You may wish to override this method if your custom (|android.view.View|) has 
an internal (|android.view.View|) that it wishes to forward the request to. 


    direction - One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT 
    previouslyFocusedRect - The rectangle (in this View's coordinate system) to give a finer grained hint 
       about where focus is coming from. May be null if there is no hint. 

    Returns: Whether this view or one of its descendants actually took focus. 

*android.view.View.requestFocusFromTouch()*

public final boolean requestFocusFromTouch()

Call this to try to give focus to a specific view or to one of its descendants. 
This is a special variant of (|android.view.View|) that will allow views that 
are not focuable in touch mode to request focus when they are touched. 



    Returns: Whether this view or one of its descendants actually took focus. 

*android.view.View.requestLayout()*

public void requestLayout()

Call this when something has changed which has invalidated the layout of this 
view. This will schedule a layout pass of the view tree. This should not be 
called while the view hierarchy is currently in a layout pass ( 
(|android.view.View|) . If layout is happening, the request may be honored at 
the end of the current layout pass (and then layout will run again) or after 
the current frame is drawn and the next layout occurs. 

Subclasses which override this method should call the superclass method to 
handle possible request-during-layout errors correctly. 



*android.view.View.requestRectangleOnScreen(Rect)*

public boolean requestRectangleOnScreen(Rect rectangle)

Request that a rectangle of this view be visible on the screen, scrolling if 
necessary just enough. 

A View should call this if it maintains some notion of which part of its 
content is interesting. For example, a text editing view should call this when 
its cursor moves. 


    rectangle - The rectangle. 

    Returns: Whether any parent scrolled. 

*android.view.View.requestRectangleOnScreen(Rect,boolean)*

public boolean requestRectangleOnScreen(
  Rect rectangle,
  boolean immediate)

Request that a rectangle of this view be visible on the screen, scrolling if 
necessary just enough. 

A View should call this if it maintains some notion of which part of its 
content is interesting. For example, a text editing view should call this when 
its cursor moves. 

When immediate is set to true, scrolling will not be animated. 


    rectangle - The rectangle. 
    immediate - True to forbid animated scrolling, false otherwise 

    Returns: Whether any parent scrolled. 

*android.view.View.resetPaddingToInitialValues()*

public void resetPaddingToInitialValues()





*android.view.View.resetResolvedDrawables()*

protected void resetResolvedDrawables()





*android.view.View.resetResolvedLayoutDirection()*

public void resetResolvedLayoutDirection()

Reset the resolved layout direction. Layout direction will be resolved during a 
call to (|android.view.View|) . 



*android.view.View.resetResolvedPadding()*

public void resetResolvedPadding()

Reset the resolved layout direction. 



*android.view.View.resetResolvedTextAlignment()*

public void resetResolvedTextAlignment()

Reset resolved text alignment. Text alignment will be resolved during a call to 
(|android.view.View|) . 



*android.view.View.resetResolvedTextDirection()*

public void resetResolvedTextDirection()

Reset resolved text direction. Text direction will be resolved during a call to 
(|android.view.View|) . 



*android.view.View.resetRtlProperties()*

public void resetRtlProperties()

Reset resolution of all RTL related properties. 



*android.view.View.resolveDrawables()*

protected void resolveDrawables()

Resolve the Drawables depending on the layout direction. This is implicitly 
supposing that the View directionality can and will be resolved before its 
Drawables. 

Will call (|android.view.View|) when resolution is done. 



*android.view.View.resolveLayoutDirection()*

public boolean resolveLayoutDirection()

Resolve and cache the layout direction. LTR is set initially. This is 
implicitly supposing that the parent directionality can and will be resolved 
before its children. 



    Returns: true if resolution has been done, false otherwise. 

*android.view.View.resolveLayoutParams()*

public void resolveLayoutParams()

Resolve the layout parameters depending on the resolved layout direction 



*android.view.View.resolvePadding()*

public void resolvePadding()

Resolves padding depending on layout direction, if applicable, and recomputes 
internal padding values to adjust for scroll bars. 



*android.view.View.resolveRtlPropertiesIfNeeded()*

public boolean resolveRtlPropertiesIfNeeded()

Resolve all RTL related properties. 



    Returns: true if resolution of RTL properties has been done 

*android.view.View.resolveSize(int,int)*

public static int resolveSize(
  int size,
  int measureSpec)

Version of (|android.view.View|) returning only the (|android.view.View|) bits 
of the result. 



*android.view.View.resolveSizeAndState(int,int,int)*

public static int resolveSizeAndState(
  int size,
  int measureSpec,
  int childMeasuredState)

Utility to reconcile a desired size and state, with constraints imposed by a 
MeasureSpec. Will take the desired size, unless a different size is imposed by 
the constraints. The returned value is a compound integer, with the resolved 
size in the (|android.view.View|) bits and optionally the bit 
(|android.view.View|) set if the resulting size is smaller than the size the 
view wants to be. 


    size - How big the view wants to be 
    measureSpec - Constraints imposed by the parent 

    Returns: Size information bit mask as defined by {@link #MEASURED_SIZE_MASK} and {@link 
             #MEASURED_STATE_TOO_SMALL}. 

*android.view.View.resolveTextAlignment()*

public boolean resolveTextAlignment()

Resolve the text alignment. 



    Returns: true if resolution has been done, false otherwise. 

*android.view.View.resolveTextDirection()*

public boolean resolveTextDirection()

Resolve the text direction. 



    Returns: true if resolution has been done, false otherwise. 

*android.view.View.restoreHierarchyState(SparseArray<Parcelable>)*

public void restoreHierarchyState(android.util.SparseArray<android.os.Parcelable> container)

Restore this view hierarchy's frozen state from the given container. 


    container - The SparseArray which holds previously frozen states. 

*android.view.View.saveHierarchyState(SparseArray<Parcelable>)*

public void saveHierarchyState(android.util.SparseArray<android.os.Parcelable> container)

Store this view hierarchy's frozen state into the given container. 


    container - The SparseArray in which to save the view's state. 

*android.view.View.scheduleDrawable(Drawable,Runnable,long)*

public void scheduleDrawable(
  Drawable who,
  java.lang.Runnable what,
  long when)

Schedules an action on a drawable to occur at a specified time. 


    who - the recipient of the action 
    what - the action to run on the drawable 
    when - the time at which the action must occur. Uses the {@link 
       SystemClock#uptimeMillis} timebase. 

*android.view.View.scrollBy(int,int)*

public void scrollBy(
  int x,
  int y)

Move the scrolled position of your view. This will cause a call to 
(|android.view.View|) and the view will be invalidated. 


    x - the amount of pixels to scroll by horizontally 
    y - the amount of pixels to scroll by vertically 

*android.view.View.scrollTo(int,int)*

public void scrollTo(
  int x,
  int y)

Set the scrolled position of your view. This will cause a call to 
(|android.view.View|) and the view will be invalidated. 


    x - the x position to scroll to 
    y - the y position to scroll to 

*android.view.View.sendAccessibilityEvent(int)*

public void sendAccessibilityEvent(int eventType)

Sends an accessibility event of the given type. If accessibility is not enabled 
this method has no effect. The default implementation calls 
(|android.view.View|) first to populate information about the event source 
(this View), then calls (|android.view.View|) to populate the text content of 
the event source including its descendants, and last calls 
(|android.view.ViewParent|) on its parent to resuest sending of the event to 
interested parties. 

If an (|android.view.View.AccessibilityDelegate|) has been specified via 
calling (|android.view.View|) its (|android.view.View.AccessibilityDelegate|) 
is responsible for handling this call. 


    eventType - The type of the event to send, as defined by several types from {@link 
       android.view.accessibility.AccessibilityEvent}, such as {@link 
       android.view.accessibility.AccessibilityEvent#TYPE_VIEW_CLICKED} or 
       {@link 
       android.view.accessibility.AccessibilityEvent#TYPE_VIEW_HOVER_ENTER}. 

*android.view.View.sendAccessibilityEventUnchecked(AccessibilityEvent)*

public void sendAccessibilityEventUnchecked(android.view.accessibility.AccessibilityEvent event)

This method behaves exactly as (|android.view.View|) but takes as an argument 
an empty (|android.view.accessibility.AccessibilityEvent|) and does not perform 
a check whether accessibility is enabled. 

If an (|android.view.View.AccessibilityDelegate|) has been specified via 
calling (|android.view.View|) its (|android.view.View.AccessibilityDelegate|) 
is responsible for handling this call. 


    event - The event to send. 

*android.view.View.setAccessibilityDelegate(View.AccessibilityDelegate)*

public void setAccessibilityDelegate(android.view.View.AccessibilityDelegate delegate)

Sets a delegate for implementing accessibility support via composition as 
opposed to inheritance. The delegate's primary use is for implementing 
backwards compatible widgets. For more details see 
(|android.view.View.AccessibilityDelegate|) . 


    delegate - The delegate instance. 

*android.view.View.setAccessibilityLiveRegion(int)*

public void setAccessibilityLiveRegion(int mode)

Sets the live region mode for this view. This indicates to accessibility 
services whether they should automatically notify the user about changes to the 
view's content description or text, or to the content descriptions or text of 
the view's children (where applicable). 

For example, in a login screen with a TextView that displays an "incorrect 
password" notification, that view should be marked as a live region with mode 
(|android.view.View|) . 

To disable change notifications for this view, use (|android.view.View|) . This 
is the default live region mode for most views. 

To indicate that the user should be notified of changes, use 
(|android.view.View|) . 

If the view's changes should interrupt ongoing speech and notify the user 
immediately, use (|android.view.View|) . 


    mode - The live region mode for this view, one of: 

{@link #ACCESSIBILITY_LIVE_REGION_NONE} {@link 
       #ACCESSIBILITY_LIVE_REGION_POLITE} {@link 
       #ACCESSIBILITY_LIVE_REGION_ASSERTIVE} 

*android.view.View.setAccessibilitySelection(int,int)*

public void setAccessibilitySelection(
  int start,
  int end)





*android.view.View.setActivated(boolean)*

public void setActivated(boolean activated)

Changes the activated state of this view. A view can be activated or not. Note 
that activation is not the same as selection. Selection is a transient 
property, representing the view (hierarchy) the user is currently interacting 
with. Activation is a longer-term state that the user can move views in and out 
of. For example, in a list view with single or multiple selection enabled, the 
views in the current selection set are activated. (Um, yeah, we are deeply 
sorry about the terminology here.) The activated state is propagated down to 
children of the view it is set on. 


    activated - true if the view must be activated, false otherwise 

*android.view.View.setAlpha(float)*

public void setAlpha(float alpha)

Sets the opacity of the view. This is a value from 0 to 1, where 0 means the 
view is completely transparent and 1 means the view is completely opaque. 

Note that setting alpha to a translucent value (0 

For a view with a frequently changing alpha, such as during a fading animation, 
it is strongly recommended for performance reasons to either override 
(|android.view.View|) to return false if appropriate, or setting a layer 
type(|android.view.View|) on the view. 

If this view overrides (|android.view.View|) to return true, then this view is 
responsible for applying the opacity itself. 

Note that if the view is backed by a layer(|android.view.View|) and is 
associated with a layer paint(|android.view.View|) , setting an alpha value 
less than 1.0 will supercede the alpha of the layer paint. 


    alpha - The opacity of the view. 

*android.view.View.setAnimation(Animation)*

public void setAnimation(android.view.animation.Animation animation)

Sets the next animation to play for this view. If you want the animation to 
play immediately, use (|android.view.View|) instead. This method provides 
allows fine-grained control over the start time and invalidation, but you must 
make sure that 1) the animation has a start time set, and 2) the view's parent 
(which controls animations on its children) will be invalidated when the 
animation is supposed to start. 


    animation - The next animation, or null. 

*android.view.View.setBackground(Drawable)*

public void setBackground(Drawable background)

Set the background to a given Drawable, or remove the background. If the 
background has padding, this View's padding is set to the background's padding. 
However, when a background is removed, this View's padding isn't touched. If 
setting the padding is desired, please use (|android.view.View|) . 


    background - The Drawable to use as the background, or null to remove the background 

*android.view.View.setBackgroundColor(int)*

public void setBackgroundColor(int color)

Sets the background color for this view. 


    color - the color of the background 

*android.view.View.setBackgroundDrawable(Drawable)*

public void setBackgroundDrawable(Drawable background)



    Deprecated: use {@link #setBackground(Drawable)} instead


*android.view.View.setBackgroundResource(int)*

public void setBackgroundResource(int resid)

Set the background to a given resource. The resource should refer to a Drawable 
object or 0 to remove the background. 


    resid - The identifier of the resource. 

*android.view.View.setBottom(int)*

public final void setBottom(int bottom)

Sets the bottom position of this view relative to its parent. This method is 
meant to be called by the layout system and should not generally be called 
otherwise, because the property may be changed at any time by the layout. 


    bottom - The bottom of this view, in pixels. 

*android.view.View.setCameraDistance(float)*

public void setCameraDistance(float distance)

Sets the distance along the Z axis (orthogonal to the X/Y plane on which views 
are drawn) from the camera to this view. The camera's distance affects 3D 
transformations, for instance rotations around the X and Y axis. If the 
rotationX or rotationY properties are changed and this view is large (more than 
half the size of the screen), it is recommended to always use a camera distance 
that's greater than the height (X axis rotation) or the width (Y axis rotation) 
of this view. 

The distance of the camera from the view plane can have an affect on the 
perspective distortion of the view when it is rotated around the x or y axis. 
For example, a large distance will result in a large viewing angle, and there 
will not be much perspective distortion of the view as it rotates. A short 
distance may cause much more perspective distortion upon rotation, and can also 
result in some drawing artifacts if the rotated view ends up partially behind 
the camera (which is why the recommendation is to use a distance at least as 
far as the size of the view, if the view is to be rotated.) 

The distance is expressed in "depth pixels." The default distance depends on 
the screen density. For instance, on a medium density display, the default 
distance is 1280. On a high density display, the default distance is 1920. 

If you want to specify a distance that leads to visually consistent results 
across various densities, use the following formula: 

float scale = context.getResources().getDisplayMetrics().density; 
view.setCameraDistance(distance * scale); 

The density scale factor of a high density display is 1.5, and 1920 = 1280 * 
1.5. 


    distance - The distance in "depth pixels", if negative the opposite value is used 

*android.view.View.setClickable(boolean)*

public void setClickable(boolean clickable)

Enables or disables click events for this view. When a view is clickable it 
will change its state to "pressed" on every click. Subclasses should set the 
view clickable to visually react to user's clicks. 


    clickable - true to make the view clickable, false otherwise 

*android.view.View.setClipBounds(Rect)*

public void setClipBounds(Rect clipBounds)

Sets a rectangular area on this view to which the view will be clipped when it 
is drawn. Setting the value to null will remove the clip bounds and the view 
will draw normally, using its full bounds. 


    clipBounds - The rectangular area, in the local coordinates of this view, to which future 
       drawing operations will be clipped. 

*android.view.View.setContentDescription(CharSequence)*

public void setContentDescription(java.lang.CharSequence contentDescription)

Sets the (|android.view.View|) description. It briefly describes the view and 
is primarily used for accessibility support. Set this property to enable better 
accessibility support for your application. This is especially true for views 
that do not have textual representation (For example, ImageButton). 


    contentDescription - The content description. 

*android.view.View.setDisabledSystemUiVisibility(int)*

public void setDisabledSystemUiVisibility(int flags)





*android.view.View.setDrawingCacheBackgroundColor(int)*

public void setDrawingCacheBackgroundColor(int color)

Setting a solid background color for the drawing cache's bitmaps will improve 
performance and memory usage. Note, though that this should only be used if 
this view will always be drawn on top of a solid color. 


    color - The background color to use for the drawing cache's bitmap 

*android.view.View.setDrawingCacheEnabled(boolean)*

public void setDrawingCacheEnabled(boolean enabled)

Enables or disables the drawing cache. When the drawing cache is enabled, the 
next call to (|android.view.View|) or (|android.view.View|) will draw the view 
in a bitmap. Calling (|android.view.View|) will not draw from the cache when 
the cache is enabled. To benefit from the cache, you must request the drawing 
cache by calling (|android.view.View|) and draw it on screen if the returned 
bitmap is not null. 

Enabling the drawing cache is similar to setting a layer(|android.view.View|) 
when hardware acceleration is turned off. When hardware acceleration is turned 
on, enabling the drawing cache has no effect on rendering because the system 
uses a different mechanism for acceleration which ignores the flag. If you want 
to use a Bitmap for the view, even when hardware acceleration is enabled, see 
(|android.view.View|) for information on how to enable software and hardware 
layers. 

This API can be used to manually generate a bitmap copy of this view, by 
setting the flag to true and calling (|android.view.View|) . 


    enabled - true to enable the drawing cache, false otherwise 

*android.view.View.setDrawingCacheQuality(int)*

public void setDrawingCacheQuality(int quality)

Set the drawing cache quality of this view. This value is used only when the 
drawing cache is enabled 


    quality - One of {@link #DRAWING_CACHE_QUALITY_AUTO}, {@link #DRAWING_CACHE_QUALITY_LOW}, 
       or {@link #DRAWING_CACHE_QUALITY_HIGH} 

*android.view.View.setDuplicateParentStateEnabled(boolean)*

public void setDuplicateParentStateEnabled(boolean enabled)

Enables or disables the duplication of the parent's state into this view. When 
duplication is enabled, this view gets its drawable state from its parent 
rather than from its own internal properties. 

Note: in the current implementation, setting this property to true after the 
view was added to a ViewGroup might have no effect at all. This property should 
always be used from XML or set to true before adding this view to a ViewGroup. 

Note: if this view's parent addStateFromChildren property is enabled and this 
property is enabled, an exception will be thrown. 

Note: if the child view uses and updates additionnal states which are unknown 
to the parent, these states should not be affected by this method. 


    enabled - True to enable duplication of the parent's drawable state, false to disable it. 

*android.view.View.setEnabled(boolean)*

public void setEnabled(boolean enabled)

Set the enabled state of this view. The interpretation of the enabled state 
varies by subclass. 


    enabled - True if this view is enabled, false otherwise. 

*android.view.View.setFadingEdgeLength(int)*

public void setFadingEdgeLength(int length)

Set the size of the faded edge used to indicate that more content in this view 
is available. Will not change whether the fading edge is enabled; use 
(|android.view.View|) or (|android.view.View|) to enable the fading edge for 
the vertical or horizontal fading edges. 


    length - The size in pixels of the faded edge used to indicate that more content in this 
       view is visible. 

*android.view.View.setFilterTouchesWhenObscured(boolean)*

public void setFilterTouchesWhenObscured(boolean enabled)

Sets whether the framework should discard touches when the view's window is 
obscured by another visible window. Refer to the (|android.view.View|) security 
documentation for more details. 


    enabled - True if touch filtering should be enabled. 

*android.view.View.setFitsSystemWindows(boolean)*

public void setFitsSystemWindows(boolean fitSystemWindows)

Sets whether or not this view should account for system screen decorations such 
as the status bar and inset its content; that is, controlling whether the 
default implementation of (|android.view.View|) will be executed. See that 
method for more details. 

Note that if you are providing your own implementation of (|android.view.View|) 
, then there is no need to set this flag to true -- your implementation will be 
overriding the default implementation that checks this flag. 


    fitSystemWindows - If true, then the default implementation of {@link #fitSystemWindows(Rect)} 
       will be executed. 

*android.view.View.setFocusable(boolean)*

public void setFocusable(boolean focusable)

Set whether this view can receive the focus. 

Setting this to false will also ensure that this view is not focusable in touch 
mode. 


    focusable - If true, this view can receive the focus. 

*android.view.View.setFocusableInTouchMode(boolean)*

public void setFocusableInTouchMode(boolean focusableInTouchMode)

Set whether this view can receive focus while in touch mode. 

Setting this to true will also ensure that this view is focusable. 


    focusableInTouchMode - If true, this view can receive the focus while in touch mode. 

*android.view.View.setFrame(int,int,int,int)*

protected boolean setFrame(
  int left,
  int top,
  int right,
  int bottom)

Assign a size and position to this view. 

This is called from layout. 


    left - Left position, relative to parent 
    top - Top position, relative to parent 
    right - Right position, relative to parent 
    bottom - Bottom position, relative to parent 

    Returns: true if the new size and position are different than the previous ones {@hide} 

*android.view.View.setHapticFeedbackEnabled(boolean)*

public void setHapticFeedbackEnabled(boolean hapticFeedbackEnabled)

Set whether this view should have haptic feedback for events such as long 
presses. 

You may wish to disable haptic feedback if your view already controls its own 
haptic feedback. 


    hapticFeedbackEnabled - whether haptic feedback enabled for this view. 

*android.view.View.setHasTransientState(boolean)*

public void setHasTransientState(boolean hasTransientState)

Set whether this view is currently tracking transient state that the framework 
should attempt to preserve when possible. This flag is reference counted, so 
every call to setHasTransientState(true) should be paired with a later call to 
setHasTransientState(false). 

A view with transient state cannot be trivially rebound from an external data 
source, such as an adapter binding item views in a list. This may be because 
the view is performing an animation, tracking user selection of content, or 
similar. 


    hasTransientState - true if this view has transient state 

*android.view.View.setHorizontalFadingEdgeEnabled(boolean)*

public void setHorizontalFadingEdgeEnabled(boolean horizontalFadingEdgeEnabled)

Define whether the horizontal edges should be faded when this view is scrolled 
horizontally. 


    horizontalFadingEdgeEnabled - true if the horizontal edges should be faded when the view is scrolled 
       horizontally 

*android.view.View.setHorizontalScrollBarEnabled(boolean)*

public void setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled)

Define whether the horizontal scrollbar should be drawn or not. The scrollbar 
is not drawn by default. 


    horizontalScrollBarEnabled - true if the horizontal scrollbar should be painted 

*android.view.View.setHovered(boolean)*

public void setHovered(boolean hovered)

Sets whether the view is currently hovered. 

Calling this method also changes the drawable state of the view. This enables 
the view to react to hover by using different drawable resources to change its 
appearance. 

The (|android.view.View|) method is called when the hovered state changes. 


    hovered - True if the view is hovered. 

*android.view.View.setId(int)*

public void setId(int id)

Sets the identifier for this view. The identifier does not have to be unique in 
this view's hierarchy. The identifier should be a positive number. 


    id - a number used to identify the view 

*android.view.View.setImportantForAccessibility(int)*

public void setImportantForAccessibility(int mode)

Sets how to determine whether this view is important for accessibility which is 
if it fires accessibility events and if it is reported to accessibility 
services that query the screen. 


    mode - How to determine whether this view is important for accessibility. 

*android.view.View.setIsRootNamespace(boolean)*

public void setIsRootNamespace(boolean isRoot)




    isRoot - true if the view belongs to the root namespace, false otherwise 

*android.view.View.setKeepScreenOn(boolean)*

public void setKeepScreenOn(boolean keepScreenOn)

Controls whether the screen should remain on, modifying the value of 
(|android.view.View|) . 


    keepScreenOn - Supply true to set {@link #KEEP_SCREEN_ON}. 

*android.view.View.setLabelFor(int)*

public void setLabelFor(int id)

Sets the id of a view for which this view serves as a label for accessibility 
purposes. 


    id - The labeled view id. 

*android.view.View.setLayerPaint(Paint)*

public void setLayerPaint(Paint paint)

Updates the (|Paint|) object used with the current layer (used only if the 
current layer type is not set to (|android.view.View|) ). Changed properties of 
the Paint provided to (|android.view.View|) will be used the next time the View 
is redrawn, but (|android.view.View|) must be called to ensure that the view 
gets redrawn immediately. 

A layer is associated with an optional (|android.graphics.Paint|) instance that 
controls how the layer is composed on screen. The following properties of the 
paint are taken into account when composing the layer: 

Translucency (alpha)(|android.graphics.Paint|) Blending 
mode(|android.graphics.Paint|) Color filter(|android.graphics.Paint|) 

If this view has an alpha value set to < 1.0 by calling (|android.view.View|) , 
the alpha value of the layer's paint is superceded by this view's alpha value. 


    paint - The paint used to compose the layer. This argument is optional and can be null. 
       It is ignored when the layer type is {@link #LAYER_TYPE_NONE} 

*android.view.View.setLayerType(int,Paint)*

public void setLayerType(
  int layerType,
  Paint paint)

Specifies the type of layer backing this view. The layer can be 
(|android.view.View|) , (|android.view.View|) or (|android.view.View|) . 

A layer is associated with an optional (|android.graphics.Paint|) instance that 
controls how the layer is composed on screen. The following properties of the 
paint are taken into account when composing the layer: 

Translucency (alpha)(|android.graphics.Paint|) Blending 
mode(|android.graphics.Paint|) Color filter(|android.graphics.Paint|) 

If this view has an alpha value set to < 1.0 by calling (|android.view.View|) , 
the alpha value of the layer's paint is superceded by this view's alpha value. 

Refer to the documentation of (|android.view.View|) , (|android.view.View|) and 
(|android.view.View|) for more information on when and how to use layers. 


    layerType - The type of layer to use with this view, must be one of {@link 
       #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or {@link 
       #LAYER_TYPE_HARDWARE} 
    paint - The paint used to compose the layer. This argument is optional and can be null. 
       It is ignored when the layer type is {@link #LAYER_TYPE_NONE} 

*android.view.View.setLayoutDirection(int)*

public void setLayoutDirection(int layoutDirection)

Set the layout direction for this view. This will propagate a reset of layout 
direction resolution to the view's children and resolve layout direction for 
this view. 


    layoutDirection - the layout direction to set. Should be one of: 

{@link #LAYOUT_DIRECTION_LTR}, {@link #LAYOUT_DIRECTION_RTL}, {@link 
       #LAYOUT_DIRECTION_INHERIT}, {@link #LAYOUT_DIRECTION_LOCALE}. 

Resolution will be done if the value is set to LAYOUT_DIRECTION_INHERIT. The 
       resolution proceeds up the parent chain of the view to get the value. If 
       there is no parent, then it will return the default {@link 
       #LAYOUT_DIRECTION_LTR}. 

*android.view.View.setLayoutParams(ViewGroup.LayoutParams)*

public void setLayoutParams(android.view.ViewGroup.LayoutParams params)

Set the layout parameters associated with this view. These supply parameters to 
the parent of this view specifying how it should be arranged. There are many 
subclasses of ViewGroup.LayoutParams, and these correspond to the different 
subclasses of ViewGroup that are responsible for arranging their children. 


    params - The layout parameters for this view, cannot be null 

*android.view.View.setLeft(int)*

public final void setLeft(int left)

Sets the left position of this view relative to its parent. This method is 
meant to be called by the layout system and should not generally be called 
otherwise, because the property may be changed at any time by the layout. 


    left - The bottom of this view, in pixels. 

*android.view.View.setLongClickable(boolean)*

public void setLongClickable(boolean longClickable)

Enables or disables long click events for this view. When a view is long 
clickable it reacts to the user holding down the button for a longer duration 
than a tap. This event can either launch the listener or a context menu. 


    longClickable - true to make the view long clickable, false otherwise 

*android.view.View.setMeasuredDimension(int,int)*

protected final void setMeasuredDimension(
  int measuredWidth,
  int measuredHeight)

This method must be called by (|android.view.View|) to store the measured width 
and measured height. Failing to do so will trigger an exception at measurement 
time. 


    measuredWidth - The measured width of this view. May be a complex bit mask as defined by {@link 
       #MEASURED_SIZE_MASK} and {@link #MEASURED_STATE_TOO_SMALL}. 
    measuredHeight - The measured height of this view. May be a complex bit mask as defined by 
       {@link #MEASURED_SIZE_MASK} and {@link #MEASURED_STATE_TOO_SMALL}. 

*android.view.View.setMinimumHeight(int)*

public void setMinimumHeight(int minHeight)

Sets the minimum height of the view. It is not guaranteed the view will be able 
to achieve this minimum height (for example, if its parent layout constrains it 
with less available height). 


    minHeight - The minimum height the view will try to be. 

*android.view.View.setMinimumWidth(int)*

public void setMinimumWidth(int minWidth)

Sets the minimum width of the view. It is not guaranteed the view will be able 
to achieve this minimum width (for example, if its parent layout constrains it 
with less available width). 


    minWidth - The minimum width the view will try to be. 

*android.view.View.setNextFocusDownId(int)*

public void setNextFocusDownId(int nextFocusDownId)

Sets the id of the view to use when the next focus is (|android.view.View|) . 


    nextFocusDownId - The next focus ID, or {@link #NO_ID} if the framework should decide 
       automatically. 

*android.view.View.setNextFocusForwardId(int)*

public void setNextFocusForwardId(int nextFocusForwardId)

Sets the id of the view to use when the next focus is (|android.view.View|) . 


    nextFocusForwardId - The next focus ID, or {@link #NO_ID} if the framework should decide 
       automatically. 

*android.view.View.setNextFocusLeftId(int)*

public void setNextFocusLeftId(int nextFocusLeftId)

Sets the id of the view to use when the next focus is (|android.view.View|) . 


    nextFocusLeftId - The next focus ID, or {@link #NO_ID} if the framework should decide 
       automatically. 

*android.view.View.setNextFocusRightId(int)*

public void setNextFocusRightId(int nextFocusRightId)

Sets the id of the view to use when the next focus is (|android.view.View|) . 


    nextFocusRightId - The next focus ID, or {@link #NO_ID} if the framework should decide 
       automatically. 

*android.view.View.setNextFocusUpId(int)*

public void setNextFocusUpId(int nextFocusUpId)

Sets the id of the view to use when the next focus is (|android.view.View|) . 


    nextFocusUpId - The next focus ID, or {@link #NO_ID} if the framework should decide 
       automatically. 

*android.view.View.setOnClickListener(View.OnClickListener)*

public void setOnClickListener(android.view.View.OnClickListener l)

Register a callback to be invoked when this view is clicked. If this view is 
not clickable, it becomes clickable. 


    l - The callback that will run 

*android.view.View.setOnCreateContextMenuListener(View.OnCreateContextMenuListener)*

public void setOnCreateContextMenuListener(android.view.View.OnCreateContextMenuListener l)

Register a callback to be invoked when the context menu for this view is being 
built. If this view is not long clickable, it becomes long clickable. 


    l - The callback that will run 

*android.view.View.setOnDragListener(View.OnDragListener)*

public void setOnDragListener(android.view.View.OnDragListener l)

Register a drag event listener callback object for this View. The parameter is 
an implementation of (|android.view.View.OnDragListener|) . To send a drag 
event to a View, the system calls the (|android.view.View.OnDragListener|) 
method. 


    l - An implementation of {@link android.view.View.OnDragListener}. 

*android.view.View.setOnFocusChangeListener(View.OnFocusChangeListener)*

public void setOnFocusChangeListener(android.view.View.OnFocusChangeListener l)

Register a callback to be invoked when focus of this view changed. 


    l - The callback that will run. 

*android.view.View.setOnGenericMotionListener(View.OnGenericMotionListener)*

public void setOnGenericMotionListener(android.view.View.OnGenericMotionListener l)

Register a callback to be invoked when a generic motion event is sent to this 
view. 


    l - the generic motion listener to attach to this view 

*android.view.View.setOnHoverListener(View.OnHoverListener)*

public void setOnHoverListener(android.view.View.OnHoverListener l)

Register a callback to be invoked when a hover event is sent to this view. 


    l - the hover listener to attach to this view 

*android.view.View.setOnKeyListener(View.OnKeyListener)*

public void setOnKeyListener(android.view.View.OnKeyListener l)

Register a callback to be invoked when a hardware key is pressed in this view. 
Key presses in software input methods will generally not trigger the methods of 
this listener. 


    l - the key listener to attach to this view 

*android.view.View.setOnLongClickListener(View.OnLongClickListener)*

public void setOnLongClickListener(android.view.View.OnLongClickListener l)

Register a callback to be invoked when this view is clicked and held. If this 
view is not long clickable, it becomes long clickable. 


    l - The callback that will run 

*android.view.View.setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener)*

public void setOnSystemUiVisibilityChangeListener(android.view.View.OnSystemUiVisibilityChangeListener l)

Set a listener to receive callbacks when the visibility of the system bar 
changes. 


    l - The {@link OnSystemUiVisibilityChangeListener} to receive callbacks. 

*android.view.View.setOnTouchListener(View.OnTouchListener)*

public void setOnTouchListener(android.view.View.OnTouchListener l)

Register a callback to be invoked when a touch event is sent to this view. 


    l - the touch listener to attach to this view 

*android.view.View.setOverScrollMode(int)*

public void setOverScrollMode(int overScrollMode)

Set the over-scroll mode for this view. Valid over-scroll modes are 
(|android.view.View|) (default), (|android.view.View|) (allow over-scrolling 
only if the view content is larger than the container), or 
(|android.view.View|) . 

Setting the over-scroll mode of a view will have an effect only if the view is 
capable of scrolling. 


    overScrollMode - The new over-scroll mode for this view. 

*android.view.View.setPadding(int,int,int,int)*

public void setPadding(
  int left,
  int top,
  int right,
  int bottom)

Sets the padding. The view may add on the space required to display the 
scrollbars, depending on the style and visibility of the scrollbars. So the 
values returned from (|android.view.View|) , (|android.view.View|) , 
(|android.view.View|) and (|android.view.View|) may be different from the 
values set in this call. 


    left - the left padding in pixels 
    top - the top padding in pixels 
    right - the right padding in pixels 
    bottom - the bottom padding in pixels 

*android.view.View.setPaddingRelative(int,int,int,int)*

public void setPaddingRelative(
  int start,
  int top,
  int end,
  int bottom)

Sets the relative padding. The view may add on the space required to display 
the scrollbars, depending on the style and visibility of the scrollbars. So the 
values returned from (|android.view.View|) , (|android.view.View|) , 
(|android.view.View|) and (|android.view.View|) may be different from the 
values set in this call. 


    start - the start padding in pixels 
    top - the top padding in pixels 
    end - the end padding in pixels 
    bottom - the bottom padding in pixels 

*android.view.View.setPivotX(float)*

public void setPivotX(float pivotX)

Sets the x location of the point around which the view is 
rotated(|android.view.View|) and scaled(|android.view.View|) . By default, the 
pivot point is centered on the object. Setting this property disables this 
behavior and causes the view to use only the explicitly set pivotX and pivotY 
values. 


    pivotX - The x location of the pivot point. 

*android.view.View.setPivotY(float)*

public void setPivotY(float pivotY)

Sets the y location of the point around which the view is 
rotated(|android.view.View|) and scaled(|android.view.View|) . By default, the 
pivot point is centered on the object. Setting this property disables this 
behavior and causes the view to use only the explicitly set pivotX and pivotY 
values. 


    pivotY - The y location of the pivot point. 

*android.view.View.setPressed(boolean)*

public void setPressed(boolean pressed)

Sets the pressed state for this view. 


    pressed - Pass true to set the View's internal state to "pressed", or false to reverts 
       the View's internal state from a previously set "pressed" state. 

*android.view.View.setRight(int)*

public final void setRight(int right)

Sets the right position of this view relative to its parent. This method is 
meant to be called by the layout system and should not generally be called 
otherwise, because the property may be changed at any time by the layout. 


    right - The bottom of this view, in pixels. 

*android.view.View.setRotation(float)*

public void setRotation(float rotation)

Sets the degrees that the view is rotated around the pivot point. Increasing 
values result in clockwise rotation. 


    rotation - The degrees of rotation. 

*android.view.View.setRotationX(float)*

public void setRotationX(float rotationX)

Sets the degrees that the view is rotated around the horizontal axis through 
the pivot point. Increasing values result in clockwise rotation from the 
viewpoint of looking down the x axis. 

When rotating large views, it is recommended to adjust the camera distance 
accordingly. Refer to (|android.view.View|) for more information. 


    rotationX - The degrees of X rotation. 

*android.view.View.setRotationY(float)*

public void setRotationY(float rotationY)

Sets the degrees that the view is rotated around the vertical axis through the 
pivot point. Increasing values result in counter-clockwise rotation from the 
viewpoint of looking down the y axis. 

When rotating large views, it is recommended to adjust the camera distance 
accordingly. Refer to (|android.view.View|) for more information. 


    rotationY - The degrees of Y rotation. 

*android.view.View.setSaveEnabled(boolean)*

public void setSaveEnabled(boolean enabled)

Controls whether the saving of this view's state is enabled (that is, whether 
its (|android.view.View|) method will be called). Note that even if freezing is 
enabled, the view still must have an id assigned to it (via 
(|android.view.View|) ) for its state to be saved. This flag can only disable 
the saving of this view; any child views may still have their state saved. 


    enabled - Set to false to disable state saving, or true (the default) to allow it. 

*android.view.View.setSaveFromParentEnabled(boolean)*

public void setSaveFromParentEnabled(boolean enabled)

Controls whether the entire hierarchy under this view will save its state when 
a state saving traversal occurs from its parent. The default is true; if false, 
these views will not be saved unless (|android.view.View|) is called directly 
on this view. 


    enabled - Set to false to disable state saving, or true (the default) to allow it. 

*android.view.View.setScaleX(float)*

public void setScaleX(float scaleX)

Sets the amount that the view is scaled in x around the pivot point, as a 
proportion of the view's unscaled width. A value of 1 means that no scaling is 
applied. 


    scaleX - The scaling factor. 

*android.view.View.setScaleY(float)*

public void setScaleY(float scaleY)

Sets the amount that the view is scaled in Y around the pivot point, as a 
proportion of the view's unscaled width. A value of 1 means that no scaling is 
applied. 


    scaleY - The scaling factor. 

*android.view.View.setScrollBarDefaultDelayBeforeFade(int)*

public void setScrollBarDefaultDelayBeforeFade(int scrollBarDefaultDelayBeforeFade)

Define the delay before scrollbars fade. 


    scrollBarDefaultDelayBeforeFade - - the delay before scrollbars fade 

*android.view.View.setScrollBarFadeDuration(int)*

public void setScrollBarFadeDuration(int scrollBarFadeDuration)

Define the scrollbar fade duration. 


    scrollBarFadeDuration - - the scrollbar fade duration 

*android.view.View.setScrollbarFadingEnabled(boolean)*

public void setScrollbarFadingEnabled(boolean fadeScrollbars)

Define whether scrollbars will fade when the view is not scrolling. 


    fadeScrollbars - wheter to enable fading 

*android.view.View.setScrollBarSize(int)*

public void setScrollBarSize(int scrollBarSize)

Define the scrollbar size. 


    scrollBarSize - - the scrollbar size 

*android.view.View.setScrollBarStyle(int)*

public void setScrollBarStyle(int style)

Specify the style of the scrollbars. The scrollbars can be overlaid or inset. 
When inset, they add to the padding of the view. And the scrollbars can be 
drawn inside the padding area or on the edge of the view. For example, if a 
view has a background drawable and you want to draw the scrollbars inside the 
padding specified by the drawable, you can use SCROLLBARS_INSIDE_OVERLAY or 
SCROLLBARS_INSIDE_INSET. If you want them to appear at the edge of the view, 
ignoring the padding, then you can use SCROLLBARS_OUTSIDE_OVERLAY or 
SCROLLBARS_OUTSIDE_INSET. 


    style - the style of the scrollbars. Should be one of SCROLLBARS_INSIDE_OVERLAY, 
       SCROLLBARS_INSIDE_INSET, SCROLLBARS_OUTSIDE_OVERLAY or 
       SCROLLBARS_OUTSIDE_INSET. 

*android.view.View.setScrollContainer(boolean)*

public void setScrollContainer(boolean isScrollContainer)

Change whether this view is one of the set of scrollable containers in its 
window. This will be used to determine whether the window can resize or must 
pan when a soft input area is open -- scrollable containers allow the window to 
use resize mode since the container will appropriately shrink. 



*android.view.View.setScrollX(int)*

public void setScrollX(int value)

Set the horizontal scrolled position of your view. This will cause a call to 
(|android.view.View|) and the view will be invalidated. 


    value - the x position to scroll to 

*android.view.View.setScrollY(int)*

public void setScrollY(int value)

Set the vertical scrolled position of your view. This will cause a call to 
(|android.view.View|) and the view will be invalidated. 


    value - the y position to scroll to 

*android.view.View.setSelected(boolean)*

public void setSelected(boolean selected)

Changes the selection state of this view. A view can be selected or not. Note 
that selection is not the same as focus. Views are typically selected in the 
context of an AdapterView like ListView or GridView; the selected view is the 
view that is highlighted. 


    selected - true if the view must be selected, false otherwise 

*android.view.View.setSoundEffectsEnabled(boolean)*

public void setSoundEffectsEnabled(boolean soundEffectsEnabled)

Set whether this view should have sound effects enabled for events such as 
clicking and touching. 

You may wish to disable sound effects for a view if you already play sounds, 
for instance, a dial key that plays dtmf tones. 


    soundEffectsEnabled - whether sound effects are enabled for this view. 

*android.view.View.setSystemUiVisibility(int)*

public void setSystemUiVisibility(int visibility)

Request that the visibility of the status bar or other screen/window 
decorations be changed. 

This method is used to put the over device UI into temporary modes where the 
user's attention is focused more on the application content, by dimming or 
hiding surrounding system affordances. This is typically used in conjunction 
with Window.FEATURE_ACTION_BAR_OVERLAY(|android.view.Window|) , allowing the 
applications content to be placed behind the action bar (and with these flags 
other system affordances) so that smooth transitions between hiding and showing 
them can be done. 

Two representative examples of the use of system UI visibility is implementing 
a content browsing application (like a magazine reader) and a video playing 
application. 

The first code shows a typical implementation of a View in a content browsing 
application. In this implementation, the application goes into a 
content-oriented mode by hiding the status bar and action bar, and putting the 
navigation elements into lights out mode. The user can then interact with 
content while in this mode. Such an application should provide an easy way for 
the user to toggle out of the mode (such as to check information in the status 
bar or access notifications). In the implementation here, this is done simply 
by tapping on the 
content.development/samples/ApiDemos/src/com/example/android/apis/view/ContentBrowserActivity.java
contentThis second code sample shows a typical implementation of a View in a 
video playing application. In this situation, while the video is playing the 
application would like to go into a complete full-screen mode, to use as much 
of the display as possible for the video. When in this state the user can not 
interact with the application; the system intercepts touching on the screen to 
pop the UI out of full screen mode. See (|android.view.View|) for a sample 
layout that goes with this 
code.development/samples/ApiDemos/src/com/example/android/apis/view/VideoPlayerActivity.java
content 


    visibility - Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE}, {@link 
       #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link #SYSTEM_UI_FLAG_FULLSCREEN}, 
       {@link #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link 
       #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION}, {@link 
       #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}, {@link #SYSTEM_UI_FLAG_IMMERSIVE}, 
       and {@link #SYSTEM_UI_FLAG_IMMERSIVE_STICKY}. 

*android.view.View.setTag(int,Object)*

public void setTag(
  int key,
  java.lang.Object tag)

Sets a tag associated with this view and a key. A tag can be used to mark a 
view in its hierarchy and does not have to be unique within the hierarchy. Tags 
can also be used to store data within a view without resorting to another data 
structure. 

The specified key should be an id declared in the resources of the application 
to ensure it is unique (see the <a 
href=guide/topics/resources/more-resources.html#Id">ID resource type). Keys 
identified as belonging to the Android framework or not associated with any 
package will cause an (|java.lang.IllegalArgumentException|) to be thrown. 


    key - The key identifying the tag 
    tag - An Object to tag the view with 

*android.view.View.setTag(Object)*

public void setTag(java.lang.Object tag)

Sets the tag associated with this view. A tag can be used to mark a view in its 
hierarchy and does not have to be unique within the hierarchy. Tags can also be 
used to store data within a view without resorting to another data structure. 


    tag - an Object to tag the view with 

*android.view.View.setTagInternal(int,Object)*

public void setTagInternal(
  int key,
  java.lang.Object tag)

Variation of (|android.view.View|) that enforces the key to be a framework id. 



*android.view.View.setTextAlignment(int)*

public void setTextAlignment(int textAlignment)

Set the text alignment. 


    textAlignment - The text alignment to set. Should be one of 

{@link #TEXT_ALIGNMENT_INHERIT}, {@link #TEXT_ALIGNMENT_GRAVITY}, {@link 
       #TEXT_ALIGNMENT_CENTER}, {@link #TEXT_ALIGNMENT_TEXT_START}, {@link 
       #TEXT_ALIGNMENT_TEXT_END}, {@link #TEXT_ALIGNMENT_VIEW_START}, {@link 
       #TEXT_ALIGNMENT_VIEW_END} 

Resolution will be done if the value is set to TEXT_ALIGNMENT_INHERIT. The 
       resolution proceeds up the parent chain of the view to get the value. If 
       there is no parent, then it will return the default {@link 
       #TEXT_ALIGNMENT_GRAVITY}. 

*android.view.View.setTextDirection(int)*

public void setTextDirection(int textDirection)

Set the text direction. 


    textDirection - the direction to set. Should be one of: 

{@link #TEXT_DIRECTION_INHERIT}, {@link #TEXT_DIRECTION_FIRST_STRONG} {@link 
       #TEXT_DIRECTION_ANY_RTL}, {@link #TEXT_DIRECTION_LTR}, {@link 
       #TEXT_DIRECTION_RTL}, {@link #TEXT_DIRECTION_LOCALE} 

Resolution will be done if the value is set to TEXT_DIRECTION_INHERIT. The 
       resolution proceeds up the parent chain of the view to get the value. If 
       there is no parent, then it will return the default {@link 
       #TEXT_DIRECTION_FIRST_STRONG}. 

*android.view.View.setTop(int)*

public final void setTop(int top)

Sets the top position of this view relative to its parent. This method is meant 
to be called by the layout system and should not generally be called otherwise, 
because the property may be changed at any time by the layout. 


    top - The top of this view, in pixels. 

*android.view.View.setTouchDelegate(TouchDelegate)*

public void setTouchDelegate(android.view.TouchDelegate delegate)

Sets the TouchDelegate for this View. 



*android.view.View.setTransitionAlpha(float)*

public void setTransitionAlpha(float alpha)

This property is hidden and intended only for use by the Fade transition, which 
animates it to produce a visual translucency that does not side-effect (or get 
affected by) the real alpha property. This value is composited with the other 
alpha value (and the AlphaAnimation value, when that is present) to produce a 
final visual translucency result, which is what is passed into the DisplayList. 



*android.view.View.setTranslationX(float)*

public void setTranslationX(float translationX)

Sets the horizontal location of this view relative to its 
left(|android.view.View|) position. This effectively positions the object 
post-layout, in addition to wherever the object's layout placed it. 


    translationX - The horizontal position of this view relative to its left position, in pixels. 

*android.view.View.setTranslationY(float)*

public void setTranslationY(float translationY)

Sets the vertical location of this view relative to its 
top(|android.view.View|) position. This effectively positions the object 
post-layout, in addition to wherever the object's layout placed it. 


    translationY - The vertical position of this view relative to its top position, in pixels. 

*android.view.View.setVerticalFadingEdgeEnabled(boolean)*

public void setVerticalFadingEdgeEnabled(boolean verticalFadingEdgeEnabled)

Define whether the vertical edges should be faded when this view is scrolled 
vertically. 


    verticalFadingEdgeEnabled - true if the vertical edges should be faded when the view is scrolled vertically 

*android.view.View.setVerticalScrollBarEnabled(boolean)*

public void setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled)

Define whether the vertical scrollbar should be drawn or not. The scrollbar is 
not drawn by default. 


    verticalScrollBarEnabled - true if the vertical scrollbar should be painted 

*android.view.View.setVerticalScrollbarPosition(int)*

public void setVerticalScrollbarPosition(int position)

Set the position of the vertical scroll bar. Should be one of 
(|android.view.View|) , (|android.view.View|) or (|android.view.View|) . 


    position - Where the vertical scroll bar should be positioned. 

*android.view.View.setVisibility(int)*

public void setVisibility(int visibility)

Set the enabled state of this view. 


    visibility - One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}. 

*android.view.View.setWillNotCacheDrawing(boolean)*

public void setWillNotCacheDrawing(boolean willNotCacheDrawing)

When a View's drawing cache is enabled, drawing is redirected to an offscreen 
bitmap. Some views, like an ImageView, must be able to bypass this mechanism if 
they already draw a single bitmap, to avoid unnecessary usage of the memory. 


    willNotCacheDrawing - true if this view does not cache its drawing, false otherwise 

*android.view.View.setWillNotDraw(boolean)*

public void setWillNotDraw(boolean willNotDraw)

If this view doesn't do any drawing on its own, set this flag to allow further 
optimizations. By default, this flag is not set on View, but could be set on 
some View subclasses such as ViewGroup. 

Typically, if you override (|android.view.View|) you should clear this flag. 


    willNotDraw - whether or not this View draw on its own 

*android.view.View.setX(float)*

public void setX(float x)

Sets the visual x position of this view, in pixels. This is equivalent to 
setting the translationX(|android.view.View|) property to be the difference 
between the x value passed in and the current left(|android.view.View|) 
property. 


    x - The visual x position of this view, in pixels. 

*android.view.View.setY(float)*

public void setY(float y)

Sets the visual y position of this view, in pixels. This is equivalent to 
setting the translationY(|android.view.View|) property to be the difference 
between the y value passed in and the current top(|android.view.View|) 
property. 


    y - The visual y position of this view, in pixels. 

*android.view.View.showContextMenu()*

public boolean showContextMenu()

Bring up the context menu for this view. 



    Returns: Whether a context menu was displayed. 

*android.view.View.showContextMenu(float,float,int)*

public boolean showContextMenu(
  float x,
  float y,
  int metaState)

Bring up the context menu for this view, referring to the item under the 
specified point. 


    x - The referenced x coordinate. 
    y - The referenced y coordinate. 
    metaState - The keyboard modifiers that were pressed. 

    Returns: Whether a context menu was displayed. 

*android.view.View.startActionMode(ActionMode.Callback)*

public |android.view.ActionMode| startActionMode(android.view.ActionMode.Callback callback)

Start an action mode. 


    callback - Callback that will control the lifecycle of the action mode 

    Returns: The new action mode if it is started, null otherwise 

*android.view.View.startAnimation(Animation)*

public void startAnimation(android.view.animation.Animation animation)

Start the specified animation now. 


    animation - the animation to start now 

*android.view.View.startDrag(ClipData,View.DragShadowBuilder,Object,int)*

public final boolean startDrag(
  android.content.ClipData data,
  android.view.View.DragShadowBuilder shadowBuilder,
  java.lang.Object myLocalState,
  int flags)

Starts a drag and drop operation. When your application calls this method, it 
passes a (|android.view.View.DragShadowBuilder|) object to the system. The 
system calls this object's (|android.view.View.DragShadowBuilder|) to get 
metrics for the drag shadow, and then calls the object's 
(|android.view.View.DragShadowBuilder|) to draw the drag shadow itself. 

Once the system has the drag shadow, it begins the drag and drop operation by 
sending drag events to all the View objects in your application that are 
currently visible. It does this either by calling the View object's drag 
listener (an implementation of onDrag()(|android.view.View.OnDragListener|) or 
by calling the View object's onDragEvent()(|android.view.View|) method. Both 
are passed a (|android.view.DragEvent|) object that has a 
(|android.view.DragEvent|) value of (|android.view.DragEvent|) . 

Your application can invoke startDrag() on any attached View object. The View 
object does not need to be the one used in 
(|android.view.View.DragShadowBuilder|) , nor does it need to be related to the 
View the user selected for dragging. 


    data - A {@link android.content.ClipData} object pointing to the data to be 
       transferred by the drag and drop operation. 
    shadowBuilder - A {@link android.view.View.DragShadowBuilder} object for building the drag 
       shadow. 
    myLocalState - An {@link java.lang.Object} containing local data about the drag and drop 
       operation. This Object is put into every DragEvent object sent by the 
       system during the current drag. 

myLocalState is a lightweight mechanism for the sending information from the 
       dragged View to the target Views. For example, it can contain flags that 
       differentiate between a a copy operation and a move operation. 
    flags - Flags that control the drag and drop operation. No flags are currently defined, 
       so the parameter should be set to 0. 

    Returns: {@code true} if the method completes successfully, or {@code false} if it fails 
             anywhere. Returning {@code false} means the system was unable to 
             do a drag, and so no drag operation is in progress. 

*android.view.View.toGlobalMotionEvent(MotionEvent)*

public boolean toGlobalMotionEvent(android.view.MotionEvent ev)

Transforms a motion event from view-local coordinates to on-screen coordinates. 


    ev - the view-local motion event 

    Returns: false if the transformation could not be applied 

*android.view.View.toLocalMotionEvent(MotionEvent)*

public boolean toLocalMotionEvent(android.view.MotionEvent ev)

Transforms a motion event from on-screen coordinates to view-local coordinates. 


    ev - the on-screen motion event 

    Returns: false if the transformation could not be applied 

*android.view.View.toString()*

public |java.lang.String| toString()





*android.view.View.unscheduleDrawable(Drawable)*

public void unscheduleDrawable(Drawable who)

Unschedule any events associated with the given Drawable. This can be used when 
selecting a new Drawable into a view, so that the previous one is completely 
unscheduled. 


    who - The Drawable to unschedule. 

*android.view.View.unscheduleDrawable(Drawable,Runnable)*

public void unscheduleDrawable(
  Drawable who,
  java.lang.Runnable what)

Cancels a scheduled action on a drawable. 


    who - the recipient of the action 
    what - the action to cancel 

*android.view.View.verifyDrawable(Drawable)*

protected boolean verifyDrawable(Drawable who)

If your view subclass is displaying its own Drawable objects, it should 
override this function and return true for any Drawable it is displaying. This 
allows animations for those drawables to be scheduled. 

Be sure to call through to the super class when overriding this function. 


    who - The Drawable to verify. Return true if it is one you are displaying, else 
       return the result of calling through to the super class. 

    Returns: boolean If true than the Drawable is being displayed in the view; else false 
             and it is not allowed to animate. 

*android.view.View.willNotCacheDrawing()*

public boolean willNotCacheDrawing()

Returns whether or not this View can cache its drawing or not. 



    Returns: true if this view does not cache its drawing, false otherwise 

*android.view.View.willNotDraw()*

public boolean willNotDraw()

Returns whether or not this View draws on its own. 



    Returns: true if this view has nothing to draw, false otherwise 


