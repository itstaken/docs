*android.view.WindowManagerPolicy* *WindowManagerPolicy* This interface supplies

public interface interface WindowManagerPolicy


|android.view.WindowManagerPolicy_Description|
|android.view.WindowManagerPolicy_Fields|
|android.view.WindowManagerPolicy_Constructors|
|android.view.WindowManagerPolicy_Methods|

================================================================================

*android.view.WindowManagerPolicy_Fields*
|int_android.view.WindowManagerPolicy.ACTION_GO_TO_SLEEP|
|java.lang.String_android.view.WindowManagerPolicy.ACTION_HDMI_PLUGGED|
|int_android.view.WindowManagerPolicy.ACTION_PASS_TO_USER|
|int_android.view.WindowManagerPolicy.ACTION_WAKE_UP|
|java.lang.String_android.view.WindowManagerPolicy.EXTRA_HDMI_PLUGGED_STATE|
|int_android.view.WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM|
|int_android.view.WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG|
|int_android.view.WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT|
|int_android.view.WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER|
|int_android.view.WindowManagerPolicy.FLAG_ALT|
|int_android.view.WindowManagerPolicy.FLAG_ALT_GR|
|int_android.view.WindowManagerPolicy.FLAG_BRIGHT_HERE|
|int_android.view.WindowManagerPolicy.FLAG_CAPS_LOCK|
|int_android.view.WindowManagerPolicy.FLAG_DISABLE_KEY_REPEAT|
|int_android.view.WindowManagerPolicy.FLAG_FILTERED|
|int_android.view.WindowManagerPolicy.FLAG_INJECTED|
|int_android.view.WindowManagerPolicy.FLAG_LAUNCHER|
|int_android.view.WindowManagerPolicy.FLAG_MENU|
|int_android.view.WindowManagerPolicy.FLAG_PASS_TO_USER|
|int_android.view.WindowManagerPolicy.FLAG_SHIFT|
|int_android.view.WindowManagerPolicy.FLAG_TRUSTED|
|int_android.view.WindowManagerPolicy.FLAG_VIRTUAL|
|int_android.view.WindowManagerPolicy.FLAG_WAKE|
|int_android.view.WindowManagerPolicy.FLAG_WAKE_DROPPED|
|int_android.view.WindowManagerPolicy.FLAG_WOKE_HERE|
|int_android.view.WindowManagerPolicy.OFF_BECAUSE_OF_ADMIN|
|int_android.view.WindowManagerPolicy.OFF_BECAUSE_OF_PROX_SENSOR|
|int_android.view.WindowManagerPolicy.OFF_BECAUSE_OF_TIMEOUT|
|int_android.view.WindowManagerPolicy.OFF_BECAUSE_OF_USER|
|int_android.view.WindowManagerPolicy.PRESENCE_EXTERNAL|
|int_android.view.WindowManagerPolicy.PRESENCE_INTERNAL|
|int_android.view.WindowManagerPolicy.TRANSIT_ENTER|
|int_android.view.WindowManagerPolicy.TRANSIT_EXIT|
|int_android.view.WindowManagerPolicy.TRANSIT_HIDE|
|int_android.view.WindowManagerPolicy.TRANSIT_PREVIEW_DONE|
|int_android.view.WindowManagerPolicy.TRANSIT_SHOW|
|int_android.view.WindowManagerPolicy.USER_ROTATION_FREE|
|int_android.view.WindowManagerPolicy.USER_ROTATION_LOCKED|
|boolean_android.view.WindowManagerPolicy.WATCH_POINTER|

*android.view.WindowManagerPolicy_Methods*
|android.view.WindowManagerPolicy.addStartingWindow(IBinder,String,int,CompatibilityInfo,CharSequence,int,int,int,int)|
|android.view.WindowManagerPolicy.adjustConfigurationLw(Configuration,int,int)|
|android.view.WindowManagerPolicy.adjustSystemUiVisibilityLw(int)|Called when a
|android.view.WindowManagerPolicy.adjustWindowParamsLw(WindowManager.LayoutParams)|
|android.view.WindowManagerPolicy.allowAppAnimationsLw()|Return true if it is o
|android.view.WindowManagerPolicy.applyPostLayoutPolicyLw(WindowManagerPolicy.WindowState,WindowManager.LayoutParams)|
|android.view.WindowManagerPolicy.beginLayoutLw(boolean,int,int,int)|Called whe
|android.view.WindowManagerPolicy.beginPostLayoutPolicyLw(int,int)|Called follo
|android.view.WindowManagerPolicy.canBeForceHidden(WindowManagerPolicy.WindowState,WindowManager.LayoutParams)|
|android.view.WindowManagerPolicy.canMagnifyWindow(int)|Returns whether a given
|android.view.WindowManagerPolicy.checkAddPermission(WindowManager.LayoutParams,int[])|
|android.view.WindowManagerPolicy.checkShowToOwnerOnly(WindowManager.LayoutParams)|
|android.view.WindowManagerPolicy.createForceHideEnterAnimation(boolean)|Create
|android.view.WindowManagerPolicy.dismissKeyguardLw()|Ask the policy to dismiss
|android.view.WindowManagerPolicy.dispatchUnhandledKey(WindowManagerPolicy.WindowState,KeyEvent,int)|
|android.view.WindowManagerPolicy.doesForceHide(WindowManagerPolicy.WindowState,WindowManager.LayoutParams)|
|android.view.WindowManagerPolicy.dump(String,PrintWriter,String[])|Print the W
|android.view.WindowManagerPolicy.enableKeyguard(boolean)|Tell the policy if an
|android.view.WindowManagerPolicy.enableScreenAfterBoot()|Called when we have f
|android.view.WindowManagerPolicy.exitKeyguardSecurely(WindowManagerPolicy.OnKeyguardExitResult)|
|android.view.WindowManagerPolicy.finishLayoutLw()|Called when layout of the wi
|android.view.WindowManagerPolicy.finishPostLayoutPolicyLw()|Called following l
|android.view.WindowManagerPolicy.focusChangedLw(WindowManagerPolicy.WindowState,WindowManagerPolicy.WindowState)|
|android.view.WindowManagerPolicy.getAboveUniverseLayer()|Return the window lay
|android.view.WindowManagerPolicy.getConfigDisplayHeight(int,int,int)|Return th
|android.view.WindowManagerPolicy.getConfigDisplayWidth(int,int,int)|Return the
|android.view.WindowManagerPolicy.getContentInsetHintLw(WindowManager.LayoutParams,Rect)|
|android.view.WindowManagerPolicy.getContentRectLw(Rect)|Return the rectangle o
|android.view.WindowManagerPolicy.getMaxWallpaperLayer()|Get the highest layer 
|android.view.WindowManagerPolicy.getNonDecorDisplayHeight(int,int,int)|Return 
|android.view.WindowManagerPolicy.getNonDecorDisplayWidth(int,int,int)|Return t
|android.view.WindowManagerPolicy.getSystemDecorLayerLw()|Returns the bottom-mo
|android.view.WindowManagerPolicy.getUserRotationMode()|Gets the current user r
|android.view.WindowManagerPolicy.hasNavigationBar()|Specifies whether there is
|android.view.WindowManagerPolicy.hideBootMessages()|Hide the UI for showing bo
|android.view.WindowManagerPolicy.init(Context,IWindowManager,WindowManagerPolicy.WindowManagerFuncs)|
|android.view.WindowManagerPolicy.inKeyguardRestrictedKeyInputMode()|inKeyguard
|android.view.WindowManagerPolicy.interceptKeyBeforeDispatching(WindowManagerPolicy.WindowState,KeyEvent,int)|
|android.view.WindowManagerPolicy.interceptKeyBeforeQueueing(KeyEvent,int,boolean)|
|android.view.WindowManagerPolicy.interceptMotionBeforeQueueingWhenScreenOff(int)|
|android.view.WindowManagerPolicy.isDefaultOrientationForced()|
|android.view.WindowManagerPolicy.isKeyguardLocked()|isKeyguardLocked   Return 
|android.view.WindowManagerPolicy.isKeyguardSecure()|isKeyguardSecure   Return 
|android.view.WindowManagerPolicy.isScreenOnEarly()|Return whether the screen i
|android.view.WindowManagerPolicy.isScreenOnFully()|Return whether the screen i
|android.view.WindowManagerPolicy.isTopLevelWindow(int)|Returns whether a given
|android.view.WindowManagerPolicy.keepScreenOnStartedLw()|Called when we have s
|android.view.WindowManagerPolicy.keepScreenOnStoppedLw()|Called when we have s
|android.view.WindowManagerPolicy.layoutWindowLw(WindowManagerPolicy.WindowState,WindowManager.LayoutParams,WindowManagerPolicy.WindowState)|
|android.view.WindowManagerPolicy.lockNow(Bundle)|Lock the device now.
|android.view.WindowManagerPolicy.notifyLidSwitchChanged(long,boolean)|Tell the
|android.view.WindowManagerPolicy.performHapticFeedbackLw(WindowManagerPolicy.WindowState,int,boolean)|
|android.view.WindowManagerPolicy.prepareAddWindowLw(WindowManagerPolicy.WindowState,WindowManager.LayoutParams)|
|android.view.WindowManagerPolicy.removeStartingWindow(IBinder,View)|Called whe
|android.view.WindowManagerPolicy.removeWindowLw(WindowManagerPolicy.WindowState)|
|android.view.WindowManagerPolicy.rotationForOrientationLw(int,int)|Given an or
|android.view.WindowManagerPolicy.rotationHasCompatibleMetricsLw(int,int)|Given
|android.view.WindowManagerPolicy.screenTurnedOff(int)|Called after the screen 
|android.view.WindowManagerPolicy.screenTurningOn(WindowManagerPolicy.ScreenOnListener)|
|android.view.WindowManagerPolicy.selectAnimationLw(WindowManagerPolicy.WindowState,int)|
|android.view.WindowManagerPolicy.selectRotationAnimationLw(int[])|Determine th
|android.view.WindowManagerPolicy.setCurrentOrientationLw(int)|
|android.view.WindowManagerPolicy.setCurrentUserLw(int)|Called when the current
|android.view.WindowManagerPolicy.setDisplayOverscan(Display,int,int,int,int)|C
|android.view.WindowManagerPolicy.setInitialDisplaySize(Display,int,int,int)|Ca
|android.view.WindowManagerPolicy.setLastInputMethodWindowLw(WindowManagerPolicy.WindowState,WindowManagerPolicy.WindowState)|
|android.view.WindowManagerPolicy.setRotationLw(int)|Called by the window manag
|android.view.WindowManagerPolicy.setSafeMode(boolean)|Called when the system i
|android.view.WindowManagerPolicy.setTouchExplorationEnabled(boolean)|Sets the 
|android.view.WindowManagerPolicy.setUserRotationMode(int,int)|Inform the polic
|android.view.WindowManagerPolicy.showBootMessage(CharSequence,boolean)|Show bo
|android.view.WindowManagerPolicy.subWindowTypeToLayerLw(int)|Return how to Z-o
|android.view.WindowManagerPolicy.systemBooted()|Called when the system is done
|android.view.WindowManagerPolicy.systemReady()|Called when the system is mostl
|android.view.WindowManagerPolicy.userActivity()|Called when userActivity is si
|android.view.WindowManagerPolicy.validateRotationAnimationLw(int,int,boolean)|
|android.view.WindowManagerPolicy.windowTypeToLayerLw(int)|Assign a window type

*android.view.WindowManagerPolicy_Description*

This interface supplies all UI-specific behavior of the window manager. An 
instance of it is created by the window manager when it starts up, and allows 
customization of window layering, special window types, key dispatching, and 
layout. 

Because this provides deep interaction with the system window manager, specific 
methods on this interface can be called from a variety of contexts with various 
restrictions on what they can do. These are encoded through a suffixes at the 
end of a method encoding the thread the method is called from and any locks 
that are held when it is being called; if no suffix is attached to a method, 
then it is not called with any locks and may be called from the main window 
manager thread or another thread calling into the window manager. 

The current suffixes are: 

Ti Called from the input thread. This is the thread that collects pending input 
events and dispatches them to the appropriate window. It may block waiting for 
events to be processed, so that the input stream is properly serialized. Tq 
Called from the low-level input queue thread. This is the thread that reads 
events out of the raw input devices and places them into the global input queue 
that is read by the Ti thread. This thread should not block for a long period 
of time on anything but the key driver. Lw Called with the main window manager 
lock held. Because the window manager is a very low-level system service, there 
are few other system services you can call with this lock held. It is 
explicitly okay to make calls into the package manager and power manager; it is 
explicitly not okay to make calls into the activity manager or most other 
services. Note that (|android.content.Context|) and variations require calling 
into the activity manager. Li Called with the input thread lock held. This lock 
can be acquired by the window manager while it holds the window lock, so this 
is even more restrictive than Lw. 



*int_android.view.WindowManagerPolicy.ACTION_GO_TO_SLEEP*

This key event should put the device to sleep (and engage keyguard if 
necessary) To be returned from (|android.view.WindowManagerPolicy|) . Do not 
return this and (|android.view.WindowManagerPolicy|) or 
(|android.view.WindowManagerPolicy|) . 


*java.lang.String_android.view.WindowManagerPolicy.ACTION_HDMI_PLUGGED*

Sticky broadcast of the current HDMI plugged state. 


*int_android.view.WindowManagerPolicy.ACTION_PASS_TO_USER*

Pass this event to the user / app. To be returned from 
(|android.view.WindowManagerPolicy|) . 


*int_android.view.WindowManagerPolicy.ACTION_WAKE_UP*

This key event should wake the device. To be returned from 
(|android.view.WindowManagerPolicy|) . Do not return this and 
(|android.view.WindowManagerPolicy|) or (|android.view.WindowManagerPolicy|) . 


*java.lang.String_android.view.WindowManagerPolicy.EXTRA_HDMI_PLUGGED_STATE*

Extra in (|android.view.WindowManagerPolicy|) indicating the state: true if 
plugged in to HDMI, false if not. 


*int_android.view.WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM*

Need to recompute animations 


*int_android.view.WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG*

Configuration state may have changed 


*int_android.view.WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT*

Layout state may have changed (so another layout will be performed) 


*int_android.view.WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER*

Wallpaper may need to move 


*int_android.view.WindowManagerPolicy.FLAG_ALT*




*int_android.view.WindowManagerPolicy.FLAG_ALT_GR*




*int_android.view.WindowManagerPolicy.FLAG_BRIGHT_HERE*




*int_android.view.WindowManagerPolicy.FLAG_CAPS_LOCK*




*int_android.view.WindowManagerPolicy.FLAG_DISABLE_KEY_REPEAT*




*int_android.view.WindowManagerPolicy.FLAG_FILTERED*




*int_android.view.WindowManagerPolicy.FLAG_INJECTED*




*int_android.view.WindowManagerPolicy.FLAG_LAUNCHER*




*int_android.view.WindowManagerPolicy.FLAG_MENU*




*int_android.view.WindowManagerPolicy.FLAG_PASS_TO_USER*




*int_android.view.WindowManagerPolicy.FLAG_SHIFT*




*int_android.view.WindowManagerPolicy.FLAG_TRUSTED*




*int_android.view.WindowManagerPolicy.FLAG_VIRTUAL*




*int_android.view.WindowManagerPolicy.FLAG_WAKE*




*int_android.view.WindowManagerPolicy.FLAG_WAKE_DROPPED*




*int_android.view.WindowManagerPolicy.FLAG_WOKE_HERE*




*int_android.view.WindowManagerPolicy.OFF_BECAUSE_OF_ADMIN*

Screen turned off because of a device admin 


*int_android.view.WindowManagerPolicy.OFF_BECAUSE_OF_PROX_SENSOR*

Screen turned off because of proximity sensor 


*int_android.view.WindowManagerPolicy.OFF_BECAUSE_OF_TIMEOUT*

Screen turned off because of timeout 


*int_android.view.WindowManagerPolicy.OFF_BECAUSE_OF_USER*

Screen turned off because of power button 


*int_android.view.WindowManagerPolicy.PRESENCE_EXTERNAL*




*int_android.view.WindowManagerPolicy.PRESENCE_INTERNAL*




*int_android.view.WindowManagerPolicy.TRANSIT_ENTER*

Window has been added to the screen. 


*int_android.view.WindowManagerPolicy.TRANSIT_EXIT*

Window has been removed from the screen. 


*int_android.view.WindowManagerPolicy.TRANSIT_HIDE*

Window has been made invisible. TODO: Consider removal as this is unused. 


*int_android.view.WindowManagerPolicy.TRANSIT_PREVIEW_DONE*

The "application starting" preview window is no longer needed, and will animate 
away to show the real window. 


*int_android.view.WindowManagerPolicy.TRANSIT_SHOW*

Window has been made visible. 


*int_android.view.WindowManagerPolicy.USER_ROTATION_FREE*

When not otherwise specified by the activity's screenOrientation, rotation 
should be determined by the system (that is, using sensors). 


*int_android.view.WindowManagerPolicy.USER_ROTATION_LOCKED*

When not otherwise specified by the activity's screenOrientation, rotation is 
set by the user. 


*boolean_android.view.WindowManagerPolicy.WATCH_POINTER*





*android.view.WindowManagerPolicy.addStartingWindow(IBinder,String,int,CompatibilityInfo,CharSequence,int,int,int,int)*

public |android.view.View| addStartingWindow(
  android.os.IBinder appToken,
  java.lang.String packageName,
  int theme,
  android.content.res.CompatibilityInfo compatInfo,
  java.lang.CharSequence nonLocalizedLabel,
  int labelRes,
  int icon,
  int logo,
  int windowFlags)

Called when the system would like to show a UI to indicate that an application 
is starting. You can use this to add a APPLICATION_STARTING_TYPE window with 
the given appToken to the window manager (using the normal window manager APIs) 
that will be shown until the application displays its own window. This is 
called without the window manager locked so that you can call back into it. 


    appToken - Token of the application being started. 
    packageName - The name of the application package being started. 
    theme - Resource defining the application's overall visual theme. 
    nonLocalizedLabel - The default title label of the application if no data is found in the resource. 
    labelRes - The resource ID the application would like to use as its name. 
    icon - The resource ID the application would like to use as its icon. 
    windowFlags - Window layout flags. 

    Returns: Optionally you can return the View that was used to create the window, for easy 
             removal in removeStartingWindow. 

*android.view.WindowManagerPolicy.adjustConfigurationLw(Configuration,int,int)*

public void adjustConfigurationLw(
  android.content.res.Configuration config,
  int keyboardPresence,
  int navigationPresence)

After the window manager has computed the current configuration based on its 
knowledge of the display and input devices, it gives the policy a chance to 
adjust the information contained in it. If you want to leave it as-is, simply 
do nothing. 

This method may be called by any thread in the window manager, but no internal 
locks in the window manager will be held. 


    config - The Configuration being computed, for you to change as desired. 
    keyboardPresence - Flags that indicate whether internal or external keyboards are present. 
    navigationPresence - Flags that indicate whether internal or external navigation devices are 
       present. 

*android.view.WindowManagerPolicy.adjustSystemUiVisibilityLw(int)*

public int adjustSystemUiVisibilityLw(int visibility)

Called when a new system UI visibility is being reported, allowing the policy 
to adjust what is actually reported. 


    visibility - The raw visiblity reported by the status bar. 

    Returns: The new desired visibility. 

*android.view.WindowManagerPolicy.adjustWindowParamsLw(WindowManager.LayoutParams)*

public void adjustWindowParamsLw(android.view.WindowManager.LayoutParams attrs)

Sanitize the layout parameters coming from a client. Allows the policy to do 
things like ensure that windows of a specific type can't take input focus. 


    attrs - The window layout parameters to be modified. These values are modified 
       in-place. 

*android.view.WindowManagerPolicy.allowAppAnimationsLw()*

public boolean allowAppAnimationsLw()

Return true if it is okay to perform animations for an app transition that is 
about to occur. You may return false for this if, for example, the lock screen 
is currently displayed so the switch should happen immediately. 



*android.view.WindowManagerPolicy.applyPostLayoutPolicyLw(WindowManagerPolicy.WindowState,WindowManager.LayoutParams)*

public void applyPostLayoutPolicyLw(
  android.view.WindowManagerPolicy.WindowState win,
  android.view.WindowManager.LayoutParams attrs)

Called following layout of all window to apply policy to each window. 


    win - The window being positioned. 
    attrs - The LayoutParams of the window. 

*android.view.WindowManagerPolicy.beginLayoutLw(boolean,int,int,int)*

public void beginLayoutLw(
  boolean isDefaultDisplay,
  int displayWidth,
  int displayHeight,
  int displayRotation)

Called when layout of the windows is about to start. 


    isDefaultDisplay - true if window is on {@link Display#DEFAULT_DISPLAY}. 
    displayWidth - The current full width of the screen. 
    displayHeight - The current full height of the screen. 
    displayRotation - The current rotation being applied to the base window. 

*android.view.WindowManagerPolicy.beginPostLayoutPolicyLw(int,int)*

public void beginPostLayoutPolicyLw(
  int displayWidth,
  int displayHeight)

Called following layout of all windows before each window has policy applied. 


    displayWidth - The current full width of the screen. 
    displayHeight - The current full height of the screen. 

*android.view.WindowManagerPolicy.canBeForceHidden(WindowManagerPolicy.WindowState,WindowManager.LayoutParams)*

public boolean canBeForceHidden(
  android.view.WindowManagerPolicy.WindowState win,
  android.view.WindowManager.LayoutParams attrs)

Determine if a window that is behind one that is force hiding (as determined by 
(|android.view.WindowManagerPolicy|) ) should actually be hidden. For example, 
typically returns false for the status bar. Be careful to return false for any 
window that you may hide yourself, since this will conflict with what you set. 



*android.view.WindowManagerPolicy.canMagnifyWindow(int)*

public boolean canMagnifyWindow(int windowType)

Returns whether a given window type can be magnified. 


    windowType - The window type. 

    Returns: True if the window can be magnified. 

*android.view.WindowManagerPolicy.checkAddPermission(WindowManager.LayoutParams,int[])*

public int checkAddPermission(
  android.view.WindowManager.LayoutParams attrs,
  int[] outAppOp)

Check permissions when adding a window. 


    attrs - The window's LayoutParams. 
    outAppOp - First element will be filled with the app op corresponding to this window, or 
       OP_NONE. 

    Returns: {@link WindowManagerGlobal#ADD_OKAY} if the add can proceed; else an error 
             code, usually {@link WindowManagerGlobal#ADD_PERMISSION_DENIED}, 
             to abort the add. 

*android.view.WindowManagerPolicy.checkShowToOwnerOnly(WindowManager.LayoutParams)*

public boolean checkShowToOwnerOnly(android.view.WindowManager.LayoutParams attrs)

Check permissions when adding a window. 


    attrs - The window's LayoutParams. 

    Returns: True if the window may only be shown to the current user, false if the window 
             can be shown on all users' windows. 

*android.view.WindowManagerPolicy.createForceHideEnterAnimation(boolean)*

public |android.view.animation.Animation| createForceHideEnterAnimation(boolean onWallpaper)

Create and return an animation to re-display a force hidden window. 



*android.view.WindowManagerPolicy.dismissKeyguardLw()*

public void dismissKeyguardLw()

Ask the policy to dismiss the keyguard, if it is currently shown. 



*android.view.WindowManagerPolicy.dispatchUnhandledKey(WindowManagerPolicy.WindowState,KeyEvent,int)*

public |android.view.KeyEvent| dispatchUnhandledKey(
  android.view.WindowManagerPolicy.WindowState win,
  android.view.KeyEvent event,
  int policyFlags)

Called from the input dispatcher thread when an application did not handle a 
key that was dispatched to it. 

Allows you to define default global behavior for keys that were not handled by 
applications. This method is called from the input thread, with no locks held. 


    win - The window that currently has focus. This is where the key event will normally 
       go. 
    event - The key event. 
    policyFlags - The policy flags associated with the key. 

    Returns: Returns an alternate key event to redispatch as a fallback, or null to give up. 
             The caller is responsible for recycling the key event. 

*android.view.WindowManagerPolicy.doesForceHide(WindowManagerPolicy.WindowState,WindowManager.LayoutParams)*

public boolean doesForceHide(
  android.view.WindowManagerPolicy.WindowState win,
  android.view.WindowManager.LayoutParams attrs)

Return whether the given window should forcibly hide everything behind it. 
Typically returns true for the keyguard. 



*android.view.WindowManagerPolicy.dump(String,PrintWriter,String[])*

public void dump(
  java.lang.String prefix,
  java.io.PrintWriter writer,
  java.lang.String[] args)

Print the WindowManagerPolicy's state into the given stream. 


    prefix - Text to print at the front of each line. 
    writer - The PrintWriter to which you should dump your state. This will be closed for 
       you after you return. 
    args - additional arguments to the dump request. 

*android.view.WindowManagerPolicy.enableKeyguard(boolean)*

public void enableKeyguard(boolean enabled)

Tell the policy if anyone is requesting that keyguard not come on. 


    enabled - Whether keyguard can be on or not. does not actually turn it on, unless it was 
       previously disabled with this function. 

*android.view.WindowManagerPolicy.enableScreenAfterBoot()*

public void enableScreenAfterBoot()

Called when we have finished booting and can now display the home screen to the 
user. This will happen after systemReady(), and at this point the display is 
active. 



*android.view.WindowManagerPolicy.exitKeyguardSecurely(WindowManagerPolicy.OnKeyguardExitResult)*

public void exitKeyguardSecurely(android.view.WindowManagerPolicy.OnKeyguardExitResult callback)

Tell the policy if anyone is requesting the keyguard to exit securely (this 
would be called after the keyguard was disabled) 


    callback - Callback to send the result back. 

*android.view.WindowManagerPolicy.finishLayoutLw()*

public void finishLayoutLw()

Called when layout of the windows is finished. After this function has 
returned, all windows given to layoutWindow() must have had a frame assigned. 



*android.view.WindowManagerPolicy.finishPostLayoutPolicyLw()*

public int finishPostLayoutPolicyLw()

Called following layout of all windows and after policy has been applied to 
each window. If in this function you do something that may have modified the 
animation state of another window, be sure to return non-zero in order to 
perform another pass through layout. 



    Returns: Return any bit set of {@link #FINISH_LAYOUT_REDO_LAYOUT}, {@link 
             #FINISH_LAYOUT_REDO_CONFIG}, {@link 
             #FINISH_LAYOUT_REDO_WALLPAPER}, or {@link 
             #FINISH_LAYOUT_REDO_ANIM}. 

*android.view.WindowManagerPolicy.focusChangedLw(WindowManagerPolicy.WindowState,WindowManagerPolicy.WindowState)*

public int focusChangedLw(
  android.view.WindowManagerPolicy.WindowState lastFocus,
  android.view.WindowManagerPolicy.WindowState newFocus)

A new window has been focused. 



*android.view.WindowManagerPolicy.getAboveUniverseLayer()*

public int getAboveUniverseLayer()

Return the window layer at which windows appear above the normal universe (that 
is no longer impacted by the universe background transform). 



*android.view.WindowManagerPolicy.getConfigDisplayHeight(int,int,int)*

public int getConfigDisplayHeight(
  int fullWidth,
  int fullHeight,
  int rotation)

Return the available screen height that we should report for the configuration. 
This must be no larger than (|android.view.WindowManagerPolicy|) ; it may be 
smaller than that to account for more transient decoration like a status bar. 



*android.view.WindowManagerPolicy.getConfigDisplayWidth(int,int,int)*

public int getConfigDisplayWidth(
  int fullWidth,
  int fullHeight,
  int rotation)

Return the available screen width that we should report for the configuration. 
This must be no larger than (|android.view.WindowManagerPolicy|) ; it may be 
smaller than that to account for more transient decoration like a status bar. 



*android.view.WindowManagerPolicy.getContentInsetHintLw(WindowManager.LayoutParams,Rect)*

public void getContentInsetHintLw(
  android.view.WindowManager.LayoutParams attrs,
  Rect contentInset)

Return the insets for the areas covered by system windows. These values are 
computed on the most recent layout, so they are not guaranteed to be correct. 


    attrs - The LayoutParams of the window. 
    contentInset - The areas covered by system windows, expressed as positive insets 

*android.view.WindowManagerPolicy.getContentRectLw(Rect)*

public void getContentRectLw(Rect r)

Return the rectangle of the screen that is available for applications to run 
in. This will be called immediately after (|android.view.WindowManagerPolicy|) 
. 


    r - The rectangle to be filled with the boundaries available to applications. 

*android.view.WindowManagerPolicy.getMaxWallpaperLayer()*

public int getMaxWallpaperLayer()

Get the highest layer (actually one more than) that the wallpaper is allowed to 
be in. 



*android.view.WindowManagerPolicy.getNonDecorDisplayHeight(int,int,int)*

public int getNonDecorDisplayHeight(
  int fullWidth,
  int fullHeight,
  int rotation)

Return the display height available after excluding any screen decorations that 
can never be removed. That is, system bar or button bar. 



*android.view.WindowManagerPolicy.getNonDecorDisplayWidth(int,int,int)*

public int getNonDecorDisplayWidth(
  int fullWidth,
  int fullHeight,
  int rotation)

Return the display width available after excluding any screen decorations that 
can never be removed. That is, system bar or button bar. 



*android.view.WindowManagerPolicy.getSystemDecorLayerLw()*

public int getSystemDecorLayerLw()

Returns the bottom-most layer of the system decor, above which no policy decor 
should be applied. 



*android.view.WindowManagerPolicy.getUserRotationMode()*

public int getUserRotationMode()

Gets the current user rotation mode. 



    Returns: The rotation mode. 

*android.view.WindowManagerPolicy.hasNavigationBar()*

public boolean hasNavigationBar()

Specifies whether there is an on-screen navigation bar separate from the status 
bar. 



*android.view.WindowManagerPolicy.hideBootMessages()*

public void hideBootMessages()

Hide the UI for showing boot messages, never to be displayed again. 



*android.view.WindowManagerPolicy.init(Context,IWindowManager,WindowManagerPolicy.WindowManagerFuncs)*

public void init(
  android.content.Context context,
  IWindowManager windowManager,
  android.view.WindowManagerPolicy.WindowManagerFuncs windowManagerFuncs)

Perform initialization of the policy. 


    context - The system context we are running in. 

*android.view.WindowManagerPolicy.inKeyguardRestrictedKeyInputMode()*

public boolean inKeyguardRestrictedKeyInputMode()

inKeyguardRestrictedKeyInputMode 

if keyguard screen is showing or in restricted key input mode (i.e. in keyguard 
password emergency screen). When in such mode, certain keys, such as the Home 
key and the right soft keys, don't work. 



    Returns: true if in keyguard restricted input mode. 

*android.view.WindowManagerPolicy.interceptKeyBeforeDispatching(WindowManagerPolicy.WindowState,KeyEvent,int)*

public long interceptKeyBeforeDispatching(
  android.view.WindowManagerPolicy.WindowState win,
  android.view.KeyEvent event,
  int policyFlags)

Called from the input dispatcher thread before a key is dispatched to a window. 

Allows you to define behavior for keys that can not be overridden by 
applications. This method is called from the input thread, with no locks held. 


    win - The window that currently has focus. This is where the key event will normally 
       go. 
    event - The key event. 
    policyFlags - The policy flags associated with the key. 

    Returns: 0 if the key should be dispatched immediately, -1 if the key should not be 
             dispatched ever, or a positive value indicating the number of 
             milliseconds by which the key dispatch should be delayed before 
             trying again. 

*android.view.WindowManagerPolicy.interceptKeyBeforeQueueing(KeyEvent,int,boolean)*

public int interceptKeyBeforeQueueing(
  android.view.KeyEvent event,
  int policyFlags,
  boolean isScreenOn)

Called from the input reader thread before a key is enqueued. 

There are some actions that need to be handled here because they affect the 
power state of the device, for example, the power keys. Generally, it's best to 
keep as little as possible in the queue thread because it's the most fragile. 


    event - The key event. 
    policyFlags - The policy flags associated with the key. 
    isScreenOn - True if the screen is already on 

    Returns: The bitwise or of the {@link #ACTION_PASS_TO_USER}, {@link #ACTION_WAKE_UP} and 
             {@link #ACTION_GO_TO_SLEEP} flags. 

*android.view.WindowManagerPolicy.interceptMotionBeforeQueueingWhenScreenOff(int)*

public int interceptMotionBeforeQueueingWhenScreenOff(int policyFlags)

Called from the input reader thread before a motion is enqueued when the screen 
is off. 

There are some actions that need to be handled here because they affect the 
power state of the device, for example, waking on motions. Generally, it's best 
to keep as little as possible in the queue thread because it's the most 
fragile. 


    policyFlags - The policy flags associated with the motion. 

    Returns: The bitwise or of the {@link #ACTION_PASS_TO_USER}, {@link #ACTION_WAKE_UP} and 
             {@link #ACTION_GO_TO_SLEEP} flags. 

*android.view.WindowManagerPolicy.isDefaultOrientationForced()*

public boolean isDefaultOrientationForced()





    Returns: true if com.android.internal.R.bool#config_forceDefaultOrientation is true. 

*android.view.WindowManagerPolicy.isKeyguardLocked()*

public boolean isKeyguardLocked()

isKeyguardLocked 

Return whether the keyguard is currently locked. 



    Returns: true if in keyguard is locked. 

*android.view.WindowManagerPolicy.isKeyguardSecure()*

public boolean isKeyguardSecure()

isKeyguardSecure 

Return whether the keyguard requires a password to unlock. 



    Returns: true if in keyguard is secure. 

*android.view.WindowManagerPolicy.isScreenOnEarly()*

public boolean isScreenOnEarly()

Return whether the screen is about to turn on or is currently on. 



*android.view.WindowManagerPolicy.isScreenOnFully()*

public boolean isScreenOnFully()

Return whether the screen is fully turned on. 



*android.view.WindowManagerPolicy.isTopLevelWindow(int)*

public boolean isTopLevelWindow(int windowType)

Returns whether a given window type is considered a top level one. A top level 
window does not have a container, i.e. attached window, or if it has a 
container it is laid out as a top-level window, not as a child of its 
container. 


    windowType - The window type. 

    Returns: True if the window is a top level one. 

*android.view.WindowManagerPolicy.keepScreenOnStartedLw()*

public void keepScreenOnStartedLw()

Called when we have started keeping the screen on because a window requesting 
this has become visible. 



*android.view.WindowManagerPolicy.keepScreenOnStoppedLw()*

public void keepScreenOnStoppedLw()

Called when we have stopped keeping the screen on because the last window 
requesting this is no longer visible. 



*android.view.WindowManagerPolicy.layoutWindowLw(WindowManagerPolicy.WindowState,WindowManager.LayoutParams,WindowManagerPolicy.WindowState)*

public void layoutWindowLw(
  android.view.WindowManagerPolicy.WindowState win,
  android.view.WindowManager.LayoutParams attrs,
  android.view.WindowManagerPolicy.WindowState attached)

Called for each window attached to the window manager as layout is proceeding. 
The implementation of this function must take care of setting the window's 
frame, either here or in finishLayout(). 


    win - The window being positioned. 
    attrs - The LayoutParams of the window. 
    attached - For sub-windows, the window it is attached to; this window will already have 
       had layoutWindow() called on it so you can use its Rect. Otherwise null. 

*android.view.WindowManagerPolicy.lockNow(Bundle)*

public void lockNow(android.os.Bundle options)

Lock the device now. 



*android.view.WindowManagerPolicy.notifyLidSwitchChanged(long,boolean)*

public void notifyLidSwitchChanged(
  long whenNanos,
  boolean lidOpen)

Tell the policy that the lid switch has changed state. 


    whenNanos - The time when the change occurred in uptime nanoseconds. 
    lidOpen - True if the lid is now open. 

*android.view.WindowManagerPolicy.performHapticFeedbackLw(WindowManagerPolicy.WindowState,int,boolean)*

public boolean performHapticFeedbackLw(
  android.view.WindowManagerPolicy.WindowState win,
  int effectId,
  boolean always)

Call from application to perform haptic feedback on its window. 



*android.view.WindowManagerPolicy.prepareAddWindowLw(WindowManagerPolicy.WindowState,WindowManager.LayoutParams)*

public int prepareAddWindowLw(
  android.view.WindowManagerPolicy.WindowState win,
  android.view.WindowManager.LayoutParams attrs)

Prepare for a window being added to the window manager. You can throw an 
exception here to prevent the window being added, or do whatever setup you need 
to keep track of the window. 


    win - The window being added. 
    attrs - The window's LayoutParams. 

    Returns: {@link WindowManagerGlobal#ADD_OKAY} if the add can proceed, else an error code 
             to abort the add. 

*android.view.WindowManagerPolicy.removeStartingWindow(IBinder,View)*

public void removeStartingWindow(
  android.os.IBinder appToken,
  android.view.View window)

Called when the first window of an application has been displayed, while 
(|android.view.WindowManagerPolicy|) has created a temporary initial window for 
that application. You should at this point remove the window from the window 
manager. This is called without the window manager locked so that you can call 
back into it. 

Note: due to the nature of these functions not being called with the window 
manager locked, you must be prepared for this function to be called multiple 
times and/or an initial time with a null View window even if you previously 
returned one. 


    appToken - Token of the application that has started. 
    window - Window View that was returned by createStartingWindow. 

*android.view.WindowManagerPolicy.removeWindowLw(WindowManagerPolicy.WindowState)*

public void removeWindowLw(android.view.WindowManagerPolicy.WindowState win)

Called when a window is being removed from a window manager. Must not throw an 
exception -- clean up as much as possible. 


    win - The window being removed. 

*android.view.WindowManagerPolicy.rotationForOrientationLw(int,int)*

public int rotationForOrientationLw(
  int orientation,
  int lastRotation)

Given an orientation constant, returns the appropriate surface rotation, taking 
into account sensors, docking mode, rotation lock, and other factors. 


    orientation - An orientation constant, such as {@link 
       android.content.pm.ActivityInfo#SCREEN_ORIENTATION_LANDSCAPE}. 
    lastRotation - The most recently used rotation. 

    Returns: The surface rotation to use. 

*android.view.WindowManagerPolicy.rotationHasCompatibleMetricsLw(int,int)*

public boolean rotationHasCompatibleMetricsLw(
  int orientation,
  int rotation)

Given an orientation constant and a rotation, returns true if the rotation has 
compatible metrics to the requested orientation. For example, if the 
application requested landscape and got seascape, then the rotation has 
compatible metrics; if the application requested portrait and got landscape, 
then the rotation has incompatible metrics; if the application did not specify 
a preference, then anything goes. 


    orientation - An orientation constant, such as {@link 
       android.content.pm.ActivityInfo#SCREEN_ORIENTATION_LANDSCAPE}. 
    rotation - The rotation to check. 

    Returns: True if the rotation is compatible with the requested orientation. 

*android.view.WindowManagerPolicy.screenTurnedOff(int)*

public void screenTurnedOff(int why)

Called after the screen turns off. 


    why - {@link #OFF_BECAUSE_OF_USER} or {@link #OFF_BECAUSE_OF_TIMEOUT}. 

*android.view.WindowManagerPolicy.screenTurningOn(WindowManagerPolicy.ScreenOnListener)*

public void screenTurningOn(android.view.WindowManagerPolicy.ScreenOnListener screenOnListener)

Called when the power manager would like to turn the screen on. Must call back 
on the listener to tell it when the higher-level system is ready for the screen 
to go on (i.e. the lock screen is shown). 



*android.view.WindowManagerPolicy.selectAnimationLw(WindowManagerPolicy.WindowState,int)*

public int selectAnimationLw(
  android.view.WindowManagerPolicy.WindowState win,
  int transit)

Control the animation to run when a window's state changes. Return a non-0 
number to force the animation to a specific resource ID, or 0 to use the 
default animation. 


    win - The window that is changing. 
    transit - What is happening to the window: {@link #TRANSIT_ENTER}, {@link #TRANSIT_EXIT}, 
       {@link #TRANSIT_SHOW}, or {@link #TRANSIT_HIDE}. 

    Returns: Resource ID of the actual animation to use, or 0 for none. 

*android.view.WindowManagerPolicy.selectRotationAnimationLw(int[])*

public void selectRotationAnimationLw(int[] anim)

Determine the animation to run for a rotation transition based on the top 
fullscreen windows (|android.view.WindowManager.LayoutParams|) and whether it 
is currently fullscreen and frontmost. 


    anim - The exiting animation resource id is stored in anim[0], the entering animation 
       resource id is stored in anim[1]. 

*android.view.WindowManagerPolicy.setCurrentOrientationLw(int)*

public void setCurrentOrientationLw(int newOrientation)





*android.view.WindowManagerPolicy.setCurrentUserLw(int)*

public void setCurrentUserLw(int newUserId)

Called when the current user changes. Guaranteed to be called before the 
broadcast of the new user id is made to all listeners. 


    newUserId - The id of the incoming user. 

*android.view.WindowManagerPolicy.setDisplayOverscan(Display,int,int,int,int)*

public void setDisplayOverscan(
  android.view.Display display,
  int left,
  int top,
  int right,
  int bottom)

Called by window manager to set the overscan region that should be used for the 
given display. 



*android.view.WindowManagerPolicy.setInitialDisplaySize(Display,int,int,int)*

public void setInitialDisplaySize(
  android.view.Display display,
  int width,
  int height,
  int density)

Called by window manager once it has the initial, default native display 
dimensions. 



*android.view.WindowManagerPolicy.setLastInputMethodWindowLw(WindowManagerPolicy.WindowState,WindowManagerPolicy.WindowState)*

public void setLastInputMethodWindowLw(
  android.view.WindowManagerPolicy.WindowState ime,
  android.view.WindowManagerPolicy.WindowState target)

Set the last used input method window state. This state is used to make IME 
transition smooth. 



*android.view.WindowManagerPolicy.setRotationLw(int)*

public void setRotationLw(int rotation)

Called by the window manager when the rotation changes. 


    rotation - The new rotation. 

*android.view.WindowManagerPolicy.setSafeMode(boolean)*

public void setSafeMode(boolean safeMode)

Called when the system is mostly done booting to set whether the system should 
go into safe mode. 



*android.view.WindowManagerPolicy.setTouchExplorationEnabled(boolean)*

public void setTouchExplorationEnabled(boolean enabled)

Sets the current touch exploration state. 


    enabled - Whether touch exploration is enabled. 

*android.view.WindowManagerPolicy.setUserRotationMode(int,int)*

public void setUserRotationMode(
  int mode,
  int rotation)

Inform the policy that the user has chosen a preferred orientation ("rotation 
lock"). 


    mode - One of {@link WindowManagerPolicy#USER_ROTATION_LOCKED} or {@link 
       WindowManagerPolicy#USER_ROTATION_FREE}. 
    rotation - One of {@link Surface#ROTATION_0}, {@link Surface#ROTATION_90}, {@link 
       Surface#ROTATION_180}, {@link Surface#ROTATION_270}. 

*android.view.WindowManagerPolicy.showBootMessage(CharSequence,boolean)*

public void showBootMessage(
  java.lang.CharSequence msg,
  boolean always)

Show boot time message to the user. 



*android.view.WindowManagerPolicy.subWindowTypeToLayerLw(int)*

public int subWindowTypeToLayerLw(int type)

Return how to Z-order sub-windows in relation to the window they are attached 
to. Return positive to have them ordered in front, negative for behind. 


    type - The sub-window type code. 

    Returns: int Layer in relation to the attached window, where positive is above and 
             negative is below. 

*android.view.WindowManagerPolicy.systemBooted()*

public void systemBooted()

Called when the system is done booting to the point where the user can start 
interacting with it. 



*android.view.WindowManagerPolicy.systemReady()*

public void systemReady()

Called when the system is mostly done booting. 



*android.view.WindowManagerPolicy.userActivity()*

public void userActivity()

Called when userActivity is signalled in the power manager. This is safe to 
call from any thread, with any window manager locks held or not. 



*android.view.WindowManagerPolicy.validateRotationAnimationLw(int,int,boolean)*

public boolean validateRotationAnimationLw(
  int exitAnimId,
  int enterAnimId,
  boolean forceDefault)

Validate whether the current top fullscreen has specified the same 
(|android.view.WindowManager.LayoutParams|) value as that being passed in from 
the previous top fullscreen window. 


    exitAnimId - exiting resource id from the previous window. 
    enterAnimId - entering resource id from the previous window. 
    forceDefault - For rotation animations only, if true ignore the animation values and just 
       return false. 

    Returns: true if the previous values are still valid, false if they should be replaced 
             with the default. 

*android.view.WindowManagerPolicy.windowTypeToLayerLw(int)*

public int windowTypeToLayerLw(int type)

Assign a window type to a layer. Allows you to control how different kinds of 
windows are ordered on-screen. 


    type - The type of window being assigned. 

    Returns: int An arbitrary integer used to order windows, with lower numbers below higher 
             ones. 


