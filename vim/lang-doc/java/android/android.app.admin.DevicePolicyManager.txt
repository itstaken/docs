*android.app.admin.DevicePolicyManager* *DevicePolicyManager* Public interface f

public class DevicePolicyManager
  extends    |java.lang.Object|

|android.app.admin.DevicePolicyManager_Description|
|android.app.admin.DevicePolicyManager_Fields|
|android.app.admin.DevicePolicyManager_Constructors|
|android.app.admin.DevicePolicyManager_Methods|

================================================================================

*android.app.admin.DevicePolicyManager_Fields*
|java.lang.String_android.app.admin.DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN|
|java.lang.String_android.app.admin.DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED|
|java.lang.String_android.app.admin.DevicePolicyManager.ACTION_SET_NEW_PASSWORD|
|java.lang.String_android.app.admin.DevicePolicyManager.ACTION_START_ENCRYPTION|
|int_android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVATING|
|int_android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE|
|int_android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE|
|int_android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED|
|java.lang.String_android.app.admin.DevicePolicyManager.EXTRA_ADD_EXPLANATION|
|java.lang.String_android.app.admin.DevicePolicyManager.EXTRA_DEVICE_ADMIN|
|int_android.app.admin.DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_ALL|
|int_android.app.admin.DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_NONE|
|int_android.app.admin.DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA|
|int_android.app.admin.DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL|
|int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC|
|int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC|
|int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK|
|int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_COMPLEX|
|int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC|
|int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_SOMETHING|
|int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED|
|int_android.app.admin.DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY|
|int_android.app.admin.DevicePolicyManager.WIPE_EXTERNAL_STORAGE|

*android.app.admin.DevicePolicyManager_Methods*
|android.app.admin.DevicePolicyManager.create(Context,Handler)|
|android.app.admin.DevicePolicyManager.getActiveAdmins()|Return a list of all c
|android.app.admin.DevicePolicyManager.getAdminInfo(ComponentName)|Returns the 
|android.app.admin.DevicePolicyManager.getCameraDisabled(ComponentName)|Determi
|android.app.admin.DevicePolicyManager.getCameraDisabled(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getCurrentFailedPasswordAttempts()|Retri
|android.app.admin.DevicePolicyManager.getDeviceOwner()|
|android.app.admin.DevicePolicyManager.getDeviceOwnerName()|
|android.app.admin.DevicePolicyManager.getGlobalProxyAdmin()|Returns the compon
|android.app.admin.DevicePolicyManager.getKeyguardDisabledFeatures(ComponentName)|
|android.app.admin.DevicePolicyManager.getKeyguardDisabledFeatures(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getMaximumFailedPasswordsForWipe(ComponentName)|
|android.app.admin.DevicePolicyManager.getMaximumFailedPasswordsForWipe(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getMaximumTimeToLock(ComponentName)|Retr
|android.app.admin.DevicePolicyManager.getMaximumTimeToLock(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getPasswordExpiration(ComponentName)|Get
|android.app.admin.DevicePolicyManager.getPasswordExpirationTimeout(ComponentName)|
|android.app.admin.DevicePolicyManager.getPasswordHistoryLength(ComponentName)|
|android.app.admin.DevicePolicyManager.getPasswordHistoryLength(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getPasswordMaximumLength(int)|Return the
|android.app.admin.DevicePolicyManager.getPasswordMinimumLength(ComponentName)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumLength(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumLetters(ComponentName)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumLetters(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumLowerCase(ComponentName)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumLowerCase(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumNonLetter(ComponentName)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumNonLetter(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumNumeric(ComponentName)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumNumeric(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumSymbols(ComponentName)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumSymbols(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumUpperCase(ComponentName)|
|android.app.admin.DevicePolicyManager.getPasswordMinimumUpperCase(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getPasswordQuality(ComponentName)|Retrie
|android.app.admin.DevicePolicyManager.getPasswordQuality(ComponentName,int)|
|android.app.admin.DevicePolicyManager.getRemoveWarning(ComponentName,RemoteCallback)|
|android.app.admin.DevicePolicyManager.getStorageEncryption(ComponentName)|Call
|android.app.admin.DevicePolicyManager.getStorageEncryptionStatus()|Called by a
|android.app.admin.DevicePolicyManager.getStorageEncryptionStatus(int)|
|android.app.admin.DevicePolicyManager.hasAnyCaCertsInstalled()|Returns whether
|android.app.admin.DevicePolicyManager.hasCaCertInstalled(byte[])|Returns wheth
|android.app.admin.DevicePolicyManager.hasGrantedPolicy(ComponentName,int)|Retu
|android.app.admin.DevicePolicyManager.installCaCert(byte[])|Installs the given
|android.app.admin.DevicePolicyManager.isActivePasswordSufficient()|Determine w
|android.app.admin.DevicePolicyManager.isAdminActive(ComponentName)|Return true
|android.app.admin.DevicePolicyManager.isDeviceOwner(String)|
|android.app.admin.DevicePolicyManager.isDeviceOwnerApp(String)|Used to determi
|android.app.admin.DevicePolicyManager.lockNow()|Make the device lock immediate
|android.app.admin.DevicePolicyManager.packageHasActiveAdmins(String)|Used by p
|android.app.admin.DevicePolicyManager.removeActiveAdmin(ComponentName)|Remove 
|android.app.admin.DevicePolicyManager.reportFailedPasswordAttempt(int)|
|android.app.admin.DevicePolicyManager.reportSuccessfulPasswordAttempt(int)|
|android.app.admin.DevicePolicyManager.resetPassword(String,int)|Force a new de
|android.app.admin.DevicePolicyManager.setActiveAdmin(ComponentName,boolean)|
|android.app.admin.DevicePolicyManager.setActivePasswordState(int,int,int,int,int,int,int,int,int)|
|android.app.admin.DevicePolicyManager.setCameraDisabled(ComponentName,boolean)|
|android.app.admin.DevicePolicyManager.setDeviceOwner(String)|
|android.app.admin.DevicePolicyManager.setDeviceOwner(String,String)|
|android.app.admin.DevicePolicyManager.setGlobalProxy(ComponentName,Proxy,List<String>)|
|android.app.admin.DevicePolicyManager.setKeyguardDisabledFeatures(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setMaximumFailedPasswordsForWipe(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setMaximumTimeToLock(ComponentName,long)|
|android.app.admin.DevicePolicyManager.setPasswordExpirationTimeout(ComponentName,long)|
|android.app.admin.DevicePolicyManager.setPasswordHistoryLength(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setPasswordMinimumLength(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setPasswordMinimumLetters(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setPasswordMinimumLowerCase(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setPasswordMinimumNonLetter(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setPasswordMinimumNumeric(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setPasswordMinimumSymbols(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setPasswordMinimumUpperCase(ComponentName,int)|
|android.app.admin.DevicePolicyManager.setPasswordQuality(ComponentName,int)|Ca
|android.app.admin.DevicePolicyManager.setStorageEncryption(ComponentName,boolean)|
|android.app.admin.DevicePolicyManager.uninstallCaCert(byte[])|Uninstalls the g
|android.app.admin.DevicePolicyManager.wipeData(int)|Ask the user date be wiped

*android.app.admin.DevicePolicyManager_Description*

Public interface for managing policies enforced on a device. Most clients of 
this class must have published a (|android.app.admin.DeviceAdminReceiver|) that 
the user has currently enabled. 

Developer Guides For more information about managing policies for device 
adminstration, read the <a href="guide/topics/admin/device-admin.html">Device 
Administration developer guide. 



*java.lang.String_android.app.admin.DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN*

Activity action: ask the user to add a new device administrator to the system. 
The desired policy is the ComponentName of the policy in the 
(|android.app.admin.DevicePolicyManager|) extra field. This will invoke a UI to 
bring the user through adding the device administrator to the system (or 
allowing them to reject it). 

You can optionally include the (|android.app.admin.DevicePolicyManager|) field 
to provide the user with additional explanation (in addition to your 
component's description) about what is being added. 

If your administrator is already active, this will ordinarily return 
immediately (without user intervention). However, if your administrator has 
been updated and is requesting additional uses-policy flags, the user will be 
presented with the new list. New policies will not be available to the updated 
administrator until the user has accepted the new list. 


*java.lang.String_android.app.admin.DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED*

Activity action: send when any policy admin changes a policy. This is generally 
used to find out when a new policy is in effect. 


*java.lang.String_android.app.admin.DevicePolicyManager.ACTION_SET_NEW_PASSWORD*

Activity action: have the user enter a new password. This activity should be 
launched after using (|android.app.admin.DevicePolicyManager|) , or 
(|android.app.admin.DevicePolicyManager|) to have the user enter a new password 
that meets the current requirements. You can use 
(|android.app.admin.DevicePolicyManager|) to determine whether you need to have 
the user select a new password in order to meet the current constraints. Upon 
being resumed from this activity, you can check the new password 
characteristics to see if they are sufficient. 


*java.lang.String_android.app.admin.DevicePolicyManager.ACTION_START_ENCRYPTION*

Activity action: begin the process of encrypting data on the device. This 
activity should be launched after using 
(|android.app.admin.DevicePolicyManager|) to request encryption be activated. 
After resuming from this activity, use 
(|android.app.admin.DevicePolicyManager|) to check encryption status. However, 
on some devices this activity may never return, as it may trigger a reboot and 
in some cases a complete data wipe of the device. 


*int_android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVATING*

Result code for (|android.app.admin.DevicePolicyManager|) and 
(|android.app.admin.DevicePolicyManager|) : indicating that encryption is not 
currently active, but is currently being activated. This is only reported by 
devices that support encryption of data and only when the storage is currently 
undergoing a process of becoming encrypted. A device that must reboot and/or 
wipe data to become encrypted will never return this value. 


*int_android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE*

Result code for (|android.app.admin.DevicePolicyManager|) and 
(|android.app.admin.DevicePolicyManager|) : indicating that encryption is 
active. 


*int_android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE*

Result code for (|android.app.admin.DevicePolicyManager|) and 
(|android.app.admin.DevicePolicyManager|) : indicating that encryption is 
supported, but is not currently active. 


*int_android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED*

Result code for (|android.app.admin.DevicePolicyManager|) and 
(|android.app.admin.DevicePolicyManager|) : indicating that encryption is not 
supported. 


*java.lang.String_android.app.admin.DevicePolicyManager.EXTRA_ADD_EXPLANATION*

An optional CharSequence providing additional explanation for why the admin is 
being added. 


*java.lang.String_android.app.admin.DevicePolicyManager.EXTRA_DEVICE_ADMIN*

The ComponentName of the administrator component. 


*int_android.app.admin.DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_ALL*

Disable all current and future keyguard customizations. 


*int_android.app.admin.DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_NONE*

Widgets are enabled in keyguard 


*int_android.app.admin.DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA*

Disable the camera on secure keyguard screens (e.g. PIN/Pattern/Password) 


*int_android.app.admin.DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL*

Disable all keyguard widgets 


*int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC*

Constant for (|android.app.admin.DevicePolicyManager|) : the user must have 
entered a password containing at least alphabetic (or other symbol) characters. 
Note that quality constants are ordered so that higher values are more 
restrictive. 


*int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC*

Constant for (|android.app.admin.DevicePolicyManager|) : the user must have 
entered a password containing at least both> numeric and alphabetic (or other 
symbol) characters. Note that quality constants are ordered so that higher 
values are more restrictive. 


*int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK*

Constant for (|android.app.admin.DevicePolicyManager|) : the policy allows for 
low-security biometric recognition technology. This implies technologies that 
can recognize the identity of an individual to about a 3 digit PIN (false 
detection is less than 1 in 1,000). Note that quality constants are ordered so 
that higher values are more restrictive. 


*int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_COMPLEX*

Constant for (|android.app.admin.DevicePolicyManager|) : the user must have 
entered a password containing at least a letter, a numerical digit and a 
special symbol, by default. With this password quality, passwords can be 
restricted to contain various sets of characters, like at least an uppercase 
letter, etc. These are specified using various methods, like 
(|android.app.admin.DevicePolicyManager|) . Note that quality constants are 
ordered so that higher values are more restrictive. 


*int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC*

Constant for (|android.app.admin.DevicePolicyManager|) : the user must have 
entered a password containing at least numeric characters. Note that quality 
constants are ordered so that higher values are more restrictive. 


*int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_SOMETHING*

Constant for (|android.app.admin.DevicePolicyManager|) : the policy requires 
some kind of password, but doesn't care what it is. Note that quality constants 
are ordered so that higher values are more restrictive. 


*int_android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED*

Constant for (|android.app.admin.DevicePolicyManager|) : the policy has no 
requirements for the password. Note that quality constants are ordered so that 
higher values are more restrictive. 


*int_android.app.admin.DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY*

Flag for (|android.app.admin.DevicePolicyManager|) : don't allow other admins 
to change the password again until the user has entered it. 


*int_android.app.admin.DevicePolicyManager.WIPE_EXTERNAL_STORAGE*

Flag for (|android.app.admin.DevicePolicyManager|) : also erase the device's 
external storage. 



*android.app.admin.DevicePolicyManager.create(Context,Handler)*

public static |android.app.admin.DevicePolicyManager| create(
  android.content.Context context,
  android.os.Handler handler)





*android.app.admin.DevicePolicyManager.getActiveAdmins()*

public |java.util.List|<ComponentName> getActiveAdmins()

Return a list of all currently active device administrator's component names. 
Note that if there are no administrators than null may be returned. 



*android.app.admin.DevicePolicyManager.getAdminInfo(ComponentName)*

public |android.app.admin.DeviceAdminInfo| getAdminInfo(android.content.ComponentName cn)

Returns the DeviceAdminInfo as defined by the administrator's package info & 
meta-data 



*android.app.admin.DevicePolicyManager.getCameraDisabled(ComponentName)*

public boolean getCameraDisabled(android.content.ComponentName admin)

Determine whether or not the device's cameras have been disabled either by the 
current admin, if specified, or all admins. 


    admin - The name of the admin component to check, or null to check if any admins have 
       disabled the camera 

*android.app.admin.DevicePolicyManager.getCameraDisabled(ComponentName,int)*

public boolean getCameraDisabled(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getCurrentFailedPasswordAttempts()*

public int getCurrentFailedPasswordAttempts()

Retrieve the number of times the user has failed at entering a password since 
that last successful password entry. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 



*android.app.admin.DevicePolicyManager.getDeviceOwner()*

public |java.lang.String| getDeviceOwner()





*android.app.admin.DevicePolicyManager.getDeviceOwnerName()*

public |java.lang.String| getDeviceOwnerName()





*android.app.admin.DevicePolicyManager.getGlobalProxyAdmin()*

public |android.content.ComponentName| getGlobalProxyAdmin()

Returns the component name setting the global proxy. 



    Returns: ComponentName object of the device admin that set the global proxy, or null if 
             no admin has set the proxy. 

*android.app.admin.DevicePolicyManager.getKeyguardDisabledFeatures(ComponentName)*

public int getKeyguardDisabledFeatures(android.content.ComponentName admin)

Determine whether or not features have been disabled in keyguard either by the 
current admin, if specified, or all admins. 


    admin - The name of the admin component to check, or null to check if any admins have 
       disabled features in keyguard. 

    Returns: bitfield of flags. See {@link #setKeyguardDisabledFeatures(ComponentName, int)} 
             for a list. 

*android.app.admin.DevicePolicyManager.getKeyguardDisabledFeatures(ComponentName,int)*

public int getKeyguardDisabledFeatures(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getMaximumFailedPasswordsForWipe(ComponentName)*

public int getMaximumFailedPasswordsForWipe(android.content.ComponentName admin)

Retrieve the current maximum number of login attempts that are allowed before 
the device wipes itself, for all admins or a particular one. 


    admin - The name of the admin component to check, or null to aggregate all admins. 

*android.app.admin.DevicePolicyManager.getMaximumFailedPasswordsForWipe(ComponentName,int)*

public int getMaximumFailedPasswordsForWipe(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getMaximumTimeToLock(ComponentName)*

public long getMaximumTimeToLock(android.content.ComponentName admin)

Retrieve the current maximum time to unlock for all admins or a particular one. 


    admin - The name of the admin component to check, or null to aggregate all admins. 

*android.app.admin.DevicePolicyManager.getMaximumTimeToLock(ComponentName,int)*

public long getMaximumTimeToLock(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getPasswordExpiration(ComponentName)*

public long getPasswordExpiration(android.content.ComponentName admin)

Get the current password expiration time for the given admin or an aggregate of 
all admins if admin is null. If the password is expired, this will return the 
time since the password expired as a negative number. If admin is null, then a 
composite of all expiration timeouts is returned - which will be the minimum of 
all timeouts. 


    admin - The name of the admin component to check, or null to aggregate all admins. 

    Returns: The password expiration time, in ms. 

*android.app.admin.DevicePolicyManager.getPasswordExpirationTimeout(ComponentName)*

public long getPasswordExpirationTimeout(android.content.ComponentName admin)

Get the password expiration timeout for the given admin. The expiration timeout 
is the recurring expiration timeout provided in the call to 
(|android.app.admin.DevicePolicyManager|) for the given admin or the aggregate 
of all policy administrators if admin is null. 


    admin - The name of the admin component to check, or null to aggregate all admins. 

    Returns: The timeout for the given admin or the minimum of all timeouts 

*android.app.admin.DevicePolicyManager.getPasswordHistoryLength(ComponentName)*

public int getPasswordHistoryLength(android.content.ComponentName admin)

Retrieve the current password history length for all admins or a particular 
one. 


    admin - The name of the admin component to check, or null to aggregate all admins. 

    Returns: The length of the password history 

*android.app.admin.DevicePolicyManager.getPasswordHistoryLength(ComponentName,int)*

public int getPasswordHistoryLength(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getPasswordMaximumLength(int)*

public int getPasswordMaximumLength(int quality)

Return the maximum password length that the device supports for a particular 
password quality. 


    quality - The quality being interrogated. 

    Returns: Returns the maximum length that the user can enter. 

*android.app.admin.DevicePolicyManager.getPasswordMinimumLength(ComponentName)*

public int getPasswordMinimumLength(android.content.ComponentName admin)

Retrieve the current minimum password length for all admins or a particular 
one. 


    admin - The name of the admin component to check, or null to aggregate all admins. 

*android.app.admin.DevicePolicyManager.getPasswordMinimumLength(ComponentName,int)*

public int getPasswordMinimumLength(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getPasswordMinimumLetters(ComponentName)*

public int getPasswordMinimumLetters(android.content.ComponentName admin)

Retrieve the current number of letters required in the password for all admins 
or a particular one. This is the same value as set by {#link 
(|android.app.admin.DevicePolicyManager|) and only applies when the password 
quality is (|android.app.admin.DevicePolicyManager|) . 


    admin - The name of the admin component to check, or null to aggregate all admins. 

    Returns: The minimum number of letters required in the password. 

*android.app.admin.DevicePolicyManager.getPasswordMinimumLetters(ComponentName,int)*

public int getPasswordMinimumLetters(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getPasswordMinimumLowerCase(ComponentName)*

public int getPasswordMinimumLowerCase(android.content.ComponentName admin)

Retrieve the current number of lower case letters required in the password for 
all admins or a particular one. This is the same value as set by {#link 
(|android.app.admin.DevicePolicyManager|) and only applies when the password 
quality is (|android.app.admin.DevicePolicyManager|) . 


    admin - The name of the admin component to check, or null to aggregate all admins. 

    Returns: The minimum number of lower case letters required in the password. 

*android.app.admin.DevicePolicyManager.getPasswordMinimumLowerCase(ComponentName,int)*

public int getPasswordMinimumLowerCase(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getPasswordMinimumNonLetter(ComponentName)*

public int getPasswordMinimumNonLetter(android.content.ComponentName admin)

Retrieve the current number of non-letter characters required in the password 
for all admins or a particular one. This is the same value as set by {#link 
(|android.app.admin.DevicePolicyManager|) and only applies when the password 
quality is (|android.app.admin.DevicePolicyManager|) . 


    admin - The name of the admin component to check, or null to aggregate all admins. 

    Returns: The minimum number of letters required in the password. 

*android.app.admin.DevicePolicyManager.getPasswordMinimumNonLetter(ComponentName,int)*

public int getPasswordMinimumNonLetter(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getPasswordMinimumNumeric(ComponentName)*

public int getPasswordMinimumNumeric(android.content.ComponentName admin)

Retrieve the current number of numerical digits required in the password for 
all admins or a particular one. This is the same value as set by {#link 
(|android.app.admin.DevicePolicyManager|) and only applies when the password 
quality is (|android.app.admin.DevicePolicyManager|) . 


    admin - The name of the admin component to check, or null to aggregate all admins. 

    Returns: The minimum number of numerical digits required in the password. 

*android.app.admin.DevicePolicyManager.getPasswordMinimumNumeric(ComponentName,int)*

public int getPasswordMinimumNumeric(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getPasswordMinimumSymbols(ComponentName)*

public int getPasswordMinimumSymbols(android.content.ComponentName admin)

Retrieve the current number of symbols required in the password for all admins 
or a particular one. This is the same value as set by {#link 
(|android.app.admin.DevicePolicyManager|) and only applies when the password 
quality is (|android.app.admin.DevicePolicyManager|) . 


    admin - The name of the admin component to check, or null to aggregate all admins. 

    Returns: The minimum number of symbols required in the password. 

*android.app.admin.DevicePolicyManager.getPasswordMinimumSymbols(ComponentName,int)*

public int getPasswordMinimumSymbols(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getPasswordMinimumUpperCase(ComponentName)*

public int getPasswordMinimumUpperCase(android.content.ComponentName admin)

Retrieve the current number of upper case letters required in the password for 
all admins or a particular one. This is the same value as set by {#link 
(|android.app.admin.DevicePolicyManager|) and only applies when the password 
quality is (|android.app.admin.DevicePolicyManager|) . 


    admin - The name of the admin component to check, or null to aggregate all admins. 

    Returns: The minimum number of upper case letters required in the password. 

*android.app.admin.DevicePolicyManager.getPasswordMinimumUpperCase(ComponentName,int)*

public int getPasswordMinimumUpperCase(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getPasswordQuality(ComponentName)*

public int getPasswordQuality(android.content.ComponentName admin)

Retrieve the current minimum password quality for all admins or a particular 
one. 


    admin - The name of the admin component to check, or null to aggregate all admins. 

*android.app.admin.DevicePolicyManager.getPasswordQuality(ComponentName,int)*

public int getPasswordQuality(
  android.content.ComponentName admin,
  int userHandle)





*android.app.admin.DevicePolicyManager.getRemoveWarning(ComponentName,RemoteCallback)*

public void getRemoveWarning(
  android.content.ComponentName admin,
  android.os.RemoteCallback result)





*android.app.admin.DevicePolicyManager.getStorageEncryption(ComponentName)*

public boolean getStorageEncryption(android.content.ComponentName admin)

Called by an application that is administering the device to determine the 
requested setting for secure storage. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. If null, 
       this will return the requested encryption setting as an aggregate of all 
       active administrators. 

    Returns: true if the admin(s) are requesting encryption, false if not. 

*android.app.admin.DevicePolicyManager.getStorageEncryptionStatus()*

public int getStorageEncryptionStatus()

Called by an application that is administering the device to determine the 
current encryption status of the device. 

Depending on the returned status code, the caller may proceed in different 
ways. If the result is (|android.app.admin.DevicePolicyManager|) , the storage 
system does not support encryption. If the result is 
(|android.app.admin.DevicePolicyManager|) , use 
(|android.app.admin.DevicePolicyManager|) to begin the process of encrypting or 
decrypting the storage. If the result is 
(|android.app.admin.DevicePolicyManager|) or 
(|android.app.admin.DevicePolicyManager|) , no further action is required. 



    Returns: current status of encryption. The value will be one of {@link 
             #ENCRYPTION_STATUS_UNSUPPORTED}, {@link 
             #ENCRYPTION_STATUS_INACTIVE}, {@link 
             #ENCRYPTION_STATUS_ACTIVATING}, or{@link 
             #ENCRYPTION_STATUS_ACTIVE}. 

*android.app.admin.DevicePolicyManager.getStorageEncryptionStatus(int)*

public int getStorageEncryptionStatus(int userHandle)





*android.app.admin.DevicePolicyManager.hasAnyCaCertsInstalled()*

public static boolean hasAnyCaCertsInstalled()

Returns whether there are any user-installed CA certificates. 



*android.app.admin.DevicePolicyManager.hasCaCertInstalled(byte[])*

public boolean hasCaCertInstalled(byte[] certBuffer)

Returns whether this certificate has been installed as a User CA. 



*android.app.admin.DevicePolicyManager.hasGrantedPolicy(ComponentName,int)*

public boolean hasGrantedPolicy(
  android.content.ComponentName admin,
  int usesPolicy)

Returns true if an administrator has been granted a particular device policy. 
This can be used to check if the administrator was activated under an earlier 
set of policies, but requires additional policies after an upgrade. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. Must be an 
       active administrator, or an exception will be thrown. 
    usesPolicy - Which uses-policy to check, as defined in {@link DeviceAdminInfo}. 

*android.app.admin.DevicePolicyManager.installCaCert(byte[])*

public boolean installCaCert(byte[] certBuffer)

Installs the given certificate as a User CA. 



    Returns: false if the certBuffer cannot be parsed or installation is interrupted, 
             otherwise true 

*android.app.admin.DevicePolicyManager.isActivePasswordSufficient()*

public boolean isActivePasswordSufficient()

Determine whether the current password the user has set is sufficient to meet 
the policy requirements (quality, minimum length) that have been requested. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 



    Returns: Returns true if the password meets the current requirements, else false. 

*android.app.admin.DevicePolicyManager.isAdminActive(ComponentName)*

public boolean isAdminActive(android.content.ComponentName who)

Return true if the given administrator component is currently active (enabled) 
in the system. 



*android.app.admin.DevicePolicyManager.isDeviceOwner(String)*

public boolean isDeviceOwner(java.lang.String packageName)





*android.app.admin.DevicePolicyManager.isDeviceOwnerApp(String)*

public boolean isDeviceOwnerApp(java.lang.String packageName)

Used to determine if a particular package has been registered as a Device Owner 
app. A device owner app is a special device admin that cannot be deactivated by 
the user, once activated as a device admin. It also cannot be uninstalled. To 
check if a particular package is currently registered as the device owner app, 
pass in the package name from (|android.content.Context|) to this method.This 
is useful for device admin apps that want to check if they are also registered 
as the device owner app. The exact mechanism by which a device admin app is 
registered as a device owner app is defined by the setup process. 


    packageName - the package name of the app, to compare with the registered device owner app, 
       if any. 

    Returns: whether or not the package is registered as the device owner app. 

*android.app.admin.DevicePolicyManager.lockNow()*

public void lockNow()

Make the device lock immediately, as if the lock screen timeout has expired at 
the point of this call. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 



*android.app.admin.DevicePolicyManager.packageHasActiveAdmins(String)*

public boolean packageHasActiveAdmins(java.lang.String packageName)

Used by package administration code to determine if a package can be stopped or 
uninstalled. 



*android.app.admin.DevicePolicyManager.removeActiveAdmin(ComponentName)*

public void removeActiveAdmin(android.content.ComponentName who)

Remove a current administration component. This can only be called by the 
application that owns the administration component; if you try to remove 
someone else's component, a security exception will be thrown. 



*android.app.admin.DevicePolicyManager.reportFailedPasswordAttempt(int)*

public void reportFailedPasswordAttempt(int userHandle)





*android.app.admin.DevicePolicyManager.reportSuccessfulPasswordAttempt(int)*

public void reportSuccessfulPasswordAttempt(int userHandle)





*android.app.admin.DevicePolicyManager.resetPassword(String,int)*

public boolean resetPassword(
  java.lang.String password,
  int flags)

Force a new device unlock password (the password needed to access the entire 
device, not for individual accounts) on the user. This takes effect 
immediately. The given password must be sufficient for the current password 
quality and length constraints as returned by 
(|android.app.admin.DevicePolicyManager|) and 
(|android.app.admin.DevicePolicyManager|) ; if it does not meet these 
constraints, then it will be rejected and false returned. Note that the 
password may be a stronger quality (containing alphanumeric characters when the 
requested quality is only numeric), in which case the currently active quality 
will be increased to match. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    password - The new password for the user. 
    flags - May be 0 or {@link #RESET_PASSWORD_REQUIRE_ENTRY}. 

    Returns: Returns true if the password was applied, or false if it is not acceptable for 
             the current constraints. 

*android.app.admin.DevicePolicyManager.setActiveAdmin(ComponentName,boolean)*

public void setActiveAdmin(
  android.content.ComponentName policyReceiver,
  boolean refreshing)





*android.app.admin.DevicePolicyManager.setActivePasswordState(int,int,int,int,int,int,int,int,int)*

public void setActivePasswordState(
  int quality,
  int length,
  int letters,
  int uppercase,
  int lowercase,
  int numbers,
  int symbols,
  int nonletter,
  int userHandle)





*android.app.admin.DevicePolicyManager.setCameraDisabled(ComponentName,boolean)*

public void setCameraDisabled(
  android.content.ComponentName admin,
  boolean disabled)

Called by an application that is administering the device to disable all 
cameras on the device. After setting this, no applications will be able to 
access any cameras on the device. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    disabled - Whether or not the camera should be disabled. 

*android.app.admin.DevicePolicyManager.setDeviceOwner(String)*

public boolean setDeviceOwner(java.lang.String packageName)
  throws |java.lang.IllegalArgumentException|
         |java.lang.IllegalStateException|
         



    packageName - the package name of the application to be registered as the device owner. 

    Returns: whether the package was successfully registered as the device owner. 

*android.app.admin.DevicePolicyManager.setDeviceOwner(String,String)*

public boolean setDeviceOwner(
  java.lang.String packageName,
  java.lang.String ownerName)
  throws |java.lang.IllegalArgumentException|
         |java.lang.IllegalStateException|
         



    packageName - the package name of the application to be registered as the device owner. 
    ownerName - the human readable name of the institution that owns this device. 

    Returns: whether the package was successfully registered as the device owner. 

*android.app.admin.DevicePolicyManager.setGlobalProxy(ComponentName,Proxy,List<String>)*

public |android.content.ComponentName| setGlobalProxy(
  android.content.ComponentName admin,
  java.net.Proxy proxySpec,
  java.util.List<java.lang.String> exclusionList)

Called by an application that is administering the device to set the global 
proxy and exclusion list. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. Only the first device admin can set 
the proxy. If a second admin attempts to set the proxy, the 
(|android.content.ComponentName|) of the admin originally setting the proxy 
will be returned. If successful in setting the proxy, null will be returned. 
The method can be called repeatedly by the device admin alrady setting the 
proxy to update the proxy and exclusion list. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    proxySpec - the global proxy desired. Must be an HTTP Proxy. Pass Proxy.NO_PROXY to reset 
       the proxy. 
    exclusionList - a list of domains to be excluded from the global proxy. 

    Returns: returns null if the proxy was successfully set, or a {@link ComponentName} of 
             the device admin that sets thew proxy otherwise. 

*android.app.admin.DevicePolicyManager.setKeyguardDisabledFeatures(ComponentName,int)*

public void setKeyguardDisabledFeatures(
  android.content.ComponentName admin,
  int which)

Called by an application that is administering the device to disable keyguard 
customizations, such as widgets. After setting this, keyguard features will be 
disabled according to the provided feature list. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    which - {@link #KEYGUARD_DISABLE_FEATURES_NONE} (default), {@link 
       #KEYGUARD_DISABLE_WIDGETS_ALL}, {@link #KEYGUARD_DISABLE_SECURE_CAMERA}, 
       {@link #KEYGUARD_DISABLE_FEATURES_ALL} 

*android.app.admin.DevicePolicyManager.setMaximumFailedPasswordsForWipe(ComponentName,int)*

public void setMaximumFailedPasswordsForWipe(
  android.content.ComponentName admin,
  int num)

Setting this to a value greater than zero enables a built-in policy that will 
perform a device wipe after too many incorrect device-unlock passwords have 
been entered. This built-in policy combines watching for failed passwords and 
wiping the device, and requires that you request both 
(|android.app.admin.DeviceAdminInfo|) and (|android.app.admin.DeviceAdminInfo|) 
}. 

To implement any other policy (e.g. wiping data for a particular application 
only, erasing or revoking credentials, or reporting the failure to a server), 
you should implement (|android.app.admin.DeviceAdminReceiver|) instead. Do not 
use this API, because if the maximum count is reached, the device will be wiped 
immediately, and your callback will not be invoked. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    num - The number of failed password attempts at which point the device will wipe its 
       data. 

*android.app.admin.DevicePolicyManager.setMaximumTimeToLock(ComponentName,long)*

public void setMaximumTimeToLock(
  android.content.ComponentName admin,
  long timeMs)

Called by an application that is administering the device to set the maximum 
time for user activity until the device will lock. This limits the length that 
the user can set. It takes effect immediately. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    timeMs - The new desired maximum time to lock in milliseconds. A value of 0 means there 
       is no restriction. 

*android.app.admin.DevicePolicyManager.setPasswordExpirationTimeout(ComponentName,long)*

public void setPasswordExpirationTimeout(
  android.content.ComponentName admin,
  long timeout)

Called by a device admin to set the password expiration timeout. Calling this 
method will restart the countdown for password expiration for the given admin, 
as will changing the device password (for all admins). 

The provided timeout is the time delta in ms and will be added to the current 
time. For example, to have the password expire 5 days from now, timeout would 
be 5 * 86400 * 1000 = 432000000 ms for timeout. 

To disable password expiration, a value of 0 may be used for timeout. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    timeout - The limit (in ms) that a password can remain in effect. A value of 0 means 
       there is no restriction (unlimited). 

*android.app.admin.DevicePolicyManager.setPasswordHistoryLength(ComponentName,int)*

public void setPasswordHistoryLength(
  android.content.ComponentName admin,
  int length)

Called by an application that is administering the device to set the length of 
the password history. After setting this, the user will not be able to enter a 
new password that is the same as any password in the history. Note that the 
current password will remain until the user has set a new one, so the change 
does not take place immediately. To prompt the user for a new password, use 
(|android.app.admin.DevicePolicyManager|) after setting this value. This 
constraint is only imposed if the administrator has also requested either 
(|android.app.admin.DevicePolicyManager|) , 
(|android.app.admin.DevicePolicyManager|) , or 
(|android.app.admin.DevicePolicyManager|) with 
(|android.app.admin.DevicePolicyManager|) . 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    length - The new desired length of password history. A value of 0 means there is no 
       restriction. 

*android.app.admin.DevicePolicyManager.setPasswordMinimumLength(ComponentName,int)*

public void setPasswordMinimumLength(
  android.content.ComponentName admin,
  int length)

Called by an application that is administering the device to set the minimum 
allowed password length. After setting this, the user will not be able to enter 
a new password that is not at least as restrictive as what has been set. Note 
that the current password will remain until the user has set a new one, so the 
change does not take place immediately. To prompt the user for a new password, 
use (|android.app.admin.DevicePolicyManager|) after setting this value. This 
constraint is only imposed if the administrator has also requested either 
(|android.app.admin.DevicePolicyManager|) , 
(|android.app.admin.DevicePolicyManager|) 
(|android.app.admin.DevicePolicyManager|) , or 
(|android.app.admin.DevicePolicyManager|) with 
(|android.app.admin.DevicePolicyManager|) . 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    length - The new desired minimum password length. A value of 0 means there is no 
       restriction. 

*android.app.admin.DevicePolicyManager.setPasswordMinimumLetters(ComponentName,int)*

public void setPasswordMinimumLetters(
  android.content.ComponentName admin,
  int length)

Called by an application that is administering the device to set the minimum 
number of letters required in the password. After setting this, the user will 
not be able to enter a new password that is not at least as restrictive as what 
has been set. Note that the current password will remain until the user has set 
a new one, so the change does not take place immediately. To prompt the user 
for a new password, use (|android.app.admin.DevicePolicyManager|) after setting 
this value. This constraint is only imposed if the administrator has also 
requested (|android.app.admin.DevicePolicyManager|) with 
(|android.app.admin.DevicePolicyManager|) . The default value is 1. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    length - The new desired minimum number of letters required in the password. A value of 
       0 means there is no restriction. 

*android.app.admin.DevicePolicyManager.setPasswordMinimumLowerCase(ComponentName,int)*

public void setPasswordMinimumLowerCase(
  android.content.ComponentName admin,
  int length)

Called by an application that is administering the device to set the minimum 
number of lower case letters required in the password. After setting this, the 
user will not be able to enter a new password that is not at least as 
restrictive as what has been set. Note that the current password will remain 
until the user has set a new one, so the change does not take place 
immediately. To prompt the user for a new password, use 
(|android.app.admin.DevicePolicyManager|) after setting this value. This 
constraint is only imposed if the administrator has also requested 
(|android.app.admin.DevicePolicyManager|) with 
(|android.app.admin.DevicePolicyManager|) . The default value is 0. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    length - The new desired minimum number of lower case letters required in the password. 
       A value of 0 means there is no restriction. 

*android.app.admin.DevicePolicyManager.setPasswordMinimumNonLetter(ComponentName,int)*

public void setPasswordMinimumNonLetter(
  android.content.ComponentName admin,
  int length)

Called by an application that is administering the device to set the minimum 
number of non-letter characters (numerical digits or symbols) required in the 
password. After setting this, the user will not be able to enter a new password 
that is not at least as restrictive as what has been set. Note that the current 
password will remain until the user has set a new one, so the change does not 
take place immediately. To prompt the user for a new password, use 
(|android.app.admin.DevicePolicyManager|) after setting this value. This 
constraint is only imposed if the administrator has also requested 
(|android.app.admin.DevicePolicyManager|) with 
(|android.app.admin.DevicePolicyManager|) . The default value is 0. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    length - The new desired minimum number of letters required in the password. A value of 
       0 means there is no restriction. 

*android.app.admin.DevicePolicyManager.setPasswordMinimumNumeric(ComponentName,int)*

public void setPasswordMinimumNumeric(
  android.content.ComponentName admin,
  int length)

Called by an application that is administering the device to set the minimum 
number of numerical digits required in the password. After setting this, the 
user will not be able to enter a new password that is not at least as 
restrictive as what has been set. Note that the current password will remain 
until the user has set a new one, so the change does not take place 
immediately. To prompt the user for a new password, use 
(|android.app.admin.DevicePolicyManager|) after setting this value. This 
constraint is only imposed if the administrator has also requested 
(|android.app.admin.DevicePolicyManager|) with 
(|android.app.admin.DevicePolicyManager|) . The default value is 1. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    length - The new desired minimum number of numerical digits required in the password. A 
       value of 0 means there is no restriction. 

*android.app.admin.DevicePolicyManager.setPasswordMinimumSymbols(ComponentName,int)*

public void setPasswordMinimumSymbols(
  android.content.ComponentName admin,
  int length)

Called by an application that is administering the device to set the minimum 
number of symbols required in the password. After setting this, the user will 
not be able to enter a new password that is not at least as restrictive as what 
has been set. Note that the current password will remain until the user has set 
a new one, so the change does not take place immediately. To prompt the user 
for a new password, use (|android.app.admin.DevicePolicyManager|) after setting 
this value. This constraint is only imposed if the administrator has also 
requested (|android.app.admin.DevicePolicyManager|) with 
(|android.app.admin.DevicePolicyManager|) . The default value is 1. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    length - The new desired minimum number of symbols required in the password. A value of 
       0 means there is no restriction. 

*android.app.admin.DevicePolicyManager.setPasswordMinimumUpperCase(ComponentName,int)*

public void setPasswordMinimumUpperCase(
  android.content.ComponentName admin,
  int length)

Called by an application that is administering the device to set the minimum 
number of upper case letters required in the password. After setting this, the 
user will not be able to enter a new password that is not at least as 
restrictive as what has been set. Note that the current password will remain 
until the user has set a new one, so the change does not take place 
immediately. To prompt the user for a new password, use 
(|android.app.admin.DevicePolicyManager|) after setting this value. This 
constraint is only imposed if the administrator has also requested 
(|android.app.admin.DevicePolicyManager|) with 
(|android.app.admin.DevicePolicyManager|) . The default value is 0. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    length - The new desired minimum number of upper case letters required in the password. 
       A value of 0 means there is no restriction. 

*android.app.admin.DevicePolicyManager.setPasswordQuality(ComponentName,int)*

public void setPasswordQuality(
  android.content.ComponentName admin,
  int quality)

Called by an application that is administering the device to set the password 
restrictions it is imposing. After setting this, the user will not be able to 
enter a new password that is not at least as restrictive as what has been set. 
Note that the current password will remain until the user has set a new one, so 
the change does not take place immediately. To prompt the user for a new 
password, use (|android.app.admin.DevicePolicyManager|) after setting this 
value. 

Quality constants are ordered so that higher values are more restrictive; thus 
the highest requested quality constant (between the policy set here, the user's 
preference, and any other considerations) is the one that is in effect. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    quality - The new desired quality. One of {@link #PASSWORD_QUALITY_UNSPECIFIED}, {@link 
       #PASSWORD_QUALITY_SOMETHING}, {@link #PASSWORD_QUALITY_NUMERIC}, {@link 
       #PASSWORD_QUALITY_ALPHABETIC}, {@link #PASSWORD_QUALITY_ALPHANUMERIC} or 
       {@link #PASSWORD_QUALITY_COMPLEX}. 

*android.app.admin.DevicePolicyManager.setStorageEncryption(ComponentName,boolean)*

public int setStorageEncryption(
  android.content.ComponentName admin,
  boolean encrypt)

Called by an application that is administering the device to request that the 
storage system be encrypted. 

When multiple device administrators attempt to control device encryption, the 
most secure, supported setting will always be used. If any device administrator 
requests device encryption, it will be enabled; Conversely, if a device 
administrator attempts to disable device encryption while another device 
administrator has enabled it, the call to disable will fail (most commonly 
returning (|android.app.admin.DevicePolicyManager|) ). 

This policy controls encryption of the secure (application data) storage area. 
Data written to other storage areas may or may not be encrypted, and this 
policy does not require or control the encryption of any other storage areas. 
There is one exception: If (|android.os.Environment|) istrue, then the 
directory returned by (|android.os.Environment|) must be written to disk within 
the encrypted storage area. 

Important Note: On some devices, it is possible to encrypt storage without 
requiring the user to create a device PIN or Password. In this case, the 
storage is encrypted, but the encryption key may not be fully secured. For 
maximum security, the administrator should also require (and check for) a 
pattern, PIN, or password. 


    admin - Which {@link DeviceAdminReceiver} this request is associated with. 
    encrypt - true to request encryption, false to release any previous request 

    Returns: the new request status (for all active admins) - will be one of {@link 
             #ENCRYPTION_STATUS_UNSUPPORTED}, {@link 
             #ENCRYPTION_STATUS_INACTIVE}, or {@link 
             #ENCRYPTION_STATUS_ACTIVE}. This is the value of the requests; Use 
             {@link #getStorageEncryptionStatus()} to query the actual device 
             state. 

*android.app.admin.DevicePolicyManager.uninstallCaCert(byte[])*

public void uninstallCaCert(byte[] certBuffer)

Uninstalls the given certificate from the list of User CAs, if present. 



*android.app.admin.DevicePolicyManager.wipeData(int)*

public void wipeData(int flags)

Ask the user date be wiped. This will cause the device to reboot, erasing all 
user data while next booting up. External storage such as SD cards will be also 
erased if the flag (|android.app.admin.DevicePolicyManager|) is set. 

The calling device admin must have requested 
(|android.app.admin.DeviceAdminInfo|) to be able to call this method; if it has 
not, a security exception will be thrown. 


    flags - Bit mask of additional options: currently 0 and {@link #WIPE_EXTERNAL_STORAGE} 
       are supported. 


